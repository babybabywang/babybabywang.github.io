<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常用数据库表优化和SKU及SPU表结构分析</title>
      <link href="/2019/02/16/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%BC%98%E5%8C%96%E5%92%8CSKU%E5%8F%8ASPU%E8%A1%A8%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/2019/02/16/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%BC%98%E5%8C%96%E5%92%8CSKU%E5%8F%8ASPU%E8%A1%A8%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><h2 id="常用数据库表优化"><a href="#常用数据库表优化" class="headerlink" title="常用数据库表优化"></a>常用数据库表优化</h2><h3 id="1-表垂直拆分"><a href="#1-表垂直拆分" class="headerlink" title="1.表垂直拆分"></a>1.表垂直拆分</h3><blockquote><p>1.对于表中字段数量打的一系列字段可以使用表的垂直拆分将大的字段拆分出去</p><p>2.对于一张表中如果存在经常不修改的字段和需要大量修改的字段可以使用垂直拆分将需要修改的字段拆分出去</p><p>3.对于多字段表可以尝试面向对象的思想，创建表使用列级</p><p>4.对于需要查询多个字段可以定义一个索引，根据索引可以快速定位字段</p></blockquote><p><em>后期扩展</em></p><h3 id="2-SKU及SPU表结构分析"><a href="#2-SKU及SPU表结构分析" class="headerlink" title="2.SKU及SPU表结构分析"></a>2.SKU及SPU表结构分析</h3><p>看一下spu的表结构和spu垂直拆分出的结构</p><figure class="highlight plain"><figcaption><span>TABLE `tb_spu` (</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;spu id&apos;,</span><br><span class="line">  `name` varchar(128) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;商品名称&apos;,</span><br><span class="line">  `sub_title` varchar(256) DEFAULT &apos;&apos; COMMENT &apos;子标题&apos;,</span><br><span class="line">  `cid1` bigint(20) NOT NULL COMMENT &apos;1级类目id&apos;,</span><br><span class="line">  `cid2` bigint(20) NOT NULL COMMENT &apos;2级类目id&apos;,</span><br><span class="line">  `cid3` bigint(20) NOT NULL COMMENT &apos;3级类目id&apos;,</span><br><span class="line">  `brand_id` bigint(20) NOT NULL COMMENT &apos;商品所属品牌id&apos;,</span><br><span class="line">  `saleable` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否上架，0下架，1上架&apos;,</span><br><span class="line">  `valid` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否有效，0已删除，1有效&apos;,</span><br><span class="line">  `create_time` datetime DEFAULT NULL COMMENT &apos;添加时间&apos;,</span><br><span class="line">  `last_update_time` datetime DEFAULT NULL COMMENT &apos;最后修改时间&apos;,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=196 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT=&apos;spu表，该表描述的是一个抽象性的商品，比如 iphone8&apos;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>TABLE `tb_spu_detail` (</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  `spu_id` bigint(20) NOT NULL,</span><br><span class="line">  `description` text COMMENT &apos;商品描述信息&apos;,</span><br><span class="line">  `generic_spec` varchar(2048) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;通用规格参数数据&apos;,</span><br><span class="line">  `special_spec` varchar(1024) NOT NULL COMMENT &apos;特有规格参数及可选值信息，json格式&apos;,</span><br><span class="line">  `packing_list` varchar(1024) DEFAULT &apos;&apos; COMMENT &apos;包装清单&apos;,</span><br><span class="line">  `after_service` varchar(1024) DEFAULT &apos;&apos; COMMENT &apos;售后服务&apos;,</span><br><span class="line">  PRIMARY KEY (`spu_id`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure><blockquote><p>我们可以知道的是，像一些大数据量的字段都拆分出spu_detail中，这里也要说明下Spu是什么?</p><p>SPU：Standard Product Unit （标准产品单位） ，一组具有共同属性的商品集</p><p>SKU：Stock Keeping Unit（库存量单位），SPU商品集因具体特性不同而细分的每个商品</p><p>SPU可以理解的是存一个共享属性，因此根据京东的页面我们可以分析出来它一些共享的属性。</p><p>SPU表中的字段我们没什么好解释的基本上都可以知道，Spu_detail中的几个字段我们需要解释一下，比如</p><p>generic_spec这个字段是存的一个通用规格的JSON串，也就是说一些同一种商品它通用规格的value值存放在这地方他的格式为:规格参数ID:规格参数值</p><p>special_spec:这些为页面进去后可以选择的信息</p></blockquote><p>看一下sku表结构和sku垂直拆分出去的结构</p><figure class="highlight plain"><figcaption><span>TABLE `tb_sku` (</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;sku id&apos;,</span><br><span class="line">  `spu_id` bigint(20) NOT NULL COMMENT &apos;spu id&apos;,</span><br><span class="line">  `title` varchar(256) NOT NULL COMMENT &apos;商品标题&apos;,</span><br><span class="line">  `images` varchar(1024) DEFAULT &apos;&apos; COMMENT &apos;商品的图片，多个图片以‘,’分割&apos;,</span><br><span class="line">  `price` bigint(15) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;销售价格，单位为分&apos;,</span><br><span class="line">  `indexes` varchar(32) DEFAULT &apos;&apos; COMMENT &apos;特有规格属性在spu属性模板中的对应下标组合&apos;,</span><br><span class="line">  `own_spec` varchar(1024) DEFAULT &apos;&apos; COMMENT &apos;sku的特有规格参数键值对，json格式，反序列化时请使用linkedHashMap，保证有序&apos;,</span><br><span class="line">  `enable` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否有效，0无效，1有效&apos;,</span><br><span class="line">  `create_time` datetime NOT NULL COMMENT &apos;添加时间&apos;,</span><br><span class="line">  `last_update_time` datetime NOT NULL COMMENT &apos;最后修改时间&apos;,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE,</span><br><span class="line">  KEY `key_spu_id` (`spu_id`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=27359021730 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT=&apos;sku表,该表表示具体的商品实体,如黑色的 64g的iphone 8&apos;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>TABLE `tb_stock` (</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  `sku_id` bigint(20) NOT NULL COMMENT &apos;库存对应的商品sku id&apos;,</span><br><span class="line">  `seckill_stock` int(9) DEFAULT &apos;0&apos; COMMENT &apos;可秒杀库存&apos;,</span><br><span class="line">  `seckill_total` int(9) DEFAULT &apos;0&apos; COMMENT &apos;秒杀总数量&apos;,</span><br><span class="line">  `stock` int(9) NOT NULL COMMENT &apos;库存数量&apos;,</span><br><span class="line">  PRIMARY KEY (`sku_id`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT=&apos;库存表，代表库存，秒杀库存等信息&apos;;</span><br></pre></td></tr></table></figure><blockquote><p>这里因为库存信息需要频繁的修改因此将这些属性垂直拆分出来。</p><p>sku存储的为商品的特有属性，这里可以看出来比如说商品的标题，图片等都是特有属性</p><p>这里我们要注意的是indexes和ovn_spec这俩个字段</p></blockquote><h4 id="3-2-2-1-indexes字段"><a href="#3-2-2-1-indexes字段" class="headerlink" title="3.2.2.1.indexes字段"></a>3.2.2.1.indexes字段</h4><p>在SPU表中，已经对特有规格参数及可选项进行了保存，结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"机身颜色"</span>: [</span><br><span class="line">        <span class="string">"香槟金"</span>,</span><br><span class="line">        <span class="string">"樱花粉"</span>,</span><br><span class="line">        <span class="string">"磨砂黑"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"内存"</span>: [</span><br><span class="line">        <span class="string">"2GB"</span>,</span><br><span class="line">        <span class="string">"3GB"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"机身存储"</span>: [</span><br><span class="line">        <span class="string">"16GB"</span>,</span><br><span class="line">        <span class="string">"32GB"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些特有属性如果排列组合，会产生12个不同的SKU，而不同的SKU，其属性就是上面备选项中的一个。</p><p>比如：</p><ul><li>红米4X，香槟金，2GB内存，16GB存储</li><li>红米4X，磨砂黑，2GB内存，32GB存储</li></ul><p>你会发现，每一个属性值，对应于SPUoptions数组的一个选项，如果我们记录下角标，就是这样：</p><ul><li>红米4X，0,0,0</li><li>红米4X，2,0,1</li></ul><p>既然如此，我们是不是可以将不同角标串联起来，作为SPU下不同SKU的标示。这就是我们的indexes字段。</p><p> <img src="/2019/02/16/常用数据库表优化和SKU及SPU表结构分析/1526266901335.png" alt="1526266901335"></p><p>这个设计在商品详情页会特别有用：</p><p> <img src="/2019/02/16/常用数据库表优化和SKU及SPU表结构分析/1526267180997.png" alt="1526267180997"></p><p>当用户点击选中一个特有属性，你就能根据 角标快速定位到sku。</p><h4 id="3-2-2-2-own-spec字段"><a href="#3-2-2-2-own-spec字段" class="headerlink" title="3.2.2.2.own_spec字段"></a>3.2.2.2.own_spec字段</h4><p>看结构：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"机身颜色"</span>:<span class="string">"香槟金"</span>,<span class="attr">"内存"</span>:<span class="string">"2GB"</span>,<span class="attr">"机身存储"</span>:<span class="string">"16GB"</span>&#125;</span><br></pre></td></tr></table></figure><p>保存的是特有属性的键值对。</p><p>SPU中保存的是可选项，但不确定具体的值，而SKU中的保存的就是具体的键值对了。</p><p>这样，在页面展示规格参数信息时，就可以根据key来获取值，用于显示。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> spu </tag>
            
            <tag> sku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决webpack-dev-server的host解析问题和Nginx基本反向代理配置</title>
      <link href="/2019/02/12/%E8%A7%A3%E5%86%B3webpack-dev-server%E7%9A%84host%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98%E5%92%8CNginx%E5%9F%BA%E6%9C%AC%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/02/12/%E8%A7%A3%E5%86%B3webpack-dev-server%E7%9A%84host%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98%E5%92%8CNginx%E5%9F%BA%E6%9C%AC%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-解决域名解析问题"><a href="#1-解决域名解析问题" class="headerlink" title="1.解决域名解析问题"></a>1.解决域名解析问题</h1><blockquote><p>开发前端工程的时候，本地域名解析后发现使用解析的域名访问Vue应用报错invalid host header;</p><p>原因：我们配置了项目访问的路径，虽然域名映射的IP也是127.0.0.1，但是webpack会验证host是否符合配置。</p></blockquote><p><img src="/2019/02/12/解决webpack-dev-server的host解析问题和Nginx基本反向代理配置/问题根源.PNG" alt="问题根源"></p><blockquote><p>在webpack.dev.conf.js中取消host验证：</p></blockquote><p><img src="/2019/02/12/解决webpack-dev-server的host解析问题和Nginx基本反向代理配置/取消host验证.PNG" alt="取消host验证"></p><blockquote><p>重新执行<code>npm run dev</code>，刷新浏览器，解决成功</p></blockquote><h1 id="2-Nginx反向代理配置"><a href="#2-Nginx反向代理配置" class="headerlink" title="2.Nginx反向代理配置"></a>2.Nginx反向代理配置</h1><ol><li><p>拉取nginx镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure></li><li><p>启动nginx容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mynginx -p 80:80 -v $PWD/conf:/etc/nginx/nginx.conf nginx</span><br></pre></td></tr></table></figure></li><li><p>修改nginx配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">     <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  反向代理域名;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Server <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://主机IP:9001;</span><br><span class="line"><span class="attribute">proxy_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line"><span class="attribute">proxy_read_timeout</span> <span class="number">600</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改vue工程对host的默认配置(解决网关报错502的问题)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host: <span class="string">'0.0.0.0'</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="3-Nginx流程图"><a href="#3-Nginx流程图" class="headerlink" title="3.Nginx流程图"></a>3.Nginx流程图</h1><p><img src="/2019/02/12/解决webpack-dev-server的host解析问题和Nginx基本反向代理配置/反向代理流程.png" alt="反向代理流程"></p><h1 id="4-文件上传优化"><a href="#4-文件上传优化" class="headerlink" title="4.文件上传优化"></a>4.文件上传优化</h1><blockquote><p>SpringCloud中的文件上传会多次用到，因此需要特地创建一个文件上传的微服务。</p></blockquote><p><strong>话不多少上代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt;ALLOW_TYPES =Arrays.asList(<span class="string">"image/jpeg"</span>,<span class="string">"image/png"</span>,<span class="string">"image/bmp"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String type = file.getContentType();</span><br><span class="line">        <span class="keyword">if</span> (!ALLOW_TYPES.contains(type))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LyException(ExceptionEnums.FILE_TYPE_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//校验文件内容</span></span><br><span class="line">        BufferedImage read = ImageIO.read(file.getInputStream());</span><br><span class="line">        <span class="keyword">if</span> (read==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LyException(ExceptionEnums.FILE_TYPE_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        File dest = <span class="keyword">new</span> File(<span class="string">"D:\\image"</span>, file.getOriginalFilename());</span><br><span class="line">        file.transferTo(dest);</span><br><span class="line">        <span class="keyword">return</span> dest.getAbsolutePath();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">//上传失败</span></span><br><span class="line">        log.error(<span class="string">"上传失败"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LyException(ExceptionEnums.FILE_UPLOAD_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段代码是一个简单的文件上传逻辑，见文件传到本地固定的目录下，做了一些文件的校验和类型的校验，</p><p>因为使用SpringCloud微服务会涉及到网关，这里我们需要让我们的图片上传微服务绕过网关，这里官方闻到文档也推荐这样，因为Zuul网关底层是Servlet它还是需要依赖SpringMvc的实体解析器，zuul每次会将进过网关的内容缓存。图片上传是文件的传输，如果也经过Zuul网关的代理，文件就会经过多次网路传输，造成不必要的网络负担。在高并发时，可能导致网络阻塞，Zuul网关不可用。这样我们的整个系统就瘫痪了。所以，我们上传文件的请求就不经过网关来处理了。</p></blockquote><h3 id="绕过Zuul网关配置"><a href="#绕过Zuul网关配置" class="headerlink" title="绕过Zuul网关配置"></a>绕过Zuul网关配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  ignored-services:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">upload-service</span></span><br></pre></td></tr></table></figure><blockquote><p>这样的话前端因为访问的是网关的地址，因此我们的文件上传微服务前台就无法使用了，所以需要利用niginx的rewrite指令来重写一个路径用于文件上传使用，话不多说上配置了。</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /api/upload &#123;</span><br><span class="line">       <span class="attribute">proxy_pass</span> http://宿主机IP:8082;</span><br><span class="line"><span class="attribute">proxy_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line"><span class="attribute">proxy_read_timeout</span> <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">rewrite</span> <span class="string">"^/api/(.*)$"</span> /<span class="variable">$1</span> <span class="literal">break</span>; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>rewrite &quot;用来匹配路径的正则&quot; 重写后的路径 [指令];</code></p><ul><li><p>首先，我们映射路径是/api/upload，而下面一个映射路径是 / ，根据最长路径匹配原则，/api/upload优先级更高。也就是说，凡是以/api/upload开头的路径，都会被第一个配置处理</p></li><li><p><code>proxy_pass</code>：反向代理，这次我们代理到8082端口，也就是upload-service服务</p></li><li><p><code>rewrite &quot;^/api/(.*)$&quot; /$1 break</code>，路径重写：</p><ul><li><p><code>&quot;^/api/(.*)$&quot;</code>：匹配路径的正则表达式，用了分组语法，把<code>/api/</code>以后的所有部分当做1组</p></li><li><p><code>/$1</code>：重写的目标路径，这里用$1引用前面正则表达式匹配到的分组（组编号从1开始），即<code>/api/</code>后面的所有。这样新的路径就是除去<code>/api/</code>以外的所有，就达到了去除<code>/api</code>前缀的目的</p></li><li><p><code>break</code>：指令，常用的有2个，分别是：last、break</p><ul><li>last：重写路径结束后，将得到的路径重新进行一次路径匹配</li><li>break：重写路径结束后，不再重新匹配路径。</li></ul><p>我们这里不能选择last，否则以新的路径/upload/image来匹配，就不会被正确的匹配到8082端口了</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> docker </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊服务端渲染技术NUXT</title>
      <link href="/2019/02/05/%E8%81%8A%E8%81%8A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AFNUXT/"/>
      <url>/2019/02/05/%E8%81%8A%E8%81%8A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AFNUXT/</url>
      
        <content type="html"><![CDATA[<h1 id="服务端渲染技术NUXT"><a href="#服务端渲染技术NUXT" class="headerlink" title="服务端渲染技术NUXT"></a>服务端渲染技术NUXT</h1><pre><code>说到NUXT首先我们要了解下什么是服务端渲染?    服务端渲染又称SSR (Server Side Render)是在服务端完成页面的内容，而不是在客户端通过AJAX获取数据。    与传统 SPA（Single-Page Application - 单页应用程序）相比，服务器端渲染(SSR)的优势主要在于：更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。    请注意，截至目前，Google 和 Bing 可以很好对同步 JavaScript 应用程序进行索引。在这里，同步是关键。如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题。    更快的内容到达时间(time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验，并且对于那些「内容到达时间(time-to-content)与转化率直接相关」的应用程序而言，服务器端渲染(SSR)至关重要。</code></pre><h2 id="什么是NUXT"><a href="#什么是NUXT" class="headerlink" title="什么是NUXT"></a>什么是NUXT</h2><blockquote><p>Nuxt.js 是一个基于 Vue.js 的轻量级应用框架,可用来创建服务端渲染 (SSR) 应用,也可充当静态站点引擎生成静态站点应用,具有优雅的代码结构分层和热加载等特点。</p></blockquote><p><a href="https://zh.nuxtjs.org/" target="_blank" rel="noopener">Nuxt.js官网</a></p><h2 id="NUXT环境搭建"><a href="#NUXT环境搭建" class="headerlink" title="NUXT环境搭建"></a>NUXT环境搭建</h2><p>1.我们从网站上<a href="https://github.com/nuxt-community/starter-template/archive/master.zip" target="_blank" rel="noopener">下载模板</a>的压缩包 starter-template-master.zip 解压，修改template目录目录的package.json中的名称<br>2.在命令提示符下进入该目录下的template目录<br>3.安装依赖</p><pre><code>npm install</code></pre><p>4.修改package.json</p><pre><code>......&quot;name&quot;: &quot;studyNuxt&quot;,......</code></pre><p>5.修改nuxt.config.js</p><pre><code>......title: &apos;学习NUXT&apos;......</code></pre><p>6.测试运行</p><pre><code>npm run dev</code></pre><h2 id="NUXT的目录结果"><a href="#NUXT的目录结果" class="headerlink" title="NUXT的目录结果"></a>NUXT的目录结果</h2><p>1.资源目录 assets</p><pre><code>用于组织未编译的静态资源如 LESS、SASS 或 JavaScrip</code></pre><p>2.组件目录 components</p><pre><code>用于组织应用的 Vue.js 组件。Nuxt.js 不会扩展增强该目录下 Vue.js 组件，即这些组件不会像页面组件那样有 asyncData 方法的特性。</code></pre><p>3.布局目录 layouts</p><pre><code>用于组织应用的布局组件</code></pre><p>4.页面目录 pages</p><pre><code>用于组织应用的路由及视图。Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。</code></pre><p>5.插件目录 plugins</p><pre><code>用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。</code></pre><p>6.nuxt.config.js 文件</p><pre><code>nuxt.config.js 文件用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。</code></pre><h2 id="NUXT快速入门"><a href="#NUXT快速入门" class="headerlink" title="NUXT快速入门"></a>NUXT快速入门</h2><h3 id="定义布局"><a href="#定义布局" class="headerlink" title="定义布局"></a>定义布局</h3><blockquote><p>我们通常的网站头部和尾部都是相同的，我们可以把头部为尾部提取出来，形成布局页</p></blockquote><pre><code>1.修改layouts目录下default.vue&lt;template&gt;  &lt;div&gt;    &lt;header&gt;NUXT布局&lt;/header&gt;    &lt;nuxt/&gt;    &lt;footer&gt;&lt;a href=&quot;https://www.babywang.huangsm.xyz&quot;&gt;个人博客&lt;/a&gt;&lt;/footer&gt;  &lt;/div&gt;&lt;/template&gt;&lt;nuxt/&gt;为内容的区域,在pages目录下</code></pre><h3 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h3><blockquote><p>在page目录创建文件夹(NUXT的路由是根据目录自动生成的，无需手写)</p></blockquote><p><img src="/2019/02/05/聊聊服务端渲染技术NUXT/页面路由.png" alt="页面路由"></p><pre><code>修改default.vue，header中添加导航链接&lt;template&gt;  &lt;div&gt;    &lt;header&gt;      &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;      &lt;router-link to=&quot;/recruit&quot;&gt;招聘&lt;/router-link&gt;      &lt;router-link to=&quot;/gathering&quot;&gt;活动&lt;/router-link&gt;    &lt;/header&gt;    &lt;nuxt/&gt;    &lt;footer&gt;      &lt;a href=&quot;https://www.babywang.huangsm.xyz&quot;&gt;个人博客&lt;/a&gt;    &lt;/footer&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="数据渲染"><a href="#数据渲染" class="headerlink" title="数据渲染"></a>数据渲染</h3><pre><code>1.安装axios，用于异步获取数据cnpm install axios --save2.修改gathering目录的index.vue&lt;template&gt;  &lt;div&gt;    &lt;b&gt;活动列表&lt;/b&gt;    &lt;div v-for=&quot;(item,index) in items&quot; :key=&quot;index&quot;&gt;{{item.name}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//加载活动列表中的全部name信息import axios from &quot;axios&quot;;export default {  asyncData() {    return axios      .get(        &quot;https://www.easy-mock.com/mock/5c57b3a6de5c260cd71d3b8d/api/gathering&quot;      )      .then(response =&gt; {        //console.log(JSON.stringify(response.data));        return { items: response.data.data };      });    console.log(&quot;这是在服务端运行的方法&quot;);  }};&lt;/script&gt;asyncData是用于异步加载数据的方法</code></pre><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><blockquote><p>如果我们需要根据ID查询活动详情，就需要使用动态路由。NUXT的动态路由是以下划线开头的vue文件，参数名为下划线后边的文件名</p></blockquote><pre><code>1.创建pages/gathering/item/_id.vue&lt;template&gt;  &lt;div&gt;    &lt;b&gt;活动详情&lt;/b&gt;    {{item.id}}    &lt;br&gt;    {{item.name}}  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//根据ID查询活动详情import axios from &quot;axios&quot;;export default {  asyncData({ params }) {    //params.id    return axios      .get(        `https://www.easy-mock.com/mock/5c57b3a6de5c260cd71d3b8d/api/gathering/${params.id}`      )      .then(response =&gt; {        return { item: response.data.data };      });  }};&lt;/script&gt;2.在活动列表页点击链接进入详情页 &lt;!-- &lt;router-link :to=&quot;&apos;/gathering/item/&apos;+item.id&quot;&gt; {{item.name}}&lt;/router-link&gt; --&gt; &lt;nuxt-link :to=&quot;&apos;/gathering/item/&apos;+item.id&quot;&gt;{{item.name}}&lt;/nuxt-link&gt;目前 nuxt‐link 的作用和 router‐link 致 ，都是进行路由的跳转</code></pre><h2 id="vue瀑布流插件使用"><a href="#vue瀑布流插件使用" class="headerlink" title="vue瀑布流插件使用"></a>vue瀑布流插件使用</h2><pre><code>安装:cnpm install vue-infinite-scroll1.plugins下创建vue-infinite-scroll.js//加载瀑布流插件import Vue from &apos;vue&apos;;import infiniteScroller from &apos;vue-infinite-scroll&apos;;//使用插件Vue.use(infiniteScroller);2.修改nuxt.config.js  plugins: [    {      src: &apos;~/plugins/vue-infinite-scroll&apos;,      //不需要服务端加载      ssr: false    }  ],3.修改页面pages/gathering/index.vue &lt;div class=&quot;activity-list&quot; v-infinite-scroll=&quot;loadMore()&quot;&gt;添加pageNo用于记录 data () {    return {      //用来记录瀑布流页码号      pageNo: 1    }  },编写方法loadMore  methods: {    loadMore(){      this.pageNo++;      gatheringApi.getListByPage(this.pageNo, 12, { state: &quot;1&quot; }).then(resp =&gt; {      this.items=this.items.concat( resp.data.data.rows);     })    }  }</code></pre>]]></content>
      
      
      <categories>
          
          <category> NUXT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> NUXT </tag>
            
            <tag> 服务端渲染技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.0路由与状态管理</title>
      <link href="/2019/02/04/Vue2-0%E8%B7%AF%E7%94%B1%E4%B8%8E%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
      <url>/2019/02/04/Vue2-0%E8%B7%AF%E7%94%B1%E4%B8%8E%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="路由与状态管理"><a href="#路由与状态管理" class="headerlink" title="路由与状态管理"></a>路由与状态管理</h1><h2 id="路由vue-router"><a href="#路由vue-router" class="headerlink" title="路由vue-router"></a>路由vue-router</h2><h3 id="什么是vue-router"><a href="#什么是vue-router" class="headerlink" title="什么是vue-router"></a>什么是vue-router</h3><blockquote><p>vue-router就是vue官方提供的一个路由框架。使用 Vue.js ，我们已经可以通过组<br>合组件来组成应用程序，当你要把 vue-router 添加进来，我们需要做的是，将组件<br>(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们。</p></blockquote><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="初始化工程"><a href="#初始化工程" class="headerlink" title="初始化工程"></a>初始化工程</h4><pre><code>1.全局安装vue-clicnpm install -g vue-cli2.创建一个基于webpack模版的新项目vue init webpack vue-router-demo3.安装依赖cd vue-router-demonpm run dev</code></pre><h4 id="路由定义"><a href="#路由定义" class="headerlink" title="路由定义"></a>路由定义</h4><blockquote><p>src/App.vue是我们的主界面，其中的 &lt;router‐view/&gt; 标签用于显示各组件视图内容src/router/index.js是定义路由的脚本 path是路径， name是名称 ，component是跳转的组件.</p></blockquote><pre><code>1.我们现在定义两个页面组件，存放在src/components下list.vue&lt;template&gt;    &lt;div&gt;        这是一个列表!    &lt;/div&gt;&lt;/template&gt;about.vue&lt;template&gt;    &lt;div&gt;        关于我:huangsm    &lt;/div&gt;&lt;/template&gt;2.定义路由修改src/router/index.jsimport Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import HelloWorld from &apos;@/components/HelloWorld&apos;import list from &apos;@/components/list&apos;import about from &apos;@/components/about&apos;Vue.use(Router)export default new Router({  routes: [    {      path: &apos;/&apos;,      name: &apos;HelloWorld&apos;,      component: HelloWorld    },    {      path: &apos;/list&apos;,      name: &apos;list&apos;,      component: list    },    {      path: &apos;/about&apos;,      name: &apos;about&apos;,      component: about    }  ]})3.放置跳转链接修改src/app.vue ,添加链接&lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;&lt;router-link to=&quot;/list&quot;&gt;列表&lt;/router-link&gt;&lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt;通过router-link标签实现路由的跳转</code></pre><p><img src="/2019/02/04/Vue2-0路由与状态管理/vue-router.png" alt="vue-router属性"></p><h3 id="深入了解"><a href="#深入了解" class="headerlink" title="深入了解"></a>深入了解</h3><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><blockquote><p>我们经常会遇到这样的需求，有一个新闻列表，点击某一条进入新闻详细页，我们通常<br>是传递新闻的ID给详细页，详细页根据ID进行处理。这时我们就会用到动态路由个『路径参数』使用冒号 : 标记。当匹配到一个路由时，参数值会被到 this.$route.params</p></blockquote><pre><code>如何实现?1.在src/components下创建item.vue &lt;div&gt;    接收的参数:{{$route.params.id}}&lt;/div&gt;2.修改src/router/index.js，引入item组件import item from &apos;@/components/item&apos;3.添加路由设置 {  path: &apos;/item/:id&apos;,  name: &apos;item&apos;,  component: item}4.修改src/components/list.vue, 增加链接 &lt;router-link to=&quot;/item/1&quot;&gt;新闻1&lt;/router-link&gt; &lt;router-link to=&quot;/item/2&quot;&gt;新闻2&lt;/router-link&gt; &lt;router-link to=&quot;/item/3&quot;&gt;新闻3&lt;/router-link&gt;</code></pre><h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><blockquote><p>实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路<br>径也按某种结构对应嵌套的各层组件，例如：</p></blockquote><p><img src="/2019/02/04/Vue2-0路由与状态管理/嵌套路由.png" alt="嵌套路由"></p><pre><code>如何实现?1.在src/components下创建address.vue&lt;template&gt;&lt;div&gt;    地址:郑州&lt;/div&gt;&lt;/template&gt;创建linkman.vue&lt;template&gt;&lt;div&gt;    联系人:王球球&lt;/div&gt;&lt;/template&gt;2.修改src/router/index.js引入linkman和addressimport address from &apos;@/components/address&apos;import linkman from &apos;@/components/linkman&apos;配置嵌套路由:{  path: &apos;/about&apos;,  name: &apos;about&apos;,  component: about,  children: [    {      path: &apos;address&apos;,      component: address    }, {      path: &apos;linkman&apos;,      component: linkman    }  ]},3.修改src/components/about.vue &lt;div&gt;    关于我:    &lt;router-link to=&quot;/about/address&quot;&gt;address&lt;/router-link&gt;    &lt;router-link to=&quot;/about/linkman&quot;&gt;linkman&lt;/router-link&gt;    &lt;router-view/&gt;&lt;/div&gt;</code></pre><h2 id="状态管理Vuex"><a href="#状态管理Vuex" class="headerlink" title="状态管理Vuex"></a>状态管理Vuex</h2><blockquote><p>我们经过测试会发现，用户登陆后可以访问其它页面的资源。未登录或退出登录后，再<br>次访问资源会跳回到登陆页，这是如何实现的呢？长话短说，这是通过一种叫Vuex的技<br>术来实现的。</p></blockquote><h3 id="Vuex简介"><a href="#Vuex简介" class="headerlink" title="Vuex简介"></a>Vuex简介</h3><blockquote><p>官方的解释： Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote><blockquote><p>快速理解：每个组件都有它自己数据属性，封装在data()中，每个组件之间data是完全隔离的，是私有的。如果我们需要各个组件都能访问到数据数据，或是需要各个组件之间能互相交换数据，这就需要一个单独存储的区域存放公共属性。这就是状态管理所要解决的问题。</p></blockquote><h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h4><pre><code>vue init webpack vuexdemocd vuexdemocnpm install ‐‐save vuexnpm run dev</code></pre><h4 id="读取状态值"><a href="#读取状态值" class="headerlink" title="读取状态值"></a>读取状态值</h4><blockquote><p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你<br>的应用中大部分的状态 (state)。</p></blockquote><p><strong>长话短说下面我们来实现吧</strong></p><pre><code>1.在src下创建store，store下创建index.js//定义仓库(Vuex的核心)import Vue from &apos;vue&apos;;import Vuex from &apos;vuex&apos;;//打开Vue状态管理的开关Vue.use(Vuex);const store = new Vuex.Store({    //定义仓库中所有的状态    state: {        count: 0    }})export default store;2.修改main.js，引入和装载storeimport store from &apos;./store&apos;;Vue.config.productionTip = false/* eslint-disable no-new */new Vue({  el: &apos;#app&apos;,  router,  store,  components: { App },  template: &apos;&lt;App/&gt;&apos;})3.修改components\HelloWorld.vue&lt;template&gt;  &lt;div&gt;    {{$store.state.count}}  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {}&lt;/script&gt;</code></pre><h4 id="改变状态值"><a href="#改变状态值" class="headerlink" title="改变状态值"></a>改变状态值</h4><blockquote><p>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p></blockquote><pre><code>1.修改store/index.js ,增加mutation定义 //相当于定义一堆方法mutations: {    increment(state){        state.count++    }}2.修改components\HelloWorld.vue ，调用mutationexport default { methods: {   addCount(){     //调用mutations     this.$store.commit(&apos;increment&apos;);     console.log(this.$store.state.count);   } }}&lt;/script&gt;</code></pre><h4 id="提交载荷"><a href="#提交载荷" class="headerlink" title="提交载荷"></a>提交载荷</h4><blockquote><p>所谓载荷（payload）就是 向 store.commit 传入额外的参数。</p></blockquote><pre><code>1.修改store下的index.jsmutations: {    increment(state,x){        state.count+=x;    }}2.修改HelloWorld.vue&lt;script&gt;export default { methods: {   addCount(){     //调用mutations     this.$store.commit(&apos;increment&apos;,10);     console.log(this.$store.state.count);   } }}&lt;/script&gt;</code></pre><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操</li></ul><p><em>我们现在使用 Action 来封装increme</em></p><pre><code>1.修改store/index.js//相当于封装了mutations支持异步actions: {    increment(context){        context.commit(&apos;increment&apos;,10);    }}2.修改show.vue//调用actionsthis.$store.dispatch(&apos;increment&apos;);</code></pre><p><strong>我们使用dispatch来调用action , Action也同样支持载荷</strong></p><h4 id="派生属性Getter"><a href="#派生属性Getter" class="headerlink" title="派生属性Getter"></a>派生属性Getter</h4><blockquote><p>有时候我们需要从 store 中的 state 中派生出一些状态，例如我们在上例代码的基础上，<br>我们增加一个叫 remark的属性，如果count属性值小于50则remark为加油，大于等于<br>50小于100则remark为你真棒，大于100则remark的值为你是大神. 这时我们就需要用<br>到getter为我们解决。</p></blockquote><pre><code>1.修改store/index.js ,增加getters getters: {    remark(state){        if(state.count&lt;50){            return &apos;加油&apos;;        }else if(state.count&lt;100){            return &apos;真棒&apos;;        }else{            return &apos;强啊!&apos;;        }    }}Getter 接受 state 作为其第一个参数，也可以接受其他 getter 作为第二个参数2.修改HelloWorld.vue 显示派生属性的值  &lt;!-- 显示getters --&gt;{{$store.getters.remark}}</code></pre><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><blockquote><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿.</p></blockquote><blockquote><p>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割 .</p></blockquote><p><img src="/2019/02/04/Vue2-0路由与状态管理/vuex模块化.png" alt="vuex模块化"></p><p><strong>模块化后的store.js</strong></p><pre><code>//定义仓库(Vuex的核心)import Vue from &apos;vue&apos;;import Vuex from &apos;vuex&apos;;//打开Vue状态管理的开关Vue.use(Vuex);//模块化const moduleA = {    //定义仓库中所有的状态    state: {        count: 0    },    //相当于定义一堆方法    mutations: {        increment(state, x) {            state.count += x;        }    },    //相当于封装了mutations支持异步    actions: {        increment(context) {            context.commit(&apos;increment&apos;, 10);        }    },    getters: {        remark(state) {            if (state.count &lt; 50) {                return &apos;加油&apos;;            } else if (state.count &lt; 100) {                return &apos;真棒&apos;;            } else {                return &apos;强啊!&apos;;            }        }    }}const store = new Vuex.Store({    modules:{        a:moduleA    }})export default store;</code></pre><p><strong>调用方式</strong></p><pre><code>&lt;template&gt;  &lt;div&gt;    {{$store.state.a.count}}    &lt;button @click=&quot;addCount()&quot;&gt;测试&lt;/button&gt;    &lt;!-- 显示getters --&gt;    {{$store.getters.remark}}  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { methods: {   addCount(){     //调用mutations     //this.$store.commit(&apos;increment&apos;,10);     //调用actions     this.$store.dispatch(&apos;increment&apos;);     console.log(this.$store.state.a.count);   } }}&lt;/script&gt;</code></pre><p><strong>标准工程结构</strong></p><p><img src="/2019/02/04/Vue2-0路由与状态管理/标准工程结构.png" alt="标准工程结构"></p><p><em>现在我们按照上图结构，重新改善我们的工程</em></p><pre><code>1.store下创建modules文件夹，文件夹下创建a.js//标准工厂结构下的--storeexport default{    state: {        count: 0    },    mutations: {        increment(state,x){            state.count+=x;        }    },    actions: {        increment(context){            context.commit(&apos;increment&apos;,10);        }    }}2.store下创建getters.js//标准工厂结果---getters派生属性export default{    remark: state=&gt;{        if(state.a.count&lt;50){            return &apos;加油&apos;;        }else if(state.a.count&lt;100){            return &apos;真棒&apos;;        }else{            return &apos;强啊!&apos;;        }    },    count: state=&gt;state.a.count}3.修改store/index.js//定义仓库(Vuex的核心)import Vue from &apos;vue&apos;;import Vuex from &apos;vuex&apos;;import a from &apos;./modules/a&apos;;import getters from &apos;./getters&apos;;//打开Vue状态管理的开关Vue.use(Vuex);const store=new Vuex.Store({    getters,    modules:{        a    }})export default store;4.修改HelloWorld.vue&lt;template&gt;  &lt;div&gt;    {{$store.getters.count}}    &lt;button @click=&quot;addCount()&quot;&gt;测试&lt;/button&gt;    &lt;!-- 显示getters --&gt;    {{$store.getters.remark}}  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { methods: {   addCount(){     //调用mutations     //this.$store.commit(&apos;increment&apos;,10);     //调用actions     this.$store.dispatch(&apos;increment&apos;);     console.log(this.$store.getters.count);   } }}&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vuex </tag>
            
            <tag> vue-router </tag>
            
            <tag> vue-cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElementUI的概念和基本控件的使用</title>
      <link href="/2019/02/04/ElementUI%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/04/ElementUI%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h1><h2 id="什么是ElementUI"><a href="#什么是ElementUI" class="headerlink" title="什么是ElementUI"></a>什么是ElementUI</h2><blockquote><p>element 饿了么前端出品的一套 Vue.js 后台组件库</p></blockquote><p><a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">官网</a></p><h2 id="神器的脚手架"><a href="#神器的脚手架" class="headerlink" title="神器的脚手架"></a>神器的脚手架</h2><h3 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h3><blockquote><p>官网上提供了非常基础的脚手架，如果我们使用官网的脚手架需要自己写很多代码比如登录页面、主界面菜单等内容。课程已经提供了功能完整的脚手架，我们可以拿过来在此基础上开发、这样可以极大节省我们开发的时间。</p></blockquote><pre><code>1.解压vueAdmin-template-master2.在命令提示符进入该目录，输入命令：cnpm install3.输入命令:npm run dev</code></pre><h3 id="了解工程结构"><a href="#了解工程结构" class="headerlink" title="了解工程结构"></a>了解工程结构</h3><p><strong>以下是主要的目录结构：</strong></p><p><img src="/2019/02/04/ElementUI的概念和基本控件的使用/脚手架结构.png" alt="脚手架结构"></p><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><h3 id="关闭语法规范性检查"><a href="#关闭语法规范性检查" class="headerlink" title="关闭语法规范性检查"></a>关闭语法规范性检查</h3><blockquote><p>修改config/index.js ，将useEslint的值改为false。<br>此配置作用: 是否开启语法检查，语法检查是通过ESLint 来实现的。<br>我们现在科普一下,什么是ESLint : ESLint 是一个语法规则和代码风格的检查工具，可以<br>用来保证写出语法正确、风格统一的代码。如果我们开启了Eslint , 也就意味着要接受它<br>非常苛刻的语法检查，包括空格不能少些或多些，必须单引不能双引，语句后不可以写<br>分号等等，这些规则其实是可以设置的。我们作为前端的初学者，最好先关闭这种校<br>验，否则会浪费很多精力在语法的规范性上。如果以后做真正的企业级开发，建议开启。</p></blockquote><h3 id="对接Easy-Mock"><a href="#对接Easy-Mock" class="headerlink" title="对接Easy-Mock"></a>对接Easy-Mock</h3><pre><code>1.修改config下的dev.env.js中的BASE_API为easy-mock的Base URLBASE_API: &apos;&quot;https://www.easy-mock.com/mock/5c57b3a6de5c260cd71d3b8d&quot;&apos;2.准备对应的user/login和user/info接口</code></pre><h3 id="更改标题与菜单"><a href="#更改标题与菜单" class="headerlink" title="更改标题与菜单"></a>更改标题与菜单</h3><pre><code>1.修改index.html里的标题为&quot;Element学习&quot;，修改后浏览器自动刷新。这就是脚手架中已经为我们添加了热部署功能。2.修改src/router 下的index.js 中constantRouterMap的内容</code></pre><h2 id="活动管理-列表"><a href="#活动管理-列表" class="headerlink" title="活动管理-列表"></a>活动管理-列表</h2><h3 id="表格组件"><a href="#表格组件" class="headerlink" title="表格组件"></a>表格组件</h3><pre><code>1.在src/api创建gathering.js//封装对restFul接口的访问const group_name=&apos;api&apos;;import request from &apos;@/utils/request&apos;export default {    getList(){        return request(            {                url:&apos;/api/gathering&apos;,                method:&apos;get&apos;            }        );    }}2.创建gathering.vue中 ，编写脚本部分&lt;script&gt;import gatheringApi from &quot;@/api/gathering&quot;;export default {  //定义成员变量，定义页面属性  data() {    return {      //接收列表      list: []    };  },  //钩子函数  created () {    this.feechData();    },  //所有的方法  methods: {    feechData() {      gatheringApi.getList().then(response =&gt; {        this.list = response.data;      });    }  }};&lt;/script&gt;3.修改gathering.vue，编写html代码部分&lt;!--template:模版区视图区    - table控件script:逻辑区(控制视图区的显示)--&gt;&lt;template&gt;  &lt;el-table :data=&quot;list&quot; border style=&quot;width: 100%&quot;&gt;    &lt;el-table-column prop=&quot;id&quot; label=&quot;活动ID&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;    &lt;el-table-column prop=&quot;name&quot; label=&quot;活动名称&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;    &lt;el-table-column prop=&quot;sponsor&quot; label=&quot;主办方&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;     &lt;el-table-column prop=&quot;starttime&quot; label=&quot;开始时间&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;    &lt;el-table-column prop=&quot;endtime&quot; label=&quot;结束时间&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;  &lt;/el-table&gt;&lt;/template&gt;</code></pre><p><a href="http://element-cn.eleme.io/#/zh-CN/component/table" target="_blank" rel="noopener">table的属性官方文档</a></p><h3 id="分页组件"><a href="#分页组件" class="headerlink" title="分页组件"></a>分页组件</h3><p><em>我们已经通过表格组件完成了列表的展示，接下来需要使用分页组件完成分页功能</em></p><p><em>准备工作：修改接口/gathering/gathering/search/{page}/{size} method:POST</em></p><pre><code>1.修改src/api/gathering.js，增加方法导出 //分页查询getListByPage(page,size,searchMap){    return request({        url:&apos;/api/gathering/search/{page}/{size}&apos;,        method:&apos;post&apos;,        data:searchMap    });}2.修改src/views/table/gathering.vue，编写脚本部分import gatheringApi from &quot;@/api/gathering&quot;;export default {  //定义成员变量，定义页面属性  data() {    return {      //接收列表      total:0,//总记录数      list: [],      cuurentPage: 1,//当前页      pageSize: 10,  //每页大小      searchMap:{}//查询条件    };  },  //钩子函数  created() {    this.feechData();  },  //所有的方法  methods: {    feechData() {      gatheringApi.getListByPage(this.cuurentPage,this.pageSize,this.searchMap).then(response =&gt; {        this.list = response.data.rows;        this.total=response.data.total;      });    }  }};3.修改src/views/table/gathering.vue，增加分页栏  &lt;div&gt;    &lt;el-table :data=&quot;list&quot; border style=&quot;width: 100%&quot;&gt;      &lt;el-table-column prop=&quot;id&quot; label=&quot;活动ID&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;      &lt;el-table-column prop=&quot;name&quot; label=&quot;活动名称&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;      &lt;el-table-column prop=&quot;sponsor&quot; label=&quot;主办方&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;      &lt;el-table-column prop=&quot;starttime&quot; label=&quot;开始时间&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;      &lt;el-table-column prop=&quot;endtime&quot; label=&quot;结束时间&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;    &lt;/el-table&gt;    &lt;el-pagination      @size-change=&quot;feechData&quot;      @current-change=&quot;feechData&quot;      :current-page=&quot;cuurentPage&quot;      :page-sizes=&quot;[5, 10, 20]&quot;      :page-size=&quot;10&quot;      layout=&quot;total, sizes, prev, pager, next, jumper&quot;      :total=&quot;total&quot;    &gt;&lt;/el-pagination&gt;  &lt;/div&gt;currentPage为当前页 ， total为总记录数注意：template里面要求必须有唯一的跟节点，我们这里用div将表格和分页控件包起来。</code></pre><p><a href="http://element-cn.eleme.io/#/zh-CN/component/pagination#pagination-fen-ye" target="_blank" rel="noopener">分页控件官方文档</a></p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><pre><code>1.修改src/views/table/gathering.vue，增加查询表单&lt;br&gt;&lt;el-form :inline=&quot;true&quot;&gt;  &lt;el-form-item label=&quot;活动名称&quot;&gt;    &lt;el-input v-model=&quot;searchMap.name&quot; placeholder=&quot;活动名称&quot;&gt;&lt;/el-input&gt;  &lt;/el-form-item&gt;  &lt;el-form-item label=&quot;开始日期&quot;&gt;    &lt;el-date-picker v-model=&quot;searchMap.starttime_1&quot; type=&quot;date&quot; placeholder=&quot;选择开始日期&quot;&gt;&lt;/el-date-picker&gt;    &lt;el-date-picker v-model=&quot;searchMap.starttime_2&quot; type=&quot;date&quot; placeholder=&quot;选择截至日期&quot;&gt;&lt;/el-date-picker&gt;  &lt;/el-form-item&gt;  &lt;el-button type=&quot;primary&quot; @click=&quot;feechData&quot;&gt;查询&lt;/el-button&gt;&lt;/el-form&gt;</code></pre><p><a href="http://element-cn.eleme.io/#/zh-CN/component/form" target="_blank" rel="noopener">表单组件</a></p><p><a href="http://element-cn.eleme.io/#/zh-CN/component/input" target="_blank" rel="noopener">Input 输入框</a></p><p><a href="http://element-cn.eleme.io/#/zh-CN/component/date-picker" target="_blank" rel="noopener">日期选择器组件</a></p><h2 id="活动管理-增加"><a href="#活动管理-增加" class="headerlink" title="活动管理-增加"></a>活动管理-增加</h2><h3 id="弹出窗口"><a href="#弹出窗口" class="headerlink" title="弹出窗口"></a>弹出窗口</h3><pre><code>1.修改src/api/gathering.js，在template中增加对话框组件 &lt;el-dialog title=&quot;编辑&quot; :visible.sync=&quot;dislogFormVisble&quot;&gt;&lt;/el-dialog&gt;2.变量dialogFormVisible用于控制对话框的显示。我们在脚本代码中定义 return {  .....  dislogFormVisble: false //编辑窗口是否可见  ....};3.template中增加按钮，用于打开对话框&lt;el-button type=&quot;primary&quot; @click=&quot;dislogFormVisble=true&quot;&gt;新增&lt;/el-button&gt;</code></pre><p><a href="http://element-cn.eleme.io/#/zh-CN/component/dialog" target="_blank" rel="noopener">diglog组件文档</a></p><h3 id="编辑表单"><a href="#编辑表单" class="headerlink" title="编辑表单"></a>编辑表单</h3><pre><code>1.修改src/views/table/gathering.vue，在弹出窗口添加编辑&lt;el-dialog title=&quot;编辑&quot; :visible.sync=&quot;dislogFormVisble&quot;&gt;  &lt;el-form label-width=&quot;80px&quot;&gt;    &lt;el-form-item label=&quot;活动名称&quot;&gt;      &lt;el-input v-model=&quot;pojo.name&quot; placeholder=&quot;活动名称&quot;&gt;&lt;/el-input&gt;    &lt;/el-form-item&gt;    &lt;el-form-item label=&quot;基本地址&quot;&gt;      &lt;el-input v-model=&quot;pojo.address&quot; placeholder=&quot;基本地址&quot;&gt;&lt;/el-input&gt;    &lt;/el-form-item&gt;    &lt;el-form-item label=&quot;开始日期&quot;&gt;      &lt;el-date-picker type=&quot;date&quot; v-model=&quot;pojo.starttime&quot; placeholder=&quot;开始日期&quot;&gt;&lt;/el-date-picker&gt;    &lt;/el-form-item&gt;    &lt;el-form-item label=&quot;截至日期&quot;&gt;      &lt;el-date-picker type=&quot;date&quot; v-model=&quot;pojo.endtime&quot; placeholder=&quot;截至日期&quot;&gt;&lt;/el-date-picker&gt;    &lt;/el-form-item&gt;    &lt;el-form-item label=&quot;报名截至&quot;&gt;      &lt;el-date-picker type=&quot;date&quot; v-model=&quot;pojo.enrolltime&quot; placeholder=&quot;报名截至&quot;&gt;&lt;/el-date-picker&gt;    &lt;/el-form-item&gt;    &lt;el-form-item label=&quot;活动详情&quot;&gt;      &lt;el-input v-model=&quot;pojo.detail&quot; placeholder=&quot;活动详情&quot; type=&quot;textarea&quot; :rows=&quot;2&quot;&gt;&lt;/el-input&gt;    &lt;/el-form-item&gt;    &lt;el-form-item label=&quot;是否可见&quot;&gt;      &lt;el-switch        v-model=&quot;pojo.status&quot;        active-value=&quot;1&quot;        inactive-value=&quot;0&quot;        active-color=&quot;#13ce66&quot;        inactive-color=&quot;#ff4949&quot;      &gt;&lt;/el-switch&gt;      &lt;el-form-item&gt;          &lt;el-button type=&quot;primary&quot;&gt;保存&lt;/el-button&gt;          &lt;el-button @click=&quot;dislogFormVisble=false&quot; type=&quot;danger&quot;&gt;关闭&lt;/el-button&gt;      &lt;/el-form-item&gt;    &lt;/el-form-item&gt;  &lt;/el-form&gt;&lt;/el-dialog&gt;</code></pre><p><strong>这里我们主要要掌握多行文本编辑框与开关组件switch的使用</strong></p><h3 id="下拉选择框"><a href="#下拉选择框" class="headerlink" title="下拉选择框"></a>下拉选择框</h3><pre><code>1.创建src/api/city.js//城市模块const group_name = &apos;base&apos;;const method_name = &apos;city&apos;;import request from &apos;@/utils/request&apos;export default {    getList() {        return request({            url: `/${group_name}/${method_name}`,            method: &apos;get&apos;        })    }}2.修改src/views/table/gathering.vue的js脚本部分 cityApi.getList().then(response =&gt; {  this.cityList = response.data;}); cityList: [] //城市列表3.修改src/views/table/gathering.vue，增加城市下拉框  &lt;el-form-item label=&quot;城市&quot;&gt;      &lt;el-select v-model=&quot;pojo.city&quot; placeholder=&quot;选择城市&quot;&gt;        &lt;el-option          v-for=&quot;item in cityList&quot;          :key=&quot;item.id&quot;          :label=&quot;item.name&quot;          :value=&quot;item.id&quot;        &gt;&lt;/el-option&gt;      &lt;/el-select&gt;    &lt;/el-form-item&gt;</code></pre><h3 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h3><pre><code>1.修改easymock中的/gathering/gathering （增加活动 POST）{  &quot;code&quot;: 20000,  &quot;flag&quot;: true,  &quot;message&quot;: &quot;增加成功&quot;}2.修改src/api/gathering.js，增加方法导出//保存save(pojo){    return request({        url:`/${group_name}/${method_name}`,        method:&apos;post&apos;,        data:pojo    })}3.修改src/views/table/gathering.vue的js脚本部分 增加方法执行保存 saveData() {  gatheringApi.save(this.pojo).then(response =&gt; {    alert(response.message);    if (response.code == 20000) {      this.feechData(); //刷新列表    }  });  this.dislogFormVisble = false; //关闭窗口}&lt;el-button type=&quot;primary&quot; @click=&quot;saveData()&quot;&gt;保存&lt;/el-button&gt;</code></pre><h3 id="活动管理-修改"><a href="#活动管理-修改" class="headerlink" title="活动管理-修改"></a>活动管理-修改</h3><p><strong>在表格的操作列增加”修改”按钮，点击修改按钮弹出窗口并显示数据，点击保存按钮保存修改并刷新</strong></p><h4 id="根据ID加载数据"><a href="#根据ID加载数据" class="headerlink" title="根据ID加载数据"></a>根据ID加载数据</h4><pre><code>1.修改easymock 接口 /gathering/gathering/{id} （GET）{  &quot;code&quot;: 20000,  &quot;flag&quot;: true,  &quot;message&quot;: &quot;查询成功&quot;,  &quot;data&quot;: {    &quot;id|+1&quot;: 1,    &quot;name&quot;: &quot;@cword(8,12)&quot;,    &quot;summary&quot;: &quot;@cword(20,40)&quot;,    &quot;detail&quot;: &quot;@cword(20,40)&quot;,    &quot;sponsor&quot;: &quot;@string&quot;,    &quot;image&quot;: &quot;@image&quot;,    &quot;starttime&quot;: &quot;@date&quot;,    &quot;endtime&quot;: &quot;@date&quot;,    &quot;address&quot;: &quot;@county(true)&quot;,    &quot;enrolltime&quot;: &quot;@date&quot;,    &quot;state&quot;: &quot;@string&quot;,    &quot;city&quot;: &quot;@string&quot;  }}2.修改src/api/gathering.js，增加方法定义 //根据ID查询活动信息findById(id){    return request({        url:`/${group_name}/${method_name}/${id}`,        method:&apos;get&apos;    })}3.修改src/views/table/gathering.vue的js脚本部分新增handleEdit方法  //根据ID查询活动信息handleEdit(id) {  //打开编辑窗口  this.dislogFormVisble = true;  if (id != &quot;&quot;) {//修改数据    gatheringApi.findById(id).then(response =&gt; {      if ((response.flag = true)) {        //定义实体，用于数据回显        this.pojo = response.data;      }    });  }else{      this.pojo={};  }}4.在表格table中增加模板列 ,模板列中防止修改按钮，调用handleEdit方法 &lt;el-table-column fixed=&quot;right&quot; label=&quot;操作&quot; width=&quot;100&quot;&gt;    &lt;template slot-scope=&quot;scope&quot;&gt;      &lt;el-button @click=&quot;handleEdit(scope.row.id)&quot; type=&quot;text&quot; size=&quot;small&quot;&gt;修改&lt;/el-button&gt;    &lt;/template&gt;  &lt;/el-table-column&gt;</code></pre><h4 id="新增窗口表单清空"><a href="#新增窗口表单清空" class="headerlink" title="新增窗口表单清空"></a>新增窗口表单清空</h4><pre><code>&lt;el-button type=&quot;primary&quot; @click=&quot;handleEdit(&apos;&apos;)&quot;&gt;新增&lt;/el-button&gt;</code></pre><h4 id="保存修改"><a href="#保存修改" class="headerlink" title="保存修改"></a>保存修改</h4><pre><code>准备工作：修改easymock 接口 /gathering/gathering/{id} （PUT){  &quot;code&quot;: 20000,  &quot;flag&quot;: true,  &quot;message&quot;: &quot;修改成功&quot;}1.在gatherging.js添加update方法 //根据ID修改活动信息update(id,pojo){    //优化    if(id==null||id==&apos;&apos;){        return this.save(pojo);    }    return request({        url:`/${group_name}/${method_name}/${id}`,        method:&apos;put&apos;,        data:pojo    })}2.在gatherging.vue调用update方法  saveData() {  gatheringApi.update(this.id, this.pojo).then(response =&gt; {    alert(response.message);    if (response.flag) {      this.feechData();    }  });  this.dislogFormVisble = false; //关闭窗口}</code></pre><h4 id="消息提示框"><a href="#消息提示框" class="headerlink" title="消息提示框"></a>消息提示框</h4><pre><code>js原生的alert简直是丑爆了，有没有更漂亮的弹出框呀！当然有，用了elementUI提供了消息提示框！ alert(response.message)可以替换为以下代码：this.$message({  message: response.message,  type: (response.flag?&apos;success&apos;:&apos;error&apos;)});</code></pre><p><a href="http://element-cn.eleme.io/#/zh-CN/component/message" target="_blank" rel="noopener">message组件文档</a></p><h3 id="活动管理-删除"><a href="#活动管理-删除" class="headerlink" title="活动管理-删除"></a>活动管理-删除</h3><h4 id="EasyMock接口"><a href="#EasyMock接口" class="headerlink" title="EasyMock接口"></a>EasyMock接口</h4><pre><code>URL:gathering/:id Method: delete{  &quot;code&quot;: 20000,  &quot;flag&quot;: true,  &quot;message&quot;: &quot;删除成功&quot;}</code></pre><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>1.修改src/api/gathering.js，增加方法定义//根据ID删除活动信息deleteById(id){    return request({        url:`/${group_name}/${method_name}/${id}`,        method:&apos;delete&apos;    })}2.修改src/views/table/gathering.vue的js脚本部分增加方法  //根据ID删除活动信息deleteById(id) {  this.$confirm(&quot;确定要删除此记录吗?&quot;, &quot;提示&quot;, {    confirmButtonText: &quot;确定&quot;,    cancelButtonText: &quot;取消&quot;,    type: &quot;warning&quot;  })    .then(() =&gt; {      gatheringApi.deleteById(id).then(response =&gt; {        this.$message({          message: response.message,          type: response.flag ? &quot;success&quot; : &quot;error&quot;        });        if (response.flag) {          this.feechData(); //刷新数据        }      });    })    .catch(() =&gt; {});}3.修改src/views/table/gathering.vue ，在操作列增加删除按钮 &lt;el-button @click=&quot;deleteById(scope.row.id)&quot; type=&quot;text&quot; size=&quot;small&quot;&gt;删除&lt;/el-button&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ElementUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElementUI </tag>
            
            <tag> vue </tag>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
            <tag> easymock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地部署EasyMock</title>
      <link href="/2019/02/04/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2EasyMock/"/>
      <url>/2019/02/04/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2EasyMock/</url>
      
        <content type="html"><![CDATA[<h1 id="EasyMock"><a href="#EasyMock" class="headerlink" title="EasyMock"></a>EasyMock</h1><h2 id="什么是EasyMock"><a href="#什么是EasyMock" class="headerlink" title="什么是EasyMock"></a>什么是EasyMock</h2><blockquote><p>EasyMock是一个极其简单、高效、可视化、并且能快速生成模拟的在线mock服务。以项目管理的方式组织Mock List，能帮助我们更好的管理Mock数据。</p></blockquote><p><a href="https://www.easy-mock.com" target="_blank" rel="noopener">地址</a></p><p><a href="https://www.easy-mock.com/docs" target="_blank" rel="noopener">在线文档</a></p><h2 id="本地部署EasyMock"><a href="#本地部署EasyMock" class="headerlink" title="本地部署EasyMock"></a>本地部署EasyMock</h2><h3 id="Centos部署node-js"><a href="#Centos部署node-js" class="headerlink" title="Centos部署node.js"></a>Centos部署node.js</h3><ul><li>将node官网下载的压缩包上传到服务器</li><li>解压xz文件</li></ul><blockquote><p>xz -d node-v8.11.1-linux-x64.tar.xz</p></blockquote><ul><li>解压tar文件</li></ul><blockquote><p>tar -xvf node-v8.11.1-linux-x64.tar.xz</p></blockquote><ul><li>目录重命名</li></ul><blockquote><p>mv node-v8.11.1-linux-x64 node</p></blockquote><ul><li>配置环境变量</li></ul><blockquote><p>vi /etc/profile</p></blockquote><blockquote><p>export NODE_HOME=~/node </p><p>export PATH=$NODE_HOME/bin:$PA</p></blockquote><ul><li>执行命令让环境变量生效</li></ul><blockquote><p>source /etc/profile</p></blockquote><ul><li>查看node版本看是否安装成功</li></ul><blockquote><p>node -v</p></blockquote><h2 id="MongoDB安装与启动"><a href="#MongoDB安装与启动" class="headerlink" title="MongoDB安装与启动"></a>MongoDB安装与启动</h2><p><em>我们使用yum方式安装mongo</em></p><pre><code>1.配置yumvi /etc/yum.repos.d/mongodb‐org‐3.2.repo[mongodb-org-3.2]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.2/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.2.asc2.安装MongoDByum install ‐y mongodb‐org3.启动MongoDsystemctl start mongod</code></pre><h2 id="Redis安装与启动"><a href="#Redis安装与启动" class="headerlink" title="Redis安装与启动"></a>Redis安装与启动</h2><pre><code>1.下载fedora的epel仓库yum install epel-release2.下载安装reidsyum install redis3.启动redis服务systemctl start redis</code></pre><h2 id="本地部署easy-mock"><a href="#本地部署easy-mock" class="headerlink" title="本地部署easy-mock"></a>本地部署easy-mock</h2><pre><code>1.项目下载地址:https://github.com/easy-mock/easy-mock2.将easy-mock-dev.zip上传至服务器3.安装zip和unzipyum install zip unzip4.解压unzip easy-mock-dev.zip5.进入其目录，安装依赖npm install6.执行构建npm run build7.启动npm run start8.输入http://192.168.25.135:7300访问即可</code></pre><h2 id="导入swaggerAPI文档"><a href="#导入swaggerAPI文档" class="headerlink" title="导入swaggerAPI文档"></a>导入swaggerAPI文档</h2><pre><code>1.将SwaggerAPI文档扩展名改为yml2.在easyMock中点击设置选项卡3.SwaggerDocs API选择Upload4.将SwaggerAPI闻到那股拖动到虚线区域，点击保存5.回到主页面后点击“同步Swagger”</code></pre>]]></content>
      
      
      <categories>
          
          <category> EasyMock </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easymock </tag>
            
            <tag> mockjs </tag>
            
            <tag> mongodb </tag>
            
            <tag> yum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6的概念以及基本使用</title>
      <link href="/2019/02/03/ES6%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/03/ES6%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="什么是ES6"><a href="#什么是ES6" class="headerlink" title="什么是ES6"></a>什么是ES6</h2><pre><code>编程语言JavaScript是ECMAScript的实现和扩展 。ECMAScript是由ECMA(一个类似W3C的标准组织)参与进行标准化的语法规范。ECMAScript定义了：语言语法 – 语法解析规则、关键字、语句、声明、运算符等。类型 – 布尔型、数字、字符串、对象等。原型和继承内建对象和函数的标准库 – JSON、Math、数组方法、对象自省方法等。ECMAScript标准不定义HTML或CSS的相关功能，也不定义类似DOM(文档对象模型)的Web API，这些都在独立的标准中进行定义。ECMAScript涵盖了各种环境中JS的使用场景，无论是浏览器环境还是类似node.js的非浏览器环境。ECMAScript标准的历史版本分别是1、2、3、5。那么为什么没有第4版？其实，在过去确实曾计划发布提出巨量新特性的第4版，但最终却因想法太过激进而惨遭废除（这一版标准中曾经有一个极其复杂的支持泛型和类型推断的内建静态类型系统）。ES4饱受争议，当标准委员会最终停止开发ES4时，其成员同意发布一个相对谦和的ES5版本，随后继续制定一些更具实质性的新特性。这一明确的协商协议最终命名为“Harmony”，因此，ES5规范中包含这样两句话</code></pre><blockquote><p>ECMAScript是一门充满活力的语言，并在不断进化中。<br>未来版本的规范中将持续进行重要的技术改进</p></blockquote><pre><code>2009年发布的改进版本ES5，引入了Object.create()、Object.defineProperty()、getters和setters、严格模式以及JSON对象。ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，2015年6月正式发布。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</code></pre><h2 id="Node-js中使用ES6"><a href="#Node-js中使用ES6" class="headerlink" title="Node.js中使用ES6"></a>Node.js中使用ES6</h2><h3 id="babel转换配置-项目根目录添加-babelrc-文件"><a href="#babel转换配置-项目根目录添加-babelrc-文件" class="headerlink" title="babel转换配置,项目根目录添加.babelrc 文件"></a>babel转换配置,项目根目录添加.babelrc 文件</h3><pre><code>{&quot;presets&quot;: [&quot;es2015&quot;]}</code></pre><h3 id="安装es6转换模块"><a href="#安装es6转换模块" class="headerlink" title="安装es6转换模块"></a>安装es6转换模块</h3><pre><code>cnpm install babel‐preset‐es2015 ‐‐save‐d</code></pre><h3 id="全局安装命令行工具"><a href="#全局安装命令行工具" class="headerlink" title="全局安装命令行工具"></a>全局安装命令行工具</h3><pre><code>cnpm install babel‐cli ‐g</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>babel‐node js文件名</code></pre><h2 id="语法新特性"><a href="#语法新特性" class="headerlink" title="语法新特性"></a>语法新特性</h2><h3 id="6-3-1-变量声明let"><a href="#6-3-1-变量声明let" class="headerlink" title="6.3.1 变量声明let"></a>6.3.1 变量声明let</h3><p>我们都是知道在ES6以前，var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(bool) &#123;</span><br><span class="line">      <span class="keyword">var</span> test = <span class="string">'hello man'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(test)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码实际上是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> test <span class="comment">// 变量提升</span></span><br><span class="line">    <span class="keyword">if</span>(bool) &#123;</span><br><span class="line">        test = <span class="string">'hello man'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//此处访问test 值为undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(test)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处访问test 值为undefined</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>所以不用关心bool是否为true or false。实际上，无论如何test都会被创建声明。</p><p>接下来ES6主角登场：</p><p>我们通常用let和const来声明，let表示变量、const表示常量。let和const都是块级作用域。怎么理解这个块级作用域？在一个函数内部 ，在一个代码块内部。看以下代码</p><pre><code>//letfunction test(b){    if(b){        let a=&apos;abc&apos;;    }    console.log(a);}test(true);</code></pre><h3 id="6-3-2-常量声明"><a href="#6-3-2-常量声明" class="headerlink" title="6.3.2 常量声明"></a>6.3.2 常量声明</h3><p>const 用于声明常量，看以下代码</p><pre><code>const name=&apos;abc&apos;;name=&apos;ccc&apos;console.log(name);</code></pre><h3 id="6-3-3-模板字符串"><a href="#6-3-3-模板字符串" class="headerlink" title="6.3.3 模板字符串"></a>6.3.3 模板字符串</h3><p>es6模板字符简直是开发者的福音啊，解决了ES5在字符串功能上的痛点。</p><p>第一个用途，基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//es5 </span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'lux'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span> + name)</span><br><span class="line"><span class="comment">//es6</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'lux'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>) <span class="comment">//hello lux</span></span><br></pre></td></tr></table></figure><p>第二个用途，在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号(<code></code>)直接搞定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">"Hi \</span></span><br><span class="line"><span class="string">man!"</span></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">const</span> template = <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;hello world&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span></span><br></pre></td></tr></table></figure><h3 id="6-3-4-函数默认参数"><a href="#6-3-4-函数默认参数" class="headerlink" title="6.3.4 函数默认参数"></a>6.3.4 函数默认参数</h3><p>ES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。</p><p>看例子代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">action</span>(<span class="params">num = <span class="number">200</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line">action() <span class="comment">//200</span></span><br><span class="line">action(<span class="number">300</span>) <span class="comment">//300</span></span><br></pre></td></tr></table></figure><h3 id="6-3-5-箭头函数"><a href="#6-3-5-箭头函数" class="headerlink" title="6.3.5 箭头函数"></a>6.3.5 箭头函数</h3><p>ES6很有意思的一部分就是函数的快捷写法。也就是箭头函数。</p><p>箭头函数最直观的三个特点。</p><p>1不需要function关键字来创建函数</p><p>2省略return关键字</p><p>3继承当前上下文的 this 关键字</p><p>看下面代码（ES6）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(response,message) =&gt; &#123;</span><br><span class="line">   .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于ES5代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">response,message</span>)</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-6-对象初始化简写"><a href="#6-3-6-对象初始化简写" class="headerlink" title="6.3.6 对象初始化简写"></a>6.3.6 对象初始化简写</h3><p>ES5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">people</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: name,</span><br><span class="line">            age: age</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上代码可以简写为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function people(name, age) &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">          name,</span><br><span class="line">          age</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-7-解构"><a href="#6-3-7-解构" class="headerlink" title="6.3.7 解构"></a>6.3.7 解构</h3><p>数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，这是将一个数据结构分解为更小的部分的过程</p><p>ES5我们提取对象中的信息形式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = &#123;</span><br><span class="line">    name: <span class="string">'lux'</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> name = people.name</span><br><span class="line"><span class="keyword">const</span> age = people.age</span><br><span class="line"><span class="built_in">console</span>.log(name + <span class="string">' --- '</span> + age)</span><br></pre></td></tr></table></figure><p>是不是觉得很熟悉，没错，在ES6之前我们就是这样获取对象信息的，一个一个获取。现在，ES6的解构能让我们从对象或者数组里取出数据存为变量，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象</span></span><br><span class="line">    <span class="keyword">const</span> people = &#123;</span><br><span class="line">        name: <span class="string">'lux'</span>,</span><br><span class="line">        age: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = people</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span> --- <span class="subst">$&#123;age&#125;</span>`</span>)</span><br><span class="line">    <span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">const</span> color = [<span class="string">'red'</span>, <span class="string">'blue'</span>]</span><br><span class="line">    <span class="keyword">const</span> [first, second] = color</span><br><span class="line">    <span class="built_in">console</span>.log(first) <span class="comment">//'red'</span></span><br><span class="line">    <span class="built_in">console</span>.log(second) <span class="comment">//'blue'</span></span><br></pre></td></tr></table></figure><h3 id="6-3-8-Spread-Operator"><a href="#6-3-8-Spread-Operator" class="headerlink" title="6.3.8 Spread Operator"></a>6.3.8 Spread Operator</h3><p>ES6中另外一个好玩的特性就是Spread Operator 也是三个点儿…接下来就展示一下它的用途。 组装对象或者数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">const</span> color = [<span class="string">'red'</span>, <span class="string">'yellow'</span>]</span><br><span class="line"><span class="keyword">const</span> colorful = [...color, <span class="string">'green'</span>, <span class="string">'pink'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(colorful) <span class="comment">//[red, yellow, green, pink]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="keyword">const</span> alp = &#123; <span class="attr">fist</span>: <span class="string">'a'</span>, <span class="attr">second</span>: <span class="string">'b'</span>&#125;</span><br><span class="line"><span class="keyword">const</span> alphabets = &#123; ...alp, <span class="attr">third</span>: <span class="string">'c'</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(alphabets) <span class="comment">//&#123; "fist": "a", "second": "b", "third": "c"</span></span><br></pre></td></tr></table></figure><h3 id="6-3-9-import-和-export"><a href="#6-3-9-import-和-export" class="headerlink" title="6.3.9 import 和 export"></a>6.3.9 import 和 export</h3><p>import导入模块、export导出模块</p><p>lib.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn0=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fn0...'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;fn0&#125;</span><br></pre></td></tr></table></figure><p>demo9.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;fn0&#125; <span class="keyword">from</span> <span class="string">'./lib'</span></span><br><span class="line">fn0();</span><br></pre></td></tr></table></figure><p>注意：node(v8.x)本身并不支持import关键字，所以我们需要使用babel的命令行工具来执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel-node demo9</span><br></pre></td></tr></table></figure><p><strong>详细了解可以参考一下阮一峰的ECMAScript 6 入门</strong><br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a></p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> babel </tag>
            
            <tag> VSCODE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js的基本使用姿势</title>
      <link href="/2019/02/03/NoDeJs%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
      <url>/2019/02/03/NoDeJs%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h3 id="什么是Node-js"><a href="#什么是Node-js" class="headerlink" title="什么是Node.js"></a>什么是Node.js</h3><blockquote><p>简单的说 Node.js 就是运行在服务端的 JavaScript。<br>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。<br>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p></blockquote><h3 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h3><ol><li>下载对应你系统的Node.js版本:</li></ol><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">下载node.js</a></p><ol start="2"><li>选安装目录进行安装(默认即可)</li></ol><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h4><p><img src="/2019/02/03/NoDeJs的基本使用姿势/quickcomein1.png" alt="控制台输出"></p><p>输入node demo1.js执行即可</p><h4 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h4><p><img src="/2019/02/03/NoDeJs的基本使用姿势/quickcomein2.png" alt="使用函数"></p><h4 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h4><p><img src="/2019/02/03/NoDeJs的基本使用姿势/quickcomein3.png" alt="被调用模块"></p><p><img src="/2019/02/03/NoDeJs的基本使用姿势/quickcomein4.png" alt="调用模块"></p><h4 id="创建web服务器"><a href="#创建web服务器" class="headerlink" title="创建web服务器"></a>创建web服务器</h4><pre><code>//创建WEB服务器var http=require(&apos;http&apos;);http.createServer(function(request,response){    // 发送 HTTP 头部    // HTTP 状态值: 200 : OK    // 内容类型: text/plain    response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;})    // 发送响应数据 &quot;Hello World&quot;    response.end(&apos;Hello World\n&apos;);}).listen(9000);// 终端打印如下信息console.log(&apos;Server running at http://127.0.0.1:8888/&apos;);</code></pre><p><em>http为node.js内置的web模块</em></p><h4 id="理解服务渲染"><a href="#理解服务渲染" class="headerlink" title="理解服务渲染"></a>理解服务渲染</h4><pre><code>//创建WEB服务器var http=require(&apos;http&apos;);http.createServer(function(request,response){    // 发送 HTTP 头部    // HTTP 状态值: 200 : OK    // 内容类型: text/plain    response.writeHead(200,{&apos;Content-Type&apos;:&apos;text/plain&apos;})    // 发送响应数据 &quot;Hello World&quot;    for(var i=0;i&lt;10;i++){        response.write(&apos;Hello World\n&apos;);    }    response.end(&apos;&apos;);}).listen(9000);// 终端打印如下信息console.log(&apos;Server running at http://127.0.0.1:9000/&apos;);</code></pre><blockquote><p>我们右键“查看源代码”发现，并没有我们写的for循环语句，而是直接的10条Hello World<br>，这就说明这个循环是在服务端完成的，而非浏览器（客户端）来完成。这与我们原来<br>的JSP很是相似。</p></blockquote><h4 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h4><pre><code>//接收参数var http=require(&apos;http&apos;);var url=require(&apos;url&apos;);http.createServer(function(request,response){    response.writeHead(200,{&apos;Content-Type&apos;:&apos;text/plain&apos;});    //解析url参数    var params=url.parse(request.url,true).query;    response.write(&quot;name:&quot;+params.name);    response.write(&quot;\n&quot;);    response.end();}).listen(8888);</code></pre><blockquote><p>测试地址<a href="http://localhost:8888/?name=huangsm" target="_blank" rel="noopener">http://localhost:8888/?name=huangsm</a></p></blockquote><h3 id="包资源管理器NPM"><a href="#包资源管理器NPM" class="headerlink" title="包资源管理器NPM"></a>包资源管理器NPM</h3><h4 id="什么是NPM"><a href="#什么是NPM" class="headerlink" title="什么是NPM"></a>什么是NPM</h4><blockquote><p>npm全称Node Package Manager，他是node包管理和分发工具。其实我们可以把NPM<br>理解为前端的Maven .<br>我们通过npm 可以很方便地下载js库，管理前端工程.<br>最近版本的node.js已经集成了npm工具，在命令提示符输入 npm -v 可查看当前npm版本</p></blockquote><h4 id="NPM命令"><a href="#NPM命令" class="headerlink" title="NPM命令"></a>NPM命令</h4><h5 id="初始化工程"><a href="#初始化工程" class="headerlink" title="初始化工程"></a>初始化工程</h5><blockquote><p>init命令是工程初始化命令。建立一个空文件夹，在命令提示符进入该文件夹 执行命令初始化</p></blockquote><pre><code>npm init按照提示输入相关信息，如果是用默认值则直接回车即可。name: 项目名称version: 项目版本号description: 项目描述keywords: {Array}关键词，便于用户搜索到我们的项目最后会生成package.json文件，这个是包的配置文件，相当于maven的pom.xml我们之后也可以根据需要进行修改。</code></pre><h5 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h5><blockquote><p>install命令用于安装某个模块，如果我们想安装express模块（node的web框架），输出命令如下:</p></blockquote><pre><code>npm install express出现黄色的是警告信息，可以忽略，请放心，你已经成功执行了该命令。在该目录下已经出现了一个node_modules文件夹 和package-lock.jsonnode_modules文件夹用于存放下载的js库（相当于maven的本地仓库）package-lock.json是当 node_modules 或 package.json 发生变化时自动生成的文件。这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。我们再打开package.json文件，发现刚才下载的express已经添加到依赖列表中了.关于版本号定义：指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。latest：安装最新版本。</code></pre><h5 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h5><blockquote><p>刚才我们使用的是本地安装，会将js库安装在当前目录，而使用全局安装会将库安装到你的全局目录下。如果你不知道你的全局目录在哪里，执行命令</p></blockquote><pre><code>npm root ‐g</code></pre><blockquote><p>我的全局目录在C:\Users\Administrator\AppData\Roaming\npm\node_modules</p></blockquote><p>比如我们全局安装jquery, 输入以下命令</p><pre><code>npm install jquery ‐g</code></pre><h4 id="批量下载"><a href="#批量下载" class="headerlink" title="批量下载"></a>批量下载</h4><blockquote><p>我们从网上下载某些代码，发现只有package.json,没有node_modules文件夹，这时我们需要通过命令重新下载这些js库</p></blockquote><blockquote><p>进入目录（package.json所在的目录）输入命令</p></blockquote><pre><code>npm install</code></pre><blockquote><p>此时，npm会自动下载package.json中依赖的js库.</p></blockquote><h4 id="淘宝NPM镜像"><a href="#淘宝NPM镜像" class="headerlink" title="淘宝NPM镜像"></a>淘宝NPM镜像</h4><blockquote><p>有时我们使用npm下载资源会很慢，所以我们可以安装一个cnmp(淘宝镜像)来加快下载速度</p><p>输入命令，进行全局安装淘宝镜像。</p></blockquote><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><blockquote><p>安装后，我们可以使用以下命令来查看cnpm的版本</p></blockquote><pre><code>cnpm -v</code></pre><blockquote><p>使用cnpm</p></blockquote><pre><code>cnpm install 需要下载的js库</code></pre><h4 id="运行工程"><a href="#运行工程" class="headerlink" title="运行工程"></a>运行工程</h4><blockquote><p>如果我们想运行某个工程，则使用run命令如果package.json中定义的脚本如下dev是开发阶段测试运行build是构建编译工程lint 是运行js代码检测我们现在来试一下运行dev</p></blockquote><pre><code>npm run dev</code></pre><h4 id="编译工程"><a href="#编译工程" class="headerlink" title="编译工程"></a>编译工程</h4><blockquote><p>我们接下来，测试一个代码的编译.编译后我们就可以将工程部署到nginx中,编译后的代码会放在dist文件夹中，首先我们先删除dist文件夹中的文件,进入命令提示符</p></blockquote><blockquote><p>输入命令</p></blockquote><pre><code>npm run build生成后我们会发现只有个静态页面，和一个static文件夹这种工程我们称之为单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。这里其实是调用了webpack来实现打包的.</code></pre><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><h4 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h4><blockquote><p>Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源</p></blockquote><p><img src="/2019/02/03/NoDeJs的基本使用姿势/webpack1.png" alt="webpack的架构图"></p><blockquote><p>从图中我们可以看出,Webpack可以将多种静态资源js、css、less 转换成一个静态文件,减少了页面的请求。接下来我们简单为大家介绍Webpack的安装与使用</p></blockquote><h4 id="Webpack安装"><a href="#Webpack安装" class="headerlink" title="Webpack安装"></a>Webpack安装</h4><blockquote><p>全局安装</p></blockquote><pre><code>cnpm install webpack -gcnpm install webpack-cli -g</code></pre><blockquote><p>安装后查看版本号</p></blockquote><pre><code>webpack -v</code></pre><h4 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h4><h5 id="JS打包"><a href="#JS打包" class="headerlink" title="JS打包"></a>JS打包</h5><ul><li>创建src文件夹，创建bar.js</li></ul><hr><pre><code>exports.info=function(str){    document.write(str);};</code></pre><ul><li>src下创建logic.js</li></ul><hr><pre><code>exports.add=function(a,b){    return a+b;};</code></pre><ul><li>src下创建main.js</li></ul><hr><pre><code>var bar=require(&apos;./bar&apos;);var logic=require(&apos;./logic&apos;);bar.info(&apos;hello world!&apos;+logic.add(100,200));</code></pre><ul><li>创建配置文件webpack.config.js ，该文件与src处于同级目录</li></ul><hr><pre><code>const path = require(&apos;path&apos;);module.exports = {  entry: &apos;./src/main.js&apos;,  output: {      path: path.resolve(__dirname, &apos;dist&apos;),    filename: &apos;bundle.js&apos;  }};</code></pre><blockquote><p>以上代码的意思是：读取当前目录下src文件夹中的main.js（入口文件）内容，把对应的js文件打包，打包后的文件放入当前目录的dist文件夹下，打包后的js文件名为bundle.</p></blockquote><ul><li><p>执行编译命令</p><p>  webpack</p><blockquote><p>执行后查看bundle.js 会发现里面包含了上面两个js文件的</p></blockquote></li><li><p>创建index.html ,引用bundle.js</p></li></ul><hr><pre><code>&lt;!doctype html&gt;&lt;html&gt;    &lt;head&gt;    &lt;/head&gt;        &lt;body&gt;            &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;        &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> webpack </tag>
            
            <tag> NPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器管理与容器监控</title>
      <link href="/2019/02/03/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7/"/>
      <url>/2019/02/03/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="容器管理与容器监控"><a href="#容器管理与容器监控" class="headerlink" title="容器管理与容器监控"></a>容器管理与容器监控</h1><h2 id="容器管理工具Rancher"><a href="#容器管理工具Rancher" class="headerlink" title="容器管理工具Rancher"></a>容器管理工具Rancher</h2><h3 id="什么是Rancher"><a href="#什么是Rancher" class="headerlink" title="什么是Rancher"></a>什么是Rancher</h3><blockquote><p>Rancher是一个开源的企业级全栈化容器部署及管理平台。Rancher为容器提供一揽子基础架构服务：CNI兼容的网络服务、存储服务、主机管理、负载均衡、防护墙……Rancher让上述服务跨越公有云、私有云、虚拟机、物理机环境运行，真正实现一键式应用部署和管理</p></blockquote><p><a href="https://www.cnrancher.com/" target="_blank" rel="noopener">Rancher官网</a></p><h3 id="Rancher安装"><a href="#Rancher安装" class="headerlink" title="Rancher安装"></a>Rancher安装</h3><ul><li>下载镜像</li></ul><blockquote><p>docker pull rancher/server</p></blockquote><ul><li>创建Rancher容器</li></ul><blockquote><p>docker run -d –name=rancher –restart=always -p 9090:8080 rancher/server</p></blockquote><pre><code>restart为重启策略no，默认策略，在容器退出时不重启容器on-failure，在容器非正常退出时（退出状态非0），才会重启on-failure:3，在容器非正常退出时重启容器，最多重启3次always，在容器退出时总是重启容器unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的</code></pre><ul><li>测试</li></ul><blockquote><p><a href="http://192.168.25.134:9090/" target="_blank" rel="noopener">http://192.168.25.134:9090/</a></p></blockquote><h3 id="Rancher初始化"><a href="#Rancher初始化" class="headerlink" title="Rancher初始化"></a>Rancher初始化</h3><h4 id="添加环境"><a href="#添加环境" class="headerlink" title="添加环境"></a>添加环境</h4><blockquote><p>Rancher 支持将资源分组归属到多个环境。 每个环境具有自己独立的基础架构资源及服务，并由一个或多个用户、团队或组织所管理。例如，您可以创建独立的“开发”、“测试”及“生产”环境以确保环境之间的安全隔离，将“开发”环境的访问权限赋予全部人员，但限制“生产”环境的访问权限给一个小的团队。</p><p>（1）选择“Default –&gt;环境管理</p></blockquote><p><img src="/2019/02/03/容器管理与容器监控/Rancher环境管理.png" alt="Rancher环境管理"></p><blockquote><p>（2）填写名称，点击”创建”按钮</p></blockquote><p><img src="/2019/02/03/容器管理与容器监控/添加环境.png" alt="添加环境"></p><blockquote><p>（3）按照上述步骤，添加服务测试环境和生产环境</p></blockquote><p><img src="/2019/02/03/容器管理与容器监控/三种环境.png" alt="三种环境"></p><blockquote><p>（4）你可以通过点击logo右侧的菜单在各种环境下</p></blockquote><h4 id="添加镜像库"><a href="#添加镜像库" class="headerlink" title="添加镜像库"></a>添加镜像库</h4><blockquote><p>192.168.25.134</p></blockquote><p><img src="/2019/02/03/容器管理与容器监控/添加镜像库.png" alt="添加镜像库"></p><h4 id="添加主机"><a href="#添加主机" class="headerlink" title="添加主机"></a>添加主机</h4><ul><li>选择基础架构–&gt;主机 菜单，点击添加主机</li><li>拷贝脚本</li></ul><p><img src="/2019/02/03/容器管理与容器监控/添加主机拷贝脚本文件.png" alt="添加主机拷贝脚本文件"></p><ul><li>在服务器（虚拟机）上运行脚本</li></ul><p><img src="/2019/02/03/容器管理与容器监控/脚本执行.png" alt="脚本执行"></p><ul><li>点击关闭按钮后，会看到界面中显示此主机。我们可以很方便地管理主机的每个容器的开启和关闭</li></ul><p><img src="/2019/02/03/容器管理与容器监控/主机显示.png" alt="主机显示"></p><h4 id="添加应用-所有微服务的集合"><a href="#添加应用-所有微服务的集合" class="headerlink" title="添加应用(所有微服务的集合)"></a>添加应用(所有微服务的集合)</h4><ul><li>点击应用–&gt;全部(或用户) ，点击”添加应用”按钮</li></ul><p><img src="/2019/02/03/容器管理与容器监控/添加应用.png" alt="添加应用"></p><ul><li>填写名称和描述</li></ul><p><img src="/2019/02/03/容器管理与容器监控/填写名称和描述.png" alt="填写名称和描述"></p><ul><li>点击”创建”按钮，列表中增加了新增的应用</li></ul><p><img src="/2019/02/03/容器管理与容器监控/新增的应用.png" alt="新增的应用"></p><h3 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h3><h4 id="MySQL部署"><a href="#MySQL部署" class="headerlink" title="MySQL部署"></a>MySQL部署</h4><ul><li>镜像：centos/mysql-57-centos7 增加数据库服务</li></ul><p><img src="/2019/02/03/容器管理与容器监控/添加服务.png" alt="添加服务"></p><p><img src="/2019/02/03/容器管理与容器监控/添加MYSQL环境变量.png" alt="添加MYSQL环境变量"></p><ul><li>点击创建按钮，完成创建 上述操作相当于以下docker命令</li></ul><blockquote><p>docker run ‐d ‐‐name mysql ‐p 3306:3306 ‐e MYSQL_ROOT_PASSWORD=mysql centos/mysql‐57‐centos</p></blockquote><p><img src="/2019/02/03/容器管理与容器监控/mysql服务构建成功.png" alt="mysql服务构建成功"></p><h3 id="微服务容器部署"><a href="#微服务容器部署" class="headerlink" title="微服务容器部署"></a>微服务容器部署</h3><h4 id="Eureka微服务容器化部署"><a href="#Eureka微服务容器化部署" class="headerlink" title="Eureka微服务容器化部署"></a>Eureka微服务容器化部署</h4><ul><li>在用户应用界面中点击”添加服务”</li><li>填写名称、描述、镜像和端口映射，点击创建按钮</li></ul><p><img src="/2019/02/03/容器管理与容器监控/部署eureka服务.png" alt="部署eureka服务"></p><ul><li>服务添加成功</li></ul><h2 id="influxDB"><a href="#influxDB" class="headerlink" title="influxDB"></a>influxDB</h2><h3 id="什么是influxDB"><a href="#什么是influxDB" class="headerlink" title="什么是influxDB"></a>什么是influxDB</h3><blockquote><p>influxDB是一个分布式时间序列数据库。cAdvisor仅仅显示实时信息，但是不存储监视数据。因此，我们需要提供时序数据库用于存储cAdvisor组件所提供的监控信息，以便显示除实时信息之外的时序数</p></blockquote><h3 id="influxDB安装"><a href="#influxDB安装" class="headerlink" title="influxDB安装"></a>influxDB安装</h3><ul><li>下载镜像</li></ul><blockquote><p>docker pull tutum/influxdb</p></blockquote><ul><li>创建容器</li></ul><blockquote><p>docker run -d -p 8083:8083 -p 8086:8086 –expose 8090 –expose 8099 –name influxsrv tutum/influxdb</p></blockquote><blockquote><p>端口概述： 8083端口:web访问端口 8086:数据写入</p></blockquote><ul><li><a href="http://192.168.25.134:8083/" target="_blank" rel="noopener">http://192.168.25.134:8083/</a></li></ul><p><img src="/2019/02/03/容器管理与容器监控/查看InfluxDB页面.png" alt="查看InfluxDB页面"></p><h3 id="nfluxDB常用操作"><a href="#nfluxDB常用操作" class="headerlink" title="nfluxDB常用操作"></a>nfluxDB常用操作</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p><img src="/2019/02/03/容器管理与容器监控/创建数据库.png" alt="创建数据库"></p><h4 id="创建用户并授权"><a href="#创建用户并授权" class="headerlink" title="创建用户并授权"></a>创建用户并授权</h4><ul><li>创建用户</li></ul><p><img src="/2019/02/03/容器管理与容器监控/创建Admin用户.png" alt="创建Admin用户"></p><ul><li>查看用户</li></ul><p><img src="/2019/02/03/容器管理与容器监控/查看用户.png" alt="查看用户"></p><ul><li><p>用户授权</p><pre><code>grant all privileges on huangsm to huangsmgrant WRITE on huangsm to huangsmgrant READ on huangsm to huangsm</code></pre></li></ul><h4 id="查看采集的数据"><a href="#查看采集的数据" class="headerlink" title="查看采集的数据　"></a>查看采集的数据　</h4><blockquote><p>SHOW MEASUREMEN</p></blockquote><h2 id="cAdvisor"><a href="#cAdvisor" class="headerlink" title="cAdvisor"></a>cAdvisor</h2><h3 id="什么是cAdvisor"><a href="#什么是cAdvisor" class="headerlink" title="什么是cAdvisor"></a>什么是cAdvisor</h3><blockquote><p>Google开源的用于监控基础设施应用的工具，它是一个强大的监控工具，不需要任何配置就可以通过运行在Docker主机上的容器来监控Docker容器，而且可以监控Docker主机。更多详细操作和配置选项可以查看Github上的cAdvisor项目文档。</p></blockquote><h3 id="cAdvisor安装"><a href="#cAdvisor安装" class="headerlink" title="cAdvisor安装"></a>cAdvisor安装</h3><ul><li>拉去镜像</li></ul><blockquote><p>docker pull google/cadvisor</p></blockquote><ul><li>启动容器</li></ul><pre><code>docker run -v=/:/rootfs:ro -v=/var/run:/var/run:rw -v=/sys:/sys:ro -v=/var/lib/docker/:/var/lib/docker:ro -p 8080:8080 --detach=true --link influxsrv:influxsrv --name=cadvisor google/cadvisor -storage_driver=influxdb -storage_driver_db=huangsm -storage_driver_host=influxsrv:8086</code></pre><blockquote><p>WEB前端访问地址 <a href="http://192.168.25.134:8080/containers/" target="_blank" rel="noopener">http://192.168.25.134:8080/containers/</a></p></blockquote><p><a href="https://blog.csdn.net/ZHANG_H_A/article/details/53097084" target="_blank" rel="noopener">性能指标含义参照如下地址</a></p><p>再次查看influxDB，发现已经有很多数据被采集进去</p><p><img src="/2019/02/03/容器管理与容器监控/cadvisor采集数据.png" alt="cadvisor采集数据"></p><h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><h3 id="什么是Grafana"><a href="#什么是Grafana" class="headerlink" title="什么是Grafana"></a>什么是Grafana</h3><blockquote><p>Grafana是一个可视化面板（Dashboard），有着非常漂亮的图表和布局展示，功能齐全的度量仪表盘和图形编辑器。支持Graphite、zabbix、InfluxDB、Prometheus和OpenTSDB作为数据源。Grafana主要特性：灵活丰富的图形化选项；可以混合多种风格；支持白天和夜间模式；多个数据源。</p></blockquote><h3 id="Grafana安装"><a href="#Grafana安装" class="headerlink" title="Grafana安装"></a>Grafana安装</h3><ul><li><p>下载镜像</p><blockquote><p>docker pull grafana/grafana</p></blockquote></li><li><p>创建容器</p></li></ul><blockquote><p>docker run -d -p 3001:3000 -e INFLUXDB_HOST=influxsrv -e INFLUXDB_PORT=8086 -e INFLUXDB_NAME=cadvisor -e INFLUXDB_USER=huangsm -e INFLUXDB_PASS=1234 –link influxsrv:influxsrv –name=grafana  grafana/grafana</p></blockquote><ul><li>访问(<a href="http://192.168.25.134:3001" target="_blank" rel="noopener">http://192.168.25.134:3001</a> 初始帐号密码都为admin)</li></ul><p><img src="/2019/02/03/容器管理与容器监控/grafana登录页面.png" alt="grafana登录页面"></p><ul><li>登录后提示你修改密码</li><li>之后进入主页面</li></ul><p><img src="/2019/02/03/容器管理与容器监控/grafana主页面.png" alt="grafana主页面"></p><h3 id="Grafana的使用"><a href="#Grafana的使用" class="headerlink" title="Grafana的使用"></a>Grafana的使用</h3><h4 id="添加数据源"><a href="#添加数据源" class="headerlink" title="添加数据源"></a>添加数据源</h4><ul><li>点击设置，DataSource</li></ul><p><img src="/2019/02/03/容器管理与容器监控/grafana添加数据源.png" alt="grafana添加数据源"></p><ul><li>点击添加data source</li></ul><p><img src="/2019/02/03/容器管理与容器监控/grafana数据源.png" alt="grafana数据源"></p><ul><li>为数据源起个名称，指定类型、地址、以及连接的数据库名、用户名和密码</li></ul><p><img src="/2019/02/03/容器管理与容器监控/grafana数据源数据填写.png" alt="grafana数据源数据填写"></p><h4 id="添加仪表盘"><a href="#添加仪表盘" class="headerlink" title="添加仪表盘"></a>添加仪表盘</h4><ul><li>选择Dashboards –Manager</li></ul><p><img src="/2019/02/03/容器管理与容器监控/grafana添加仪表盘.png" alt="grafana添加仪表盘"></p><ul><li>点击“添加”按钮</li><li>点击Graph图标</li></ul><p><img src="/2019/02/03/容器管理与容器监控/grafana点击grafana.png" alt="grafana点击grafana"></p><ul><li>出现下面图表的界面 ，点击Panel Title 选择Edit (编辑)</li></ul><p><img src="/2019/02/03/容器管理与容器监控/grafana编辑Graph.png" alt="grafana编辑Graph"></p><ul><li>定义标题等基础信息</li></ul><p><img src="/2019/02/03/容器管理与容器监控/grafana基础服务内存监控.png" alt="grafana基础服务内存监控"></p><ul><li>设置查询的信息为内存，指定容器名称</li></ul><p><img src="/2019/02/03/容器管理与容器监控/grafana监控rabbitmq.png" alt="grafana监控rabbitmq"></p><ul><li>指定y轴的单位 为M</li></ul><p><img src="/2019/02/03/容器管理与容器监控/grafana指定y.png" alt="grafana指定y"></p><ul><li>保存</li></ul><p><img src="/2019/02/03/容器管理与容器监控/grafana保存.png" alt="grafana保存"></p><h4 id="预警通知设置"><a href="#预警通知设置" class="headerlink" title="预警通知设置"></a>预警通知设置</h4><ul><li>选择菜单 alerting–&gt; Notification channels</li></ul><p><img src="/2019/02/03/容器管理与容器监控/预警通知1.png" alt="预警通知1"></p><ul><li>点击Add channel 按钮</li></ul><p><img src="/2019/02/03/容器管理与容器监控/预警通知2.png" alt="预警通知1"></p><ul><li>填写名称，选择类型为webhook ,填写钩子地址（这个钩子地址是之前对base微服务扩容的地址）</li></ul><p><img src="/2019/02/03/容器管理与容器监控/预警通知3.png" alt="预警通知1"></p><ul><li>点击SendTest 测试 观察基础微服务是否增加容器</li><li>点击save保存</li><li>按照同样的方法添加缩容地址</li></ul><h4 id="仪表盘预警设置"><a href="#仪表盘预警设置" class="headerlink" title="仪表盘预警设置"></a>仪表盘预警设置</h4><ul><li>再次打开刚刚编辑的仪表盘</li></ul><p><img src="/2019/02/03/容器管理与容器监控/仪表盘预警1.png" alt="仪表盘预警1"></p><ul><li>点击 Create Alert</li></ul><p><img src="/2019/02/03/容器管理与容器监控/仪表盘预警2.png" alt="仪表盘预警2"></p><ul><li>选择通知</li></ul><p><img src="/2019/02/03/容器管理与容器监控/仪表盘预警3.png" alt="仪表盘预警3"></p><p><img src="/2019/02/03/容器管理与容器监控/仪表盘预警4.png" alt="仪表盘预警4"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> Rancher </tag>
            
            <tag> influxDB </tag>
            
            <tag> cAdvisor </tag>
            
            <tag> Grafana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务的持续化部署</title>
      <link href="/2019/02/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%8C%81%E7%BB%AD%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/02/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%8C%81%E7%BB%AD%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="理解持续集成"><a href="#理解持续集成" class="headerlink" title="理解持续集成"></a>理解持续集成</h2><h3 id="什么是持续集成"><a href="#什么是持续集成" class="headerlink" title="什么是持续集成"></a>什么是持续集成</h3><blockquote><p>持续集成 Continuous integration ，简称CI</p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件<br>开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile）<br>在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也<br>显得尤其的重要。</p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常<br>集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建<br>来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开<br>发内聚的软件.</p></blockquote><h3 id="持续集成的特点"><a href="#持续集成的特点" class="headerlink" title="持续集成的特点"></a>持续集成的特点</h3><ul><li>它是一个自动化的周期性的集成测试过程，从检出代码、编译构建、运行测试、结果记录、测试统计等都是自动完成的，无需人工干预；</li><li>需要有专门的集成服务器来执行集成构建；</li><li>需要有代码托管工具支持，我们下一小节将介绍Git以及可视化界面Gogs的</li></ul><h3 id="持续集成作用"><a href="#持续集成作用" class="headerlink" title="持续集成作用"></a>持续集成作用</h3><ul><li>保证团队开发人员提交代码的质量，减轻了软件发布时的压力；</li><li>持续集成中的任何一个环节都是自动完成的，无需太多的人工干预，有利于减少重复<br>过程以节省时间、费用和工作量；</li></ul><h2 id="Gogs"><a href="#Gogs" class="headerlink" title="Gogs"></a>Gogs</h2><h3 id="什么是Gogs"><a href="#什么是Gogs" class="headerlink" title="什么是Gogs"></a>什么是Gogs</h3><blockquote><p>Gogs 是一款极易搭建的自助 Git 服务。</p></blockquote><blockquote><p>Gogs 的目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务。使用 Go 语<br>言开发使得 Gogs 能够通过独立的二进制分发，并且支持 Go 语言支持的 所有平台，包<br>括 Linux、Mac OS X、Windows 以及 ARM 平台。</p></blockquote><blockquote><p>地址：<a href="https://gitee.com/Unknown/gogs" target="_blank" rel="noopener">https://gitee.com/Unknown/gogs</a></p></blockquote><h3 id="Gogs安装与配置"><a href="#Gogs安装与配置" class="headerlink" title="Gogs安装与配置"></a>Gogs安装与配置</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li><p>下载镜像</p><p>  docker pull gogs/gogs</p></li><li><p>创建容器</p><p>  docker run -d –name=gogs -p 10022:22 -p 3000:3000 -v /var/gogsdata:/data gogs/gogs</p></li></ul><p><em>3000是外部访问使用，10022是内部使用</em></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><blockquote><p>假设我的centos虚拟机IP为192.168.25.134 完成以下步骤<br>（1）在地址栏输入<a href="http://192.168.25.134:3000" target="_blank" rel="noopener">http://192.168.25.134:3000</a> 会进入首次运行安装程序页面，我们<br>可以选择一种数据库作为gogs数据的存储，最简单的是选择SQLite3。如果对于规模较大<br>的公司，可以选择MySQL</p></blockquote><p><img src="/2019/02/02/微服务的持续化部署/gogs配置1.png" alt="微服务的持续化部署"></p><p><img src="/2019/02/02/微服务的持续化部署/gogs配置2.png" alt="微服务的持续化部署"></p><p><strong>剩下的操作类似与码云和gitHub这里就不一一赘述了</strong></p><p><img src="/2019/02/02/微服务的持续化部署/代码部署到gogs.png" alt="代码部署到gogs"></p><h2 id="运用Jenkins实现持续集成"><a href="#运用Jenkins实现持续集成" class="headerlink" title="运用Jenkins实现持续集成"></a>运用Jenkins实现持续集成</h2><h3 id="Jenkins简介"><a href="#Jenkins简介" class="headerlink" title="Jenkins简介"></a>Jenkins简介</h3><blockquote><p>Jenkins，原名Hudson，2011年改为现在的名字，它是一个开源的实现持续集成的软件工具。</p></blockquote><blockquote><p>官方网站：<a href="http://jenkins-ci.org/。" target="_blank" rel="noopener">http://jenkins-ci.org/。</a><br>Jenkins能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。</p></blockquote><blockquote><p>特点:</p></blockquote><ul><li>易安装：仅仅一个 java -jar jenkins.war，从官网下载该文件后，直接运行，无需额外的安装，更无需安装数据库；</li><li>易配置：提供友好的GUI配置界面；</li><li>变更支持：Jenkins能从代码仓库（Subversion/CVS）中获取并产生代码更新列表并输出到编译输出信息中；支持永久</li><li>链接：用户是通过web来访问Jenkins的，而这些web页面的链接地址都是永久链接地址，因此，你可以在各种文档中直接使用该链接；</li><li>集成E-Mail/RSS/IM：当完成一次集成时，可通过这些工具实时告诉你集成结果（据我所知，构建一次集成需要花费一定时间，有了这个功能，你就可以在等待结果过程中，干别的事情）；</li><li>JUnit/TestNG测试报告：也就是用以图表等形式提供详细的测试报表功能；</li><li>支持分布式构建：Jenkins可以把集成构建等工作分发到多台计算机中完成；</li><li>文件指纹信息：Jenkins会保存哪次集成构建产生了哪些jars文件，哪一次集成构建使用了哪个版本的jars文件等构建记录；</li><li>支持第三方插件：使得 Jenkins 变得越来越</li></ul><h3 id="Jenkins安装"><a href="#Jenkins安装" class="headerlink" title="Jenkins安装"></a>Jenkins安装</h3><h4 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h4><ul><li>将jdk-8u171-linux-x64.rpm上传至服务器（虚拟机）</li><li><p>执行安装命令</p><p>  rpm ‐ivh jdk‐8u171‐linux‐x64.rpm</p></li><li><p>RPM方式安装JDK，其根目录为：/usr/java/jdk1.8.0_171t</p></li></ul><h4 id="Jenkins安装与启动"><a href="#Jenkins安装与启动" class="headerlink" title="Jenkins安装与启动"></a>Jenkins安装与启动</h4><ul><li><p>下载jenkins</p><blockquote><p>wget <a href="https://pkg.jenkins.io/redhat/jenkins‐2.83‐1.1.noarch.rpm" target="_blank" rel="noopener">https://pkg.jenkins.io/redhat/jenkins‐2.83‐1.1.noarch.rpm</a></p></blockquote></li><li><p>安装jenkins</p><blockquote><p>rpm ‐ivh jenkins‐2.83‐1.1.noarch.rpm</p></blockquote></li><li><p>配置jenkins</p><blockquote><p>vi /etc/sysconfig/jenkins</p></blockquote></li></ul><p>修改用户和端口</p><blockquote><p>JENKINS_USER=”root”<br>JENKINSPORT=”8888”</p></blockquote><ul><li>启动服务</li></ul><blockquote><p>systemctl start jenkins</p></blockquote><ul><li>访问链接 <a href="http://192.168.25.134:8888" target="_blank" rel="noopener">http://192.168.25.134:8888</a></li></ul><blockquote><p>从/var/lib/jenkins/secrets/initialAdminPassword中获取初始密码串</p></blockquote><p><img src="/2019/02/02/微服务的持续化部署/Jenkins输入密码.png" alt="Jenkins输入密码"></p><ul><li>安装插件</li></ul><p><img src="/2019/02/02/微服务的持续化部署/安装jenkins插件.png" alt="安装jenkins插件"></p><p><img src="/2019/02/02/微服务的持续化部署/安装插件.png" alt="安装插件"></p><ul><li>新建用户</li></ul><p><img src="/2019/02/02/微服务的持续化部署/新建jenkins用户.png" alt="新建jenkins用户"></p><h3 id="Jenkins插件安装"><a href="#Jenkins插件安装" class="headerlink" title="Jenkins插件安装"></a>Jenkins插件安装</h3><h4 id="安装Maven插件"><a href="#安装Maven插件" class="headerlink" title="安装Maven插件"></a>安装Maven插件</h4><p><img src="/2019/02/02/微服务的持续化部署/jenkins安装maven插件.png" alt="jenkins安装maven插件"></p><h3 id="全局工具配置"><a href="#全局工具配置" class="headerlink" title="全局工具配置"></a>全局工具配置</h3><p>选择系统管理，全局工具配置</p><ul><li>JDK安装</li></ul><p><img src="/2019/02/02/微服务的持续化部署/JDK全局配置.png" alt="JDK全局配置"></p><p>设置JAVA_HOME为 /usr/java/jdk1.8.0_171-amd64</p><ul><li>Maven安装（这里的mavenhome是我服务器上maven的路径）</li></ul><p><img src="/2019/02/02/微服务的持续化部署/Maven全局配置.png" alt="Maven全局配置"></p><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><h4 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4><blockquote><p>回到首页，点击新建按钮 .如下图，输入名称，选择创建一个Maven项目，点击OK</p></blockquote><p><img src="/2019/02/02/微服务的持续化部署/制作eureka镜像.png" alt="制作eureka镜像"></p><p><img src="/2019/02/02/微服务的持续化部署/持续集成命令.png" alt="持续集成命令"></p><blockquote><p>可以看到控制台输出</p></blockquote><p><img src="/2019/02/02/微服务的持续化部署/jenkins持续继承配置.png" alt="jenkins持续继承配置"></p><blockquote><p>持续集成成功</p></blockquote><p><img src="/2019/02/02/微服务的持续化部署/持续集成成功.png" alt="持续集成成功"></p><p><strong>这样我们的持续集成就算配置完成了</strong></p>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> gogs </tag>
            
            <tag> jenkins </tag>
            
            <tag> 持续化部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dockerfile的基本使用以及服务的部署</title>
      <link href="/2019/02/01/dockerfile%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/02/01/dockerfile%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><h3 id="什么是DockerFile"><a href="#什么是DockerFile" class="headerlink" title="什么是DockerFile?"></a>什么是DockerFile?</h3><pre><code>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；3、对于运维人员：在部署时，可以实现应用的无缝移植。</code></pre><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="/2019/02/01/dockerfile的基本使用以及服务的部署/DockerFile常用命令.png" alt="DockerFile常用命令"></p><h3 id="使用脚本创建镜像"><a href="#使用脚本创建镜像" class="headerlink" title="使用脚本创建镜像"></a>使用脚本创建镜像</h3><pre><code>1.首先将jdk的压缩包上传到服务器2.编写dockerfile#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER Huangsm#切换工作目录WORKDIR /usrRUN mkdir /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH3.使用docker build构建镜像使用命令docker build -t=&quot;huangsm/jdk8&quot; . 4.启动容器docker run -it --name=myjdk8 huangsm/jdk8 /bin/bash</code></pre><h2 id="Docker私有仓库"><a href="#Docker私有仓库" class="headerlink" title="Docker私有仓库"></a>Docker私有仓库</h2><h3 id="私有仓库搭建与配置"><a href="#私有仓库搭建与配置" class="headerlink" title="私有仓库搭建与配置"></a>私有仓库搭建与配置</h3><pre><code>1.拉取私有仓库镜像docker pull registry2.启动私有仓库容器docker run -d --name=huangsm_dockerresp -p 5000:5000 docker.io/registry3.查看仓库内容http://192.168.25.133:5000/v2/_catalog4.修改daemon.jsonvi /etc/docker/daemon.json 添加如下内容:&quot;insecure-registries&quot;:[&quot;192.168.25.133:5000&quot;]5.重启docker服务systemctl restart docker</code></pre><h3 id="镜像上传至私有仓库"><a href="#镜像上传至私有仓库" class="headerlink" title="镜像上传至私有仓库"></a>镜像上传至私有仓库</h3><pre><code>（1）标记此镜像为私有仓库的镜像docker tag huangsm/jdk8 192.168.25.133:5000/jdk1.8（2）再次启动私服容器docker start huangsm_dockerresp（3）上传标记的镜像docker push 192.168.25.133:5000/jdk1.8</code></pre><p><img src="/2019/02/01/dockerfile的基本使用以及服务的部署/将镜像push到私人仓库.png" alt="将镜像push到私人仓库"></p><h2 id="DockerMaven插件"><a href="#DockerMaven插件" class="headerlink" title="DockerMaven插件"></a>DockerMaven插件</h2><pre><code>微服务部署有两种方法：（1）手动部署：首先基于源码打包生成jar包（或war包）,将jar包（或war包）上传至虚拟机并拷贝至JDK容器。（2）通过Maven插件自动部署。  对于数量众多的微服务，手动部署无疑是非常麻烦的做法，并且容易出错。所以我们这里学习如何自动部署，这也是企业实际开发中经常使用的方法Maven插件自动部署步骤:（1）修改宿主机的docker配置，让其可以远程访问vi /lib/systemd/system/docker.serviceExecStart=/usr/bin/dockerd-current -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock （2）刷新配置，重启服务    systemctl daemon‐reload    systemctl restart docker    docker start registry(3)在config配置中心工程pom.xml 增加配置插件 &lt;build&gt;    &lt;finalName&gt;app&lt;/finalName&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;        &lt;!-- docker的maven插件，官网：https://github.com/spotify/docker‐maven‐plugin --&gt;        &lt;plugin&gt;            &lt;groupId&gt;com.spotify&lt;/groupId&gt;            &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;0.4.13&lt;/version&gt;            &lt;configuration&gt;                &lt;imageName&gt;192.168.25.134:5000/${project.artifactId}:${project.version}&lt;/imageName&gt;                &lt;baseImage&gt;192.168.25.134:5000/jdk1.8&lt;/baseImage&gt;                &lt;entryPoint&gt;[&quot;java&quot;, &quot;-jar&quot;,&quot;/${project.build.finalName}.jar&quot;]&lt;/entryPoint&gt;                &lt;resources&gt;                    &lt;resource&gt;                        &lt;targetPath&gt;/&lt;/targetPath&gt;                        &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                        &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                    &lt;/resource&gt;                &lt;/resources&gt;                &lt;dockerHost&gt;http://192.168.25.134:2375&lt;/dockerHost&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;使用以上DockerMaven插件会自动创建Dockerfile(4) 使用mvn clean package docker:build -DpushImage</code></pre><p><img src="/2019/02/01/dockerfile的基本使用以及服务的部署/使用MavenDocker插件将镜像发布到私人仓库中.png" alt="dockerfile的基本使用以及服务的部署"></p><p><strong>根据图片就可以看出我已经将我开发的微服务push到私人仓库中了</strong>    </p>]]></content>
      
      
      <categories>
          
          <category> Dockerfile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DockerFile </tag>
            
            <tag> docker </tag>
            
            <tag> DockerMaven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloudConfig和SpringCloudBus实战应用</title>
      <link href="/2019/01/30/SpringCloudConfig%E5%92%8CSpringCloudBus%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
      <url>/2019/01/30/SpringCloudConfig%E5%92%8CSpringCloudBus%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="集中配置组件SpringCloudConfig"><a href="#集中配置组件SpringCloudConfig" class="headerlink" title="集中配置组件SpringCloudConfig"></a>集中配置组件SpringCloudConfig</h2><h3 id="Spring-Cloud-Config简介"><a href="#Spring-Cloud-Config简介" class="headerlink" title="Spring Cloud Config简介"></a>Spring Cloud Config简介</h3><pre><code>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中(即本地)，也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。Config Server是一个可横向扩展、集中式的配置服务器，它用于集中管理应用程序各个环境下的配置，默认使用Git存储配置文件内容，也可以使用SVN存储，或者是本地文件存储。Config Client是Config Server的客户端，用于操作存储在Config Server中的配置内容。微服务在启动时会请求Config Server获取配置文件的内容，请求到后再启动容器。</code></pre><blockquote><p>详细内容看在线文档： <a href="https://springcloud.cc/spring-cloud-config.html" target="_blank" rel="noopener">https://springcloud.cc/spring-cloud-config.html</a></p></blockquote><h3 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h3><ol><li>因为我们这里用的是Git仓库，所以我将我的配置文件放的我码云的仓库里</li></ol><p><img src="/2019/01/30/SpringCloudConfig和SpringCloudBus实战应用/码云配置文件.png" alt="码云配置文件"></p><ol start="2"><li><p>引入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>修改配置文件</p><pre><code>server:  port: 12000spring:  application:    name: tensquare-config  cloud:    config:      server:        git:          uri: https://gitee.com/wangyuanbaby/study-config.git</code></pre></li><li><p>在启动类添加@EnableConfigServer注解</p></li></ol><h3 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h3><ol><li>引入依赖</li></ol><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li><p>删除原来的配置文件，添加bootstrap.yml配置以下内容</p><pre><code>spring:  cloud:    config:      name: base      label: master      profile: dev      uri: http://127.0.0.1:12000  application:    name: base-dev</code></pre></li></ol><h2 id="消息总线组件SpringCloudBus"><a href="#消息总线组件SpringCloudBus" class="headerlink" title="消息总线组件SpringCloudBus"></a>消息总线组件SpringCloudBus</h2><h3 id="SpringCloudBus简介"><a href="#SpringCloudBus简介" class="headerlink" title="SpringCloudBus简介"></a>SpringCloudBus简介</h3><pre><code>如果我们更新码云中的配置文件，那客户端工程是否可以及时接受新的配置信息呢？我们现在来做有一个测试，修改一下码云中的配置文件中mysql的端口 ，然后测试http://localhost:9001/label 数据依然可以查询出来，证明修改服务器中的配置并没有更新立刻到工程，只有重新启动程序才会读取配置。 那我们如果想在不重启微服务的情况下更新配置如何来实现呢? 我们使用SpringCloudBus来实现配置的自动更新。</code></pre><h3 id="配置Config服务端"><a href="#配置Config服务端" class="headerlink" title="配置Config服务端"></a>配置Config服务端</h3><ol><li><p>引入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>修改配置文件</p><pre><code>server:  port: 12000spring:  application:    name: tensquare-config  cloud:    config:      server:        git:          uri: https://gitee.com/wangyuanbaby/study-config.git  rabbitmq:    host: 192.168.25.133management: #暴露触发消息总线的地址  endpoints:    web:      exposure:        include: bus-refresh</code></pre></li></ol><h3 id="配置Config客户端"><a href="#配置Config客户端" class="headerlink" title="配置Config客户端"></a>配置Config客户端</h3><p>1.　引入依赖</p><pre><code> &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>2.　在码云中修改对应服务配置文件</p><pre><code>rabbitmq:  host: 192.168.25.133cloud:  refresh:    refreshable: none　　#解决引入actuator时所造成的数据源死循环问题</code></pre><ol><li>修改码云上的配置文件 ，将数据库连接IP 改为127.0.0.1 ，在本地部署一份数据库。</li><li><p>postman测试 Url: <a href="http://127.0.0.1:12000/actuator/bus-refresh" target="_blank" rel="noopener">http://127.0.0.1:12000/actuator/bus-refresh</a> Method:post</p><p> <img src="/2019/01/30/SpringCloudConfig和SpringCloudBus实战应用/手动刷新配置.png" alt="手动刷新配置"></p></li><li><p>再次观察输出的数据是否是读取了本地的mysql数据。</p></li></ol><p><strong>如果需要通过BUS来动态获取配置文件中的自定义配置的话，需要在Controller上加@RefreshScope注解</strong></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><pre><code>我这里只是使用SpringCloudConfig和SpringConfigBus在实战中的应用，想要了解更加详细的应用和配置可以去阅读官方文档，相信你会收获颇深！</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> SpringCloudConfig </tag>
            
            <tag> SpringCloudBus </tag>
            
            <tag> 配置中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务网关zuul的概念与实战</title>
      <link href="/2019/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3zuul%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
      <url>/2019/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3zuul%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="微服务网关Zuul"><a href="#微服务网关Zuul" class="headerlink" title="微服务网关Zuul"></a>微服务网关Zuul</h1><h3 id="为什么需要微服务网关"><a href="#为什么需要微服务网关" class="headerlink" title="为什么需要微服务网关"></a>为什么需要微服务网关</h3><pre><code>不同的微服务一般有不同的网络地址，而外部的客户端可能需要调用多个服务的接口才能完成一个业务需求。比如一个电影购票的收集APP,可能回调用电影分类微服务，用户微服务，支付微服务等。如果客户端直接和微服务进行通信，会存在一下问题： 客户端会多次请求不同微服务，增加客户端的复杂性 存在跨域请求，在一定场景下处理相对复杂 认证复杂，每一个服务都需要独立认证 难以重构，随着项目的迭代，可能需要重新划分微服务，如果客户端直接和微服务通信，那么重构会难以实施 某些微服务可能使用了其他协议，直接访问有一定困难上述问题，都可以借助微服务网关解决。微服务网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过微服务网关。</code></pre><h3 id="什么是Zuul"><a href="#什么是Zuul" class="headerlink" title="什么是Zuul"></a>什么是Zuul</h3><pre><code>Zuul是Netflix开源的微服务网关，他可以和Eureka,Ribbon,Hystrix等组件配合使用。Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能： 身份认证和安全: 识别每一个资源的验证要求，并拒绝那些不符的请求审查与监控： 动态路由：动态将请求路由到不同后端集群 压力测试：逐渐增加指向集群的流量，以了解性能 负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求 静态响应处理：边缘位置进行响应，避免转发到内部集群 多区域弹性：跨域AWS Region进行请求路由，旨在实现ELB(ElasticLoad Balancing)使用多样化Spring Cloud对Zuul进行了整合和增强。使用Zuul后，架构图演变为以下形式</code></pre><p><img src="/2019/01/28/微服务网关zuul的概念与实战/Zuul图.png" alt="微服务网关zuul的概念与实战"></p><h3 id="Zuul路由转发"><a href="#Zuul路由转发" class="headerlink" title="Zuul路由转发"></a>Zuul路由转发</h3><ol><li>引入依赖</li></ol><pre><code> &lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li><p>修改application.yml文件</p><pre><code>server:  port: 9012spring:  application:    name: tensquare-managereureka:  client:    service-url:      defaultZone: http://localhost:9010/eureka/  instance:    prefer-ip-address: true    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}zuul:  routes:    tensquare-base: /base/**    tensquare-article: /article/**    tensquare-user: /user/**jwt:  config:    key: huangsmzhenshuaihystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 60000# 解决请求超时连接问题ribbon:  ConnectTimeout: 3000  ReadTimeout: 60000management:  endpoint:    health:      show-details: always  endpoints:    web:      exposure:        include: &quot;*&quot;</code></pre></li><li><p>在启动类添加@EnableZuulProxy</p></li></ol><h3 id="Zuul过滤器"><a href="#Zuul过滤器" class="headerlink" title="Zuul过滤器"></a>Zuul过滤器</h3><ol><li><p>Zuul过滤器快速体验</p><pre><code>创建一个简单的zuul过滤器:/** * Zuul过滤器 * @author huangsm */@Componentpublic class WebFilter extends ZuulFilter {    /**     * filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过     *         滤器类型，具体如下：     *         * pre ：可以在请求被路由之前调用     *         * route ：在路由请求时候被调用     *         * post ：在route和error过滤器之后被调用     *         * error ：处理请求时发生错误时被调用     *         filterOrder ：通过int值来定义过滤器的执行顺序     *         shouldFilter ：返回一个boolean类型来判断该过滤器是否要执行，所以通过此函数可     *         实现过滤器的开关。在上例中，我们直接返回true，所以该过滤器总是生效     *         run ：过滤器的具体逻辑。     */    @Override    public String filterType() {        //前置过滤器        return &quot;pre&quot;;    }    @Override    public int filterOrder() {        //优先级为0,数字越大，优先级越低        return 0;    }    @Override    public boolean shouldFilter() {        //是否执行该过滤器，此处为true，说明需要过滤        return true;    }    @Override    public Object run() throws ZuulException {        System.out.println(&quot;进过了Zuul过滤器!&quot;);        return null;    }}</code></pre></li></ol><pre><code>filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：* pre ：可以在请求被路由之前调用* route ：在路由请求时候被调用* post ：在route和error过滤器之后被调用* error ：处理请求时发生错误时被调用filterOrder ：通过int值来定义过滤器的执行顺序shouldFilter ：返回一个boolean类型来判断该过滤器是否要执行，所以通过此函数可实现过滤器的开关。在上例中，我们直接返回true，所以该过滤器总是生效run ：过滤器的具体逻辑。</code></pre><ol start="2"><li>网站前台的token转发</li></ol><pre><code>1.网关转发Token信息到下游服务@Overridepublic Object run() throws ZuulException {    System.out.println(&quot;进过了Zuul过滤器!&quot;);    //得到request上下文    RequestContext currentContext = RequestContext.getCurrentContext();    //得到request域    HttpServletRequest request = currentContext.getRequest();    //得到头信息    String authorization = request.getHeader(&quot;Authorization&quot;);    //判断是否有头信息    if (StringUtils.isNotBlank(authorization)) {        currentContext.addZuulRequestHeader(&quot;Authorization&quot;, authorization);    }    return null;}</code></pre><ol start="3"><li><p>管理后台过滤器实现token校验</p><pre><code>  @Overridepublic Object run() throws ZuulException {    RequestContext currentContext = RequestContext.getCurrentContext();    HttpServletRequest request = RequestContext.getCurrentContext().getRequest();    String authorization = request.getHeader(&quot;Authorization&quot;);    //第一次请求时，进过OPTIONS方法来分发路径，不会带有头信息    if (request.getMethod().equals(&quot;OPTIONS&quot;)){        return null;    }    //如果login存在这为登录请求，就放行    if (request.getRequestURI().indexOf(&quot;/admin/login&quot;)&gt;0){        System.out.println(&quot;登录页面&quot;+request.getRequestURI());        return null;    }    if (StringUtils.isNotBlank(authorization)) {        if (authorization.startsWith(&quot;Bearer &quot;)) {            String token = authorization.substring(7);            try {                Claims claims = jwtUtil.parseJWT(token);                String roles = (String) claims.get(&quot;roles&quot;);                if (roles.equals(&quot;admin&quot;)) {                    currentContext.addZuulRequestHeader(&quot;Authorization&quot;, authorization);                    return null;                }            } catch (Exception e) {                //终止运行                currentContext.setSendZuulResponse(false);                currentContext.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);                currentContext.setResponseBody(&quot;无权访问&quot;);            }        }    }    //终止运行    currentContext.setSendZuulResponse(false);    currentContext.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);    currentContext.setResponseBody(&quot;无权访问&quot;);    currentContext.getResponse().setContentType(&quot;text/html;charset=UTF-8&quot;);    return null;}</code></pre></li><li><p>解决CORS跨域请求问题</p><pre><code>/** * 解决cors跨域问题 * @author huangsm * @version V1.0 */@Configurationpublic class WebMvcConfigurer {    @Bean    public WebMvcConfigurer corsConfigurer() {        return new WebMvcConfigurer() {            public void addCorsMappings(CorsRegistry registry) {                registry.addMapping(&quot;/users/**&quot;)                        .allowedOrigins(&quot;http://huangsm.zyx.com&quot;)                        .allowedMethods(&quot;GET&quot;, &quot;POST&quot;);            }        };    }}</code></pre></li></ol><p><strong>关于更加详细的Zuul网关的使用，可以了解下我的码云上的代码</strong></p><p><a href="https://gitee.com/wangyuanbaby/microservice-springcloud/tree/master/microservice-gateway-zuul-filter/" target="_blank" rel="noopener">SpringCloud-Zuul</a></p>]]></content>
      
      
      <categories>
          
          <category> Zuul </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zuul </tag>
            
            <tag> 统一权限管理与Token转发 </tag>
            
            <tag> Zuul访问超时问题解决 </tag>
            
            <tag> 统一Cors跨域解决 </tag>
            
            <tag> Zuul过滤器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud的Hystrix断路器在服务中的应用</title>
      <link href="/2019/01/27/SpringCloud%E7%9A%84Hystrix%E6%96%AD%E8%B7%AF%E5%99%A8%E5%9C%A8%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2019/01/27/SpringCloud%E7%9A%84Hystrix%E6%96%AD%E8%B7%AF%E5%99%A8%E5%9C%A8%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="熔断器Hystrix"><a href="#熔断器Hystrix" class="headerlink" title="熔断器Hystrix"></a>熔断器Hystrix</h1><h3 id="为什么要使用熔断器"><a href="#为什么要使用熔断器" class="headerlink" title="为什么要使用熔断器"></a>为什么要使用熔断器</h3><blockquote><p>&nbsp;&nbsp;&nbsp;在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，<br>进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种<br>因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;如果下图所示：A作为服务提供者，B为A的服务消费者，C和D是B的服务消费者。A<br>不可用引起了B的不可用，并将不可用像滚雪球一样放大到C和D时，雪崩效应就形成<br>了。</p></blockquote><p><img src="/2019/01/27/SpringCloud的Hystrix断路器在服务中的应用/雪崩效应.png" alt="雪崩效应"></p><p>如何避免产生这种雪崩效应呢？我们可以使用Hystrix来实现熔断器。</p><h3 id="什么是Hystrix"><a href="#什么是Hystrix" class="headerlink" title="什么是Hystrix"></a>什么是Hystrix</h3><blockquote><p>Hystrix 能使你的系统在出现依赖服务失效的时候，通过隔离系统所依赖的服务，防止服务级联失败，同时提供失败回退机制，更优雅地应对失效，并使你的系统能更快地从异常中恢复。</p></blockquote><blockquote><p>了解熔断器模式请看下图:</p></blockquote><p><img src="/2019/01/27/SpringCloud的Hystrix断路器在服务中的应用/Hystirx.png" alt="Hystirx"></p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ol><li><p>Feign 本身支持Hystrix，不需要额外引入依赖。修改application.yml配置文件</p><pre><code>feign:  hystrix:    enabled: true</code></pre></li><li><p>创建BaseClient实现类</p><pre><code>@FeignClient(name = &quot;tensquare-base&quot;,fallback = BaseClientFallback.class,configuration = FallBackConfig.class)public interface BaseClient {    /**     * 调用base服务的根据ID查询文章接口     * @param labelId     * @return     */    @GetMapping(&quot;/label/{labelId}&quot;)    Result findById(@PathVariable(&quot;labelId&quot;) String labelId);}/** * 熔断器 * @author huangsm */@Componentpublic class BaseClientFallback implements BaseClient{    @Override    public Result findById(String labelId) {        return new Result(false, StatusCode.ERROR,&quot;服务崩溃了~&quot;);    }}</code></pre></li><li><p>创建配置类，监控feign客户端日志</p><pre><code>/** * feign配置类 * @author huangsm */public class FallBackConfig  {    /**     * 配置Feign的日志级别     * @return     */    @Bean    public Logger.Level feignLoggerLevel(){        return Logger.Level.FULL;    }}</code></pre></li><li><p>根据日志监听类</p><pre><code>logging:  level:    com.tensquare.qa.client.BaseClient: debug</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Hystrix </tag>
            
            <tag> Feign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud基本概念以及服务注册与服务调用</title>
      <link href="/2019/01/27/SpringCloud%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
      <url>/2019/01/27/SpringCloud%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud简介"><a href="#SpringCloud简介" class="headerlink" title="SpringCloud简介"></a>SpringCloud简介</h1><h3 id="什么是SpringCloud"><a href="#什么是SpringCloud" class="headerlink" title="什么是SpringCloud?"></a>什么是SpringCloud?</h3><blockquote><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如<br>服务发现注册、配置中心、消息总线、负载均衡、熔断器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p></blockquote><p>&nbsp;&nbsp;&nbsp;<a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="noopener">Spring Cloud项目的官方网址</a></p><h3 id="SpringCloud与SpringBoot的关系"><a href="#SpringCloud与SpringBoot的关系" class="headerlink" title="SpringCloud与SpringBoot的关系"></a>SpringCloud与SpringBoot的关系</h3><blockquote><p>&nbsp;&nbsp;&nbsp;Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单<br>个微服务，Spring Cloud是一个基于Spring Boot实现的云应用开发工具；Spring Boot专<br>注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架；<br>Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就<br>不配置，Spring Cloud很大的一部分是基于Spring Boot来实现，可以不基于Spring Boot<br>吗？不可以。</p></blockquote><blockquote><p>Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开<br>Spring Boot，属于依赖的关系。</p></blockquote><h3 id="Spring-Cloud和Dubbo对比"><a href="#Spring-Cloud和Dubbo对比" class="headerlink" title="Spring Cloud和Dubbo对比"></a>Spring Cloud和Dubbo对比</h3><blockquote><p>或许很多人会说Spring Cloud和Dubbo的对比有点不公平，Dubbo只是实现了服务治<br>理，而Spring Cloud下面有17个子项目（可能还会新增）分别覆盖了微服务架构下的方<br>方面面，服务治理只是其中的一个方面，一定程度来说，Dubbo只是Spring Cloud<br>Netflix中的一个子集。</p></blockquote><p><img src="/2019/01/27/SpringCloud基本概念以及服务注册与服务调用/SpringCloud和Dubbo的对比.png" alt="SpringCloud和Dubbo的对比"></p><p><strong>这里可以去了解下我以前一篇文章了解下RPC和HTTP直接的区别，也可以帮助你了解Dubbo和SC之间的区别</strong><br><a href="https://www.babywang.huangsm.xyz/2019/01/20/%E7%AE%80%E8%BF%B0HTTP%E5%92%8CRPC%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/">简述HTTP和RPC的优缺点</a></p><h1 id="服务发现组件-Eureka"><a href="#服务发现组件-Eureka" class="headerlink" title="服务发现组件 Eureka"></a>服务发现组件 Eureka</h1><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><pre><code>    Eureka是Netflix开发的服务发现框架，SpringCloud将它集成在自己的子项目spring-cloud-netflix中，实现SpringCloud的服务发现功能。Eureka包含两个组件：Eureka Server和Eureka Client。    Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。    Eureka Client是一个java客户端，用于简化与Eureka Server的交互，客户端同时也就别一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳,默认周期为30秒，如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移除(默认90秒)。    Eureka Server之间通过复制的方式完成数据的同步，Eureka还提供了客户端缓存机制，即使所有的Eureka Server都挂掉，客户端依然可以利用缓存中的信息消费其他服务的API。综上，Eureka通过心跳检查、客户端缓存等机制，确保了系统的高可用性、灵活性和可伸缩性。</code></pre><h3 id="Eureka服务端开发"><a href="#Eureka服务端开发" class="headerlink" title="Eureka服务端开发"></a>Eureka服务端开发</h3><ol><li>创建注册中心模块</li><li><p>引入依赖</p><pre><code>&lt;properties&gt;    &lt;spring-cloud.version&gt; Finchley.RELEASE&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;            &lt;version&gt;${spring-cloud.version}&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;</code></pre></li><li><p>添加application.yml配置</p><pre><code>server:  port: 9010spring:  application:    name: eureka-registereureka:  client:    service-url:      defaultZone: http://localhost:${server.port}/eureka/    register-with-eureka: false    fetch-registry: false</code></pre></li><li><p>在启动类加上@EnableEurekaServer</p></li></ol><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><ol><li><p>引入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>编写application.yml文件</p><pre><code>eureka:  client:    service-url:      defaultZone: http://localhost:9010/eureka/  instance:    prefer-ip-address: true    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}</code></pre></li></ol><p><img src="/2019/01/27/SpringCloud基本概念以及服务注册与服务调用/服务注册成功.png" alt="服务注册成功"><br><strong>注意F版本后，客户端无需在启动类加@EnableEurekaClient注解</strong></p><p>###　保护模式</p><pre><code>如果在Eureka Server的首页看到以下这段提示，则说明Eureka已经进入了保护模式：</code></pre><p><img src="/2019/01/27/SpringCloud基本概念以及服务注册与服务调用/eureka自我保护提示.png" alt="eureka自我保护提示">　</p><blockquote><p>&nbsp;&nbsp;&nbsp;Eureka Server在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%，如果出<br>现低于的情况（在单机调试的时候很容易满足，实际在生产环境上通常是由于网络不稳<br>定导致），Eureka Server会将当前的实例注册信息保护起来，同时提示这个警告。保护<br>模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保<br>护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的<br>数据（也就是不会注销任何微服务）。</p></blockquote><h1 id="Feign实现服务间的调用"><a href="#Feign实现服务间的调用" class="headerlink" title="Feign实现服务间的调用"></a>Feign实现服务间的调用</h1><h3 id="Feign简介"><a href="#Feign简介" class="headerlink" title="Feign简介"></a>Feign简介</h3><blockquote><p>&nbsp;&nbsp;&nbsp;Feign是简化Java HTTP客户端开发的工具（java-to-httpclient-binder），它的灵感<br>来自于Retrofit、JAXRS-2.0和WebSocket。Feign的初衷是降低统一绑定Denominator到<br>HTTP API的复杂度，不区分是否为restful.</p></blockquote><h3 id="通过Feign-实现问答服务调用基础服务"><a href="#通过Feign-实现问答服务调用基础服务" class="headerlink" title="(通过Feign)实现问答服务调用基础服务"></a>(通过Feign)实现问答服务调用基础服务</h3><ol><li><p>引入依赖</p><pre><code> &lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>在启动类添加@EnableFeignClients和@EnableDiscoveryClient</p></li><li>调用Base服务接口</li></ol><pre><code>/** * 通过Feign调用服务 * @author huangsm */@FeignClient(name = &quot;tensquare-base&quot;)public interface BaseClient {    /**     * 调用base服务的根据ID查询文章接口     * @param labelId     * @return     */    @GetMapping(&quot;/label/{labelId}&quot;)    Result findById(@PathVariable(&quot;labelId&quot;) String labelId);}</code></pre><ol start="4"><li>远程服务的使用</li></ol><pre><code>@Autowiredprivate BaseClient baseClient;@GetMapping(value = &quot;/label/{labelid}&quot;)public Result findLabelById(@PathVariable String labelid){    Result result = baseClient.findById(labelid);    return result;}</code></pre><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p><strong>因为Feign内集成了rabbion所以引入feign后服务带有负载均衡</strong></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Feign </tag>
            
            <tag> Dubbo </tag>
            
            <tag> Eureka </tag>
            
            <tag> rabbion </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于JWT的微服务鉴权开发实现</title>
      <link href="/2019/01/26/%E5%9F%BA%E4%BA%8EJWT%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%89%B4%E6%9D%83%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/01/26/%E5%9F%BA%E4%BA%8EJWT%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%89%B4%E6%9D%83%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="鉴权微服务开发"><a href="#鉴权微服务开发" class="headerlink" title="鉴权微服务开发"></a>鉴权微服务开发</h2><h3 id="JWT工具类编写"><a href="#JWT工具类编写" class="headerlink" title="JWT工具类编写"></a>JWT工具类编写</h3><pre><code>/** * JWT工具类 * @author huangsm */@ConfigurationProperties(&quot;jwt.config&quot;)public class JwtUtil {    private String key ;    /**     * 一个小时     */    private long ttl ;    public String getKey() {        return key;    }    public void setKey(String key) {        this.key = key;    }    public long getTtl() {        return ttl;    }    public void setTtl(long ttl) {        this.ttl = ttl;    }    /**     * 生成JWT     *     * @param id     * @param subject     * @return     */    public String createJWT(String id, String subject, String roles) {        long nowMillis = System.currentTimeMillis();        Date now = new Date(nowMillis);        JwtBuilder builder = Jwts.builder().setId(id)                .setSubject(subject)                .setIssuedAt(now)                .signWith(SignatureAlgorithm.HS256, key).claim(&quot;roles&quot;, roles);        if (ttl &gt; 0) {            builder.setExpiration( new Date( nowMillis + ttl));        }        return builder.compact();    }    /**     * 解析JWT     * @param jwtStr     * @return     */    public Claims parseJWT(String jwtStr){        return  Jwts.parser()                .setSigningKey(key)                .parseClaimsJws(jwtStr)                .getBody();    }}</code></pre><h3 id="管理员登陆后台签发token"><a href="#管理员登陆后台签发token" class="headerlink" title="管理员登陆后台签发token"></a>管理员登陆后台签发token</h3><p>１．　修改全局配置文件，配置token的盐和过期时间</p><pre><code>jwt:  config:    key: huangsmzhenshuai    ttl: 3600000</code></pre><ol start="2"><li><p>将Jwt工具类放入Spring容器</p><pre><code>@Beanpublic JwtUtil jwtUtil(){    return new JwtUtil();}</code></pre></li><li><p>管理员登录后台token签发</p><pre><code>1.控制层代码: @PostMapping(value = &quot;/login&quot;)public Result login(@RequestBody Admin admin) {    String token = adminService.login(admin.getLoginname(), admin.getPassword());    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;token&quot;, token);    map.put(&quot;roles&quot;, &quot;admin&quot;);    map.put(&quot;loginName&quot;, admin.getLoginname());    return new Result(true, StatusCode.OK, &quot;登录成功&quot;, map);} 2.服务层代码:@Autowiredprivate JwtUtil jwtUtil;public String login(String loginName,String password){    Admin sysAdmin = adminDao.findByLoginname(loginName);    if (sysAdmin==null){        throw new RuntimeException(&quot;用户名不存在!&quot;);    }    if (!bCryptPasswordEncoder.matches(password,sysAdmin.getPassword())){        throw new RuntimeException(&quot;密码错误!&quot;);    }    String token = jwtUtil.createJWT(loginName, password, &quot;admin&quot;);    return token;}</code></pre></li></ol><ol start="4"><li><p>管理员删除用户功能鉴权</p><pre><code>需求：删除用户，必须拥有管理员权限，否则不能删除前后端约定：前端请求微服务时需要添加头信息Authorization ,内容为Bearer+空格+token业务代码:   /**     * 删除必须有admin才可以删除     *     * @param id     */    public void deleteById(String id) {        String authorization = request.getHeader(&quot;Authorization&quot;);        if (StringUtils.isEmpty(authorization)){            throw new RuntimeException(&quot;权限不足!&quot;);        }        if (!authorization.startsWith(&quot;Bearer&quot;)){            throw new RuntimeException(&quot;权限不足!&quot;);        }        //得到token        String token = authorization.substring(7);        try {            Claims claims = jwtUtil.parseJWT(token);            if (!claims.get(&quot;roles&quot;).equals(&quot;admin&quot;)||claims.get(&quot;roles&quot;)==null){                throw new RuntimeException(&quot;权限不足!&quot;);            }        }catch (Exception e){            throw new RuntimeException(&quot;权限不足!&quot;);        }        userDao.deleteById(id);    }</code></pre></li><li><p>上述代码你会发现个问题，每次验证都需要写一大堆业务，代码过于重复，这里使用拦截器来完成鉴权</p></li></ol><pre><code>一、编写拦截器/** * 授权拦截器 * * @author huangsm */@Componentpublic class JwtInterceptor implements HandlerInterceptor {    /**     * Spring为我们提供了org.springframework.web.servlet.handler.HandlerInterceptorAdapter这个适配器，     * 继承此类，可以非常方便的实现自己的拦截器。     * 他有三个方法：分别实现预处理、后处理（调用了Service并返回ModelAndView，但未进行页面渲染）、返回处理（已经渲染了页面）     * 在preHandle中，可以进行编码、安全控制等处理；     * 在postHandle中，有机会修改ModelAndView；     * 在afterCompletion中，可以根据ex是否为null判断是否发生了异常，进行日志记     */    @Autowired    private JwtUtil jwtUtil;    /**     * 前置拦截器     *     * @param request     * @param response     * @param handler     * @return     * @throws Exception     */    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(&quot;经过了拦截器&quot;);        //无论如何都放下。具体能不能操作还是在具体操作中去判断        //拦截器只是负责把请求头中包含token的令牌进行解析验证。        final String authorization = request.getHeader(&quot;Authorization&quot;);        //如果包含有Authorization头信息，就对其进行判断        if (authorization != null &amp;&amp; authorization.startsWith(&quot;Bearer&quot;)) {            //得到token            final String token = authorization.substring(7);            try {                Claims claims = jwtUtil.parseJWT(token);                if (claims != null) {                    String roles = (String) claims.get(&quot;roles&quot;);                    //如果是管理员                    if (&quot;admin&quot;.equals(roles) &amp;&amp; roles != null) {                        request.setAttribute(&quot;admin_claims&quot;, claims);                    }                    //如果是用户                    if (&quot;user&quot;.equals(roles) &amp;&amp; roles != null) {                        request.setAttribute(&quot;user_claims&quot;, claims);                    }                }            } catch (Exception e) {                throw new RuntimeException(&quot;令牌有误!&quot;);            }        }        return true;    }}二、将拦截器加入到SpringMvc中/** * Web配置类 * * @author huangsm */@Configurationpublic class WebConfig extends WebMvcConfigurationSupport {    @Autowired    private JwtInterceptor jwtInterceptor;    /**     * 添加拦截器     * addPathPatterns拦截的路径     * excludePathPatterns不拦截的路径     * @param registry     */    @Override    public void addInterceptors(InterceptorRegistry registry) {        //注册拦截器要声明拦截器对象和要拦截的请求        registry.addInterceptor(jwtInterceptor)                .addPathPatterns(&quot;/**&quot;)                .excludePathPatterns(&quot;/**/login&quot;);    }}三、修改原有的删除用户逻辑    /**     * 删除必须有admin才可以删除     *     * @param id     */    public void deleteById(String id) {        Claims admin_claims = (Claims) request.getAttribute(&quot;admin_claims&quot;);        if (admin_claims == null) {            throw new RuntimeException(&quot;权限不足!&quot;);        }        userDao.deleteById(id);    }</code></pre><p><strong>这是是一个拦截器的简单使用，其实可以加上角色认证和aop注解栏控制那些请求不需要拦截</strong></p>]]></content>
      
      
      <categories>
          
          <category> JWT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> jwt </tag>
            
            <tag> 权限拦截器 </tag>
            
            <tag> 鉴权微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于JWT的Token认证机制以及实现</title>
      <link href="/2019/01/26/%E5%9F%BA%E4%BA%8EJWT%E7%9A%84Token%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/01/26/%E5%9F%BA%E4%BA%8EJWT%E7%9A%84Token%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前提要求"><a href="#前提要求" class="headerlink" title="前提要求"></a>前提要求</h1><p><strong>考虑到使用SpringSecurity的BCryptPasswordEncoder盐加密算法所以在服务中引入SpringSecurity</strong></p><ol><li>引入依赖</li></ol><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>我们在添加了spring security依赖后，所有的地址都被spring security所控制了，我们目前只是需要用到BCrypt密码加密的部分，所以我们要添加一个配置类，配置为所有地址都可以匿名访问</li></ol><pre><code>/** * 安全配置类 * @author huangsm */@EnableWebSecurity@Configurationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {    /**     * authorizeRequests所有security全注解配置实现的开端，表示开始说明需要的权限。     * 需要的权限分两部分，第一部分是拦截的路径，第二部分访问该路径需要的权限。     * antMatchers表示拦截什么路径，permitAll任何权限都可以访问，直接放行所有。     * anyRequest()任何的请求，authenticated认证后才能访问     * and().csrf().disable()；固定写法，标识csrf失效。     * @param http     * @throws Exception     */    @Override    protected void configure(HttpSecurity http) throws Exception {        http                .authorizeRequests()                .antMatchers(&quot;/**&quot;).permitAll()                .anyRequest().authenticated()                .and().csrf().disable();    }    /**     * 配置BCrypt强哈希方法 每次加密的结果都不一样     * @return     */    @Bean    public BCryptPasswordEncoder bCryptPasswordEncoder(){        return new BCryptPasswordEncoder();    }}</code></pre><h1 id="基于JWT的Token认证机制"><a href="#基于JWT的Token认证机制" class="headerlink" title="基于JWT的Token认证机制"></a>基于JWT的Token认证机制</h1><h3 id="关于有状态登录和无状态的登录"><a href="#关于有状态登录和无状态的登录" class="headerlink" title="关于有状态登录和无状态的登录"></a>关于有状态登录和无状态的登录</h3><ul><li>有状态登录: 服务器端需要存储用户信息</li><li>无状态登录: 服务器端不需要存储用户信息</li></ul><h3 id="常见的认证机制"><a href="#常见的认证机制" class="headerlink" title="常见的认证机制"></a>常见的认证机制</h3><ol><li>HTTP Basic Auth（无状态登录）</li></ol><pre><code>HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP BasicAuth</code></pre><ol start="2"><li><p>Cookie Auth</p><pre><code>Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效。</code></pre><p> <img src="/2019/01/26/基于JWT的Token认证机制以及实现/Cookie认证机制.png" alt="基于JWT的Token认证机制以及实现"></p></li><li><p>OAuth</p><pre><code>OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有</code></pre><p><strong>下面是OAuth2.0的流程:</strong></p></li></ol><p><img src="/2019/01/26/基于JWT的Token认证机制以及实现/OAuth认证机制.png" alt="OAuth认证机制"></p><pre><code>这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。</code></pre><ol start="4"><li><p>Token Auth</p><pre><code>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：1.客户端使用用户名跟密码请求登录2.服务端收到请求，去验证用户名与密码3.验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端4.客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里5.客户端每次向服务端请求资源的时候需要带着服务端签发的 Token6.服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</code></pre></li></ol><p><img src="/2019/01/26/基于JWT的Token认证机制以及实现/JwtToken.png" alt="JwtToken"></p><p><strong>Token Auth的优点:</strong></p><p>Token机制相对于Cookie机制又有什么好处呢？</p><ul><li>支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提<br>是传输的用户认证信息通过HTTP头传输.</li><li>无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为<br>Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储<br>状态信息.</li><li>更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，<br>HTML,图片等），而你的服务端只要提供API即可.</li><li>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在<br>你的API被调用的时候，你可以进行Token生成调用即可.<br>更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）<br>时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认<br>证机制就会简单得多。</li><li>CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防<br>范。</li><li>性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256<br>计算 的Token验证和解析要费时得多.</li><li>不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要<br>为登录页面做特殊处理.</li><li>基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在<br>多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：<br>Firebase,Google, Microsoft）.<h3 id="基于JWT的Token认证机制实现"><a href="#基于JWT的Token认证机制实现" class="headerlink" title="基于JWT的Token认证机制实现"></a>基于JWT的Token认证机制实现</h3></li></ul><ol><li><p>什么是JWT?</p><pre><code>JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息.</code></pre></li><li><p>JWT组成</p><pre><code>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。</code></pre></li></ol><p><strong>头部（Header）</strong></p><pre><code>    头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。{&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;}    在头部指明了签名算法是HS256算法。 我们进行BASE64编码http://base64.xpcha.com/，编码后的字符串如下：    eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1Ni</code></pre><blockquote><p>小知识：Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。JDK 中提供了非常方便的 BASE64Encoder 和 BASE64Decoder，用它们可以非常方便的完成基于 BASE64 的编码和解码</p></blockquote><p><strong>载荷（playload）</strong></p><pre><code>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分（1）标准中注册的声明（建议但不强制使用）    iss: jwt签发者    sub: jwt所面向的用户    aud: 接收jwt的一方    exp: jwt的过期时间，这个过期时间必须要大于签发时间    nbf: 定义在什么时间之前，该jwt都是不可用的.    iat: jwt的签发时间    jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。（2）公共的声明    公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.    但不建议添加敏感信息，因为该部分在客户端可解密.（3）私有的声明    私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64    是对称解密的，意味着该部分信息可以归类为明文信息。    这个指的就是自定义的claim。比如前面那个结构举例中的admin和name都属于自定的    claim。这些claim跟JWT标准规定的claim区别在于：JWT规定的claim，JWT的接收方在    拿到JWT之后，都知道怎么对这些标准的claim进行验证(还不知道是否能够验证)；而    private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行.</code></pre><p><em>定义一个payload:</em></p><pre><code>{&quot;sub&quot;:&quot;1234567890&quot;,&quot;name&quot;:&quot;John Doe&quot;,&quot;admin&quot;:true}</code></pre><p><em>然后将其进行base64编码，得到Jwt的第二部分。</em></p><pre><code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</code></pre><p><strong>签证（signature）</strong></p><p><em>jwt的第三部分是一个签证信息，这个签证信息由三部分组成</em></p><pre><code>    header (base64后的)    payload (base64后的)    secr这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ将这三部分用.连接成一个完整的字符串,构成了最终的jwt:</code></pre><blockquote><p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIi<br>wiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</p></blockquote><pre><code>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</code></pre><h3 id="Java的JJWT实现JWT"><a href="#Java的JJWT实现JWT" class="headerlink" title="Java的JJWT实现JWT"></a>Java的JJWT实现JWT</h3><ol><li><p>什么是JJWT？</p><pre><code>JJWT是一个提供端到端的JWT创建和验证的Java库。永远免费和开源(ApacheLicense，版本2.0)，JJWT很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。</code></pre></li><li><p>token的创建</p><pre><code>一、引入依赖&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;    &lt;version&gt;0.6.0&lt;/version&gt;&lt;/dependency&gt;二、创建类JwtTest，用于生成token/** * 测试生产Json Web Token */public class CreateJwt {    public static void main(String[] args) {        /**         * signWith实现签名算法和盐(huangsm是盐)         * setIssuedAt用于设置签发时间         * signWith用于设置签名秘钥         * setExpiration设置过期时间         */        //为了方便测试，我们将过期时间设置为1分钟        long now = System.currentTimeMillis();// 当前时间        long exp = now + 1000 * 60;//过期时间为1分钟        JwtBuilder jwtBuilder = Jwts.builder()                .setId(&quot;666&quot;)                .setSubject(&quot;你号&quot;)                .setIssuedAt(new Date())                .signWith(SignatureAlgorithm.HS256, &quot;huangsm&quot;)                .setExpiration(new Date(exp));        System.out.println(jwtBuilder.compact());    }}</code></pre></li></ol><ol start="3"><li>token的解析</li></ol><pre><code>我们刚才已经创建了token ，在web应用中这个操作是由服务端进行然后发给客户端，客户端在下次向服务端发送请求时需要携带这个token（这就好像是拿着一张门票一样），那服务端接到这个token 应该解析出token中的信息（例如用户id）,根据这些信息查询数据库返回相应的结果。解析类:/** * JWT解析 * * @author huangsm */public class ParseJwt {    public static void main(String[] args) {        String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI2NjYiLCJzdWIiOiLkvaDlj7ciLCJpYXQiOjE1NDg1MDI5NzZ9.-MhnLDDDmdsT6c8CX1qXA-kM2HneEgdxIrNH5_54Jn8&quot;;        Claims claims = Jwts.parser().setSigningKey(&quot;huangsm&quot;)                .parseClaimsJws(token).getBody();        System.out.println(&quot;用户ID:&quot;+claims.getId());        System.out.println(&quot;用户名称:&quot;+claims.getSubject());        System.out.println(&quot;登录时间:&quot;+claims.getIssuedAt());    }}</code></pre><p><em>试着将token或签名秘钥篡改一下，会发现运行时就会报错，所以解析token也就是验证token</em></p><ol start="4"><li>自定义claims</li></ol><blockquote><p>我们刚才的例子只是存储了id和subject两个信息，如果你想存储更多的信息（例如角<br>色）可以定义自定义claims </p></blockquote><pre><code>/** * 测试生产Json Web Token */public class CreateJwt {    public static void main(String[] args) {        /**         * signWith实现签名算法和盐(huangsm是盐)         * setIssuedAt用于设置签发时间         * signWith用于设置签名秘钥         * setExpiration设置过期时间         * claim自定义claim         */        //为了方便测试，我们将过期时间设置为1分钟        long now = System.currentTimeMillis();// 当前时间        long exp = now + 1000 * 60;//过期时间为1分钟        JwtBuilder jwtBuilder = Jwts.builder()                .setId(&quot;666&quot;)                .setSubject(&quot;你号&quot;)                .setIssuedAt(new Date())                .signWith(SignatureAlgorithm.HS256, &quot;huangsm&quot;)                .setExpiration(new Date(exp))                .claim(&quot;role&quot;,&quot;admin&quot;)                .claim(&quot;image&quot;,&quot;login.png&quot;);        System.out.println(jwtBuilder.compact());    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JWT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Json Web Token </tag>
            
            <tag> token </tag>
            
            <tag> JJWT </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> 认证机制 </tag>
            
            <tag> 无状态登录和有状态登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ在用户微服务开发中的实战</title>
      <link href="/2019/01/26/RabbitMQ%E5%9C%A8%E7%94%A8%E6%88%B7%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AE%9E%E6%88%98/"/>
      <url>/2019/01/26/RabbitMQ%E5%9C%A8%E7%94%A8%E6%88%B7%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h4 id="用户微服务开发"><a href="#用户微服务开发" class="headerlink" title="用户微服务开发"></a>用户微服务开发</h4><ol><li><p>发送短信验证码</p><pre><code>实现思路： 在用户微服务编写API ,生成手机验证码，存入Redis并发送到RabbitMQ一、准备工作（1）因为要用到缓存和消息队列，所以在用户微服务（tensquare_user）引入依赖redis和amqp的起步依赖。  &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;  &lt;/dependency&gt;（2）修改application.yml ,在spring 节点下添加配置    spring:      redis:        host: 192.168.25.133      rabbitmq:        host: 192.168.25.133二、代码实现（1）在UserService中新增方法，用于发送短信验证码     /**      * 发送短信验证码      *      * @param mobile 手机号      */    public void sendSms(String mobile) {        //1.生成6位短信验证码        String code = RandomStringUtils.randomNumeric(6);        System.out.println(mobile + &quot;收到验证码是:&quot; + code);        //2.将验证码放于redis(5分钟过期)        redisTemplate.opsForValue().set(&quot;smsCode_&quot; + mobile, code, 5, TimeUnit.MINUTES);        //3.将验证码和手机号发动到RabbitMQ中        Map&lt;String, String&gt; map = new HashMap&lt;&gt;(2);        map.put(&quot;mobile&quot;, mobile);        map.put(&quot;code&quot;, code);        rabbitTemplate.convertAndSend(&quot;sms&quot;, map);    }（2）UserController新增方法    @PostMapping(&quot;/sendSms/{mobile}&quot;)    public Result sendSms(@PathVariable(&quot;mobile&quot;) String mobile){        userService.sendSms(mobile);        return new Result(true,StatusCode.OK,&quot;发送成功&quot;);    }（3）启动微服务，在rabbitMQ中创建名为sms的队列，测试API三、用户注册服务开发  /**   * 用户注册   * @param user 用户信息   * @param code 验证码   */    @Transactional(rollbackFor = Exception.class)    public void  register(User user,String code){        String sysCode = (String) redisTemplate.opsForValue().get(&quot;smsCode_&quot; + user.getMobile());        if (StringUtils.isEmpty(sysCode)){            throw new RuntimeException(&quot;请点击获取验证码!&quot;);        }        if (StringUtils.isEmpty(code)){            throw new RuntimeException(&quot;请输入您收到的验证码!&quot;);        }        if (!sysCode.equals(code)){            throw new RuntimeException(&quot;验证码输入有误，请重新输入!&quot;);        }        user.setId(idWorker.nextId()+&quot;&quot;);        //关注数        user.setFollowcount(0);        //粉丝总数        user.setFanscount(0);        userDao.save(user);    }</code></pre><h4 id="短信微服务开发"><a href="#短信微服务开发" class="headerlink" title="短信微服务开发"></a>短信微服务开发</h4><p>开发短信发送微服务，从rabbitMQ中提取消息，调用阿里大于短信接口实现短信发送。<br><br>（我们这里实际做的就是消息的消费）</p></li><li><p>引入依赖</p><pre><code>&lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt;</code></pre></li><li><p>创建application.yml</p><pre><code>server:  port: 9009spring:  application:    name: tensquare-sms  rabbitmq:    host: 192.168.25.133</code></pre></li><li><p>创建消息监听器(消息消费者)</p><pre><code>/** * 发送短信监听类 * @author huangsm * @date 2019/1/26 17:08:36 */@Component@RabbitListener(queues = &quot;sms&quot;)public class SmsListener {    @RabbitHandler    public void sendSms(Map&lt;String,String&gt; map){        System.out.println(map);    }}</code></pre></li></ol><p><strong>这里RabbitMQ在短信服务中的应用就开发完成了，这里没有真的发送短信，如果发送短信可以调用第三方(如阿里大于等)</strong></p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 短信服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件RabbitMQ的使用以及基本概念</title>
      <link href="/2019/01/26/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/01/26/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h2><ol><li><p>消息队列中间件简介</p><pre><code>  消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用，可伸缩和最终一致性[架构]使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ以下介绍消息队列在实际应用中常用的使用场景：异步处理，应用解耦，流量削锋和消息通讯四个场景</code></pre><p><em>速度:kafka、rabbitmq、activemq</em><br><br><em>最安全的是:activemq</em></p></li><li><p>什么是RabbitMQ</p><pre><code>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：1.可靠性（Reliability）RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。2.灵活的路由（Flexible Routing）在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。3.消息集群（Clustering）多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。4.高可用（Highly Available Queues）队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。5.多种协议（Multi-protocol）RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。6.多语言客户端（Many Clients）RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。7.管理界面（Management UI）RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。8.跟踪机制（Tracing）如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。9.插件机制（Plugin System）RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件</code></pre></li><li><p>架构图与主要概念</p></li></ol><p><strong>RabbitMQ架构图</strong><br><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/RabbitMq架构图.png" alt="RabbitMq架构图"></p><p><strong>主要概念</strong></p><pre><code>RabbitMQ Server： 也叫broker server，它是一种传输服务。 他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。Producer： 消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服务器然后将消息投递到Exchange。Consumer：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列，RabbitMQ将Queue中的消息发送到消息消费者。Exchange：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。Exchange并不存储消息。RabbitMQ中的Exchange有direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。Queue：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并最终投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。RoutingKey：生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255bytesConnection： （连接）：Producer和Consumer都是通过TCP连接到RabbitMQ Server的。以后我们可以看到，程序的起始处就是建立这个TCP连接。Channels： （信道）：它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。VirtualHost：权限控制的基本单位，一个VirtualHost里面有若干Exchange和MessageQueue，以及指定被哪些user使用</code></pre><h2 id="RabbitMQ的使用"><a href="#RabbitMQ的使用" class="headerlink" title="RabbitMQ的使用"></a>RabbitMQ的使用</h2><ol><li><p>RabbitMQ安装与启动</p><p> <strong>一、windows环境下的安装</strong></p><pre><code>（1）下载并安装 Eralng配套软件中已提供otp_win64_20.2.exe （以管理员身份运行安装）（2）下载并安装rabbitmq配套软件中已提供rabbitmq-server-3.7.4.exe。双击安装，注意不要安装在包含    中文和空格的目录下！安装后window服务中就存在rabbitMQ了，并且是启动状态。（3）安装管理界面（插件）进入rabbitMQ安装目录的sbin目录，输入命令    rabbitmq‐plugins enable rabbitmq_management（4）重新启动服务（5）打开浏览器，地址栏输入http://127.0.0.1:15672 ,即可看到管理界面的登陆页</code></pre><p> <strong>二、docker容器中按照RabbitMQ</strong></p><pre><code>（1）拉去rabbitMQ镜像    docker pull rabbitmq:management（2）创建容器，rabbitmq需要有映射以下端口: 5671 5672 4369 15671 15672 25672    15672 (if management plugin is enabled)    15671 management监听端口    5672, 5671 (AMQP 0-9-1 without and with TLS)    4369 (epmd) epmd 代表 Erlang 端口映射守护进程    25672 (Erlang distribution)(3)启动容器:docker run -d --name=myrabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 15671:15671 -p 15672:15672 -p 25672:25672 d69a5113ceae</code></pre></li></ol><p><em>输入<a href="http://192.168.25.133:15672进入RabbitMQ登录页面" target="_blank" rel="noopener">http://192.168.25.133:15672进入RabbitMQ登录页面</a></em></p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/启动RabbitMq.png" alt="启动RabbitMq"><br></p><p><em>输入用户名和密码，都为guest 进入主界</em></p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/RabbitMq启动页面.png" alt="RabbitMq启动页面"><br></p><p><strong>最上侧的导航以此是：概览、连接、信道、交换器、队列、用户管理</strong></p><ol start="2"><li><p>直接模式(Direct)</p><pre><code>一、什么是Direct模式我们需要将消息发给唯一一个节点时使用这种模式，这是最简单的一种形式。任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。1.一般情况可以使用rabbitMQ自带的Exchange：&quot;&quot;(该Exchange的名字为空字符串，下文称其为default Exchange)。2.这种模式下不需要将Exchange进行任何绑定(binding)操作3.消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。4.如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。</code></pre></li></ol><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/直接模式Direct.png" alt="直接模式Direct"></p><pre><code>二、创建队列做下面的例子前，我们先建立一个叫myQue的队列Durability：是否做持久化 Durable（持久） transient（临时）Auto delete : 是否自动删除</code></pre><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/创建队列.png" alt="创建队列">    </p><pre><code>三、代码实现-消息生产者1.引入依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;2.编写配置文件application.ymlspring:  rabbitmq:    host: 192.168.25.1333.编写测试类@Autowiredprivate RabbitTemplate rabbitTemplate;@Testpublic void contextLoads() {    /**     * 第一个参数是队列名也就是routingKey     */    rabbitTemplate.convertAndSend(&quot;myQue&quot;,&quot;测试下直接模式(Direct)&quot;);}</code></pre><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/直接模式消息接收情况.png" alt="直接模式消息接收情况">    </p><pre><code>四、代码实现-消息消费者（1）编写消息消费者类@Component                            @RabbitListener(queues = &quot;myQue&quot;)public class Customer {    @RabbitHandler    public void showMessage(String msg){        System.out.println(&quot;myQue接收的消息:&quot;+msg);    }}    (2)运行启动类，可以在控制台看到刚才发送的消息</code></pre><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/消费者测试.png" alt="消费者测试"></p><p><strong>利用IDEA启用俩个消费者实例，在利用生产者发送消息，多次测试后发现俩个消费者实例收到消息的比例相同为1:1（负载均衡）</strong></p><ol start="2"><li><p>分列模式（Fanout）</p><pre><code>一、什么是分列（Fanout）模式当我们需要将消息一次发给多个队列时，需要使用这种模式。任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。1.可以理解为路由表的模式2.这种模式不需要RouteKey3.这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。4.如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。</code></pre></li></ol><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/分列模式图.png" alt="分列模式图"></p><p><strong>创建交换机</strong></p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/添加交换机.png" alt="添加交换机"></p><p><strong>绑定QUEUE</strong></p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/绑定Queue.png" alt="绑定Queue"></p><pre><code>二、代码实现---分列模式消息生产者     /**        *      * 分列模式(Fanout)      */    @Test    public void sendMsg2() {        /**         * 第一个参数是交换机名称，第二个队列名称是routingkey         */        rabbitTemplate.convertAndSend(&quot;huangsm&quot;,&quot;&quot;,&quot;测试分列模式(Fanout)&quot;);    }三、代码实现-分列模式消息消费者@Component@RabbitListener(queues = &quot;myQue2&quot;)public class Customer2 {    @RabbitHandler    public void showMessage(String msg){        System.out.println(&quot;myQue3接收的消息:&quot;+msg);    }}</code></pre><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/分列模式消息消费者.png" alt="分列模式消息消费者"></p><ol start="3"><li><p>主题模式（Topic）</p><pre><code>一、什么是主题模式任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上</code></pre></li></ol><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/topic模式.png" alt="topic模式">        </p><pre><code>由上图看出:此类交换器使得来自不同的源头的消息可以到达一个队列，其实说的更明白一点就是模糊匹配的意思，例如：上图中红色对列的routekey为usa.#，#代表匹配任意字符，但是要想消息能到达此对列，usa.必须匹配后面的#好可以随意。图中usa.newsusa.weather,都能找到红色队列，符号 # 匹配一个或多个词，符号 * 匹配不多不少一个词。因此 usa.# 能够匹配到 usa.news.XXX ，但是 usa.* 只会匹配到 usa.XXX 。注：交换器说到底是一个名称与队列绑定的列表。当消息发布到交换器时，实际上是由你所连接的信道，将消息路由键同交换器上绑定的列表进行比较，最后路由消息。任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上1.这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的队列。2.这种模式需要RouteKey，也许要提前绑定Exchange与Queue。3.在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。4.“#”表示0个或若干个关键字，“”表示一个关键字。如“log.”能与“log.warn”匹配，无法与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。5.同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息</code></pre><p><strong>创建队列与绑定</strong></p><p>（1）新建一个交换器 ，类型选择topic</p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/新建topic交换机.png" alt="新建topic交换机"></p><p>（2）点击新建的交换器topichuang,添加匹配规则，添加后列表如下：</p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/绑定routingkey.png" alt="绑定routingkey"></p><p><strong>消息生产者代码已经消费者测试结果</strong></p><pre><code>/** * 测试主题模式(topic)*/     @Test public void sendMsg3() {     /**      * 第一个参数是交换机名称，第二个队列名称是routingKey      */     rabbitTemplate.convertAndSend(&quot;topichuang&quot;,&quot;huang.aaa&quot;,&quot;aaa消息发送给谁呢&quot;); } /**  * 测试主题模式(topic)  */ @Test public void sendMsg4() {     /**      * 第一个参数是交换机名称，第二个队列名称是routingKey      */     rabbitTemplate.convertAndSend(&quot;topichuang&quot;,&quot;huang.log&quot;,&quot;huang.log消息发送给谁呢&quot;); } /**  * 测试主题模式(topic)  */ @Test public void sendMsg5() {     /**      * 第一个参数是交换机名称，第二个队列名称是routingKey      */     rabbitTemplate.convertAndSend(&quot;topichuang&quot;,&quot;log.ccc&quot;,&quot;ccc消息发送给谁呢&quot;); }</code></pre><p><em>Topic模式测试结果</em></p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/Topic模式测试结果.png" alt="Topic模式测试结果"></p><p><em>Topic模式流程图</em></p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/Rabbit主题模式.png" alt="Rabbit主题模式"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p><strong>这篇博客主要讲述RabbitMQ的一些概念和一些操作方式，下篇博客会介绍RabbitMQ的实战，开发一个用户微服务</strong></p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 主题模式Topic </tag>
            
            <tag> 直接模式Direct </tag>
            
            <tag> 分列模式（Fanout) </tag>
            
            <tag> AMQP </tag>
            
            <tag> Erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker下部署elasticsearch环境</title>
      <link href="/2019/01/25/docker%E4%B8%8B%E9%83%A8%E7%BD%B2elasticsearch%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/01/25/docker%E4%B8%8B%E9%83%A8%E7%BD%B2elasticsearch%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li>阿里云服务器</li><li>docker最新版环境</li></ol><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><h5 id="容器的创建与远程连接"><a href="#容器的创建与远程连接" class="headerlink" title="容器的创建与远程连接"></a>容器的创建与远程连接</h5><ul><li><p>下载镜像</p><pre><code>docker pull elasticsearch:5.6.8</code></pre></li><li><p>创建容器</p><pre><code>docker run -d --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; 6c0bdf761f3b</code></pre><p><strong>如果启动报错，通过docker logs es查看日志，如果错误是</strong></p><pre><code>Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x0000000085330000, 2060255232, 0) failed; error=’Cannot allocate memory’ (errno=12)</code></pre><p>因为这是由于elasticsearch5.0默认分配jvm空间大小为2g，内存不足以分配导致<br><strong>修改elasticsearch分配的jvm空间</strong></p><pre><code>find /var/lib/docker/overlay2/ -name jvm.optionsvim /var/lib/docker/overlay2/7f59cf980d035aa1f8e5275e4e64eb9ec9a775b0d62bacf94ee3d562b782c136/diff/etc/elasticsearch/jvm.options</code></pre><p><strong>最后重新启动即可</strong></p></li><li><p>测试</p><pre><code>输入http://192.168.25.133:9200/</code></pre><p><img src="/2019/01/25/docker下部署elasticsearch环境/es测试.png" alt="es测试"></p><pre><code>使用写好的搜索服务，改变elasticsearch服务器地址后启动测试报错:</code></pre><p><img src="/2019/01/25/docker下部署elasticsearch环境/es搜索服务启动报错.png" alt="es搜索服务启动报错"></p></li><li><p>进入容器</p><pre><code>一、输入命令docker exec es -it /bin/bash此时，我们看到elasticsearch所在的目录为/usr/share/elasticsearch,进入config看到了配置文件elasticsearch.yml我们通过vi命令编辑此文件，尴尬的是容器并没有vi命令 ，咋办？我们需要以文件挂载的方式创建容器才行，这样我们就可以通过修改宿主机中的某个文件来实现对容器内配置文件的修改二、拷贝配置文件到宿主机首先退出容器，然后执行命令： docker cp es:/usr/share/elasticsearch/config/elasticsearch.yml /usr/share/elasticsearch.yml三、停止和删除原来创建的容器docker stop esdocker rm es四、重新执行创建容器命令docker run -d --name=es -p 9200:9200 -p 9300:9300 -v /usr/share/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml elasticsearch:5.6.8五、修改/usr/share/elasticsearch.yml 将 transport.host: 0.0.0.0 前的#去掉后保存文件退出。其作用是允许任何ip地址访问elasticsearch开发测试阶段可以这么做，生产环境下指定具体的IP</code></pre><p><img src="/2019/01/25/docker下部署elasticsearch环境/解决docker容器中部署的跨域问题.png" alt="解决docker容器中部署的跨域问题"></p></li><li><p>重启启动</p><p>  docker restart es<br><strong>重新启动失败怎么办?</strong></p><pre><code>重启后发现重启启动失败了，这时什么原因呢？这与我们刚才修改的配置有关，因为elasticsearch在启动的时候会进行一些检查，比如最多打开的文件的个数以及虚拟内存区域数量等等，如果你放开了此配置，意味着需要打开更多的文件以及虚拟内存，所以我们还需要系统调优。</code></pre></li><li>系统调优(宿主机问题)</li></ul><p><em>我们一共需要修改两处</em></p><pre><code>第一步:修改/etc/security/limits.conf 配置文件,追加* soft nofile 65536* hard nofile 655nofile是单个进程允许打开的最大文件个数 soft nofile 是软限制 hard nofile是硬限制第二步:修改/etc/sysctl.conf，追加内容vm.max_map_count=655360限制一个进程可以拥有的VMA(虚拟内存区域)的数量执行下面命令 修改内核参数马上生效</code></pre><ul><li>安装IK分词器</li></ul><p>（1）快捷键alt+p进入sftp , 将ik文件夹上传至宿主机</p><pre><code>put -r  D:\friendprojec\elasticsearch-5.6.8\plugins\ik</code></pre><p>（2）在宿主机中将ik文件夹拷贝到容器内 /usr/share/elasticsearch/plugins 目录下。</p><pre><code>docker cp ik es:/usr/share/elasticsearch/plugins/</code></pre><p>（3）重启容器</p><ul><li>HEAD插件安装</li></ul><p>（1）修改/usr/share/elasticsearch.yml ,添加允许跨域配置</p><pre><code>http.cors.enabled: truehttp.cors.allow‐origin: &quot;*&quot;</code></pre><p>（2）重新启动elasticseach容器<br>（3）下载head镜像</p><pre><code>docker pull mobz/elasticsearch‐head:5</code></pre><p>（4）创建head容器</p><pre><code>docker run ‐di ‐‐name=myhead ‐p 9100:9100  mobz/elasticsearch‐head:5</code></pre><p><strong>这样我们在docker中部署elasticsearch就完成了</strong></p>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> head </tag>
            
            <tag> docker </tag>
            
            <tag> elasticsearch </tag>
            
            <tag> IK </tag>
            
            <tag> docker系统优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Logstash同步ElasticSearch与Mysql数据</title>
      <link href="/2019/01/24/%E4%BD%BF%E7%94%A8Logstash%E5%90%8C%E6%AD%A5ElasticSearch%E4%B8%8EMysql%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/01/24/%E4%BD%BF%E7%94%A8Logstash%E5%90%8C%E6%AD%A5ElasticSearch%E4%B8%8EMysql%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="ElasticSearch与MYSQL数据库的同步-使用logstash"><a href="#ElasticSearch与MYSQL数据库的同步-使用logstash" class="headerlink" title="ElasticSearch与MYSQL数据库的同步(使用logstash)"></a>ElasticSearch与MYSQL数据库的同步(使用logstash)</h3><ol><li><p>概述</p><pre><code>Logstash是一款轻量级的日志搜集处理框架，可以方便的把分散的、多样化的日志搜集起来，并进行自定义的理，然后传输到指定的位置，比如某个服务器或者文件。</code></pre></li><li><p>Logstash的安装和测试</p><pre><code>解压，进入bin目录logstash ‐e &apos;input { stdin { } } output { stdout {} }&apos;控制台输入字符，随后就有日志输出stdin，表示输入流，指从键盘输入stdout，表示输出流，指从显示器输出命令行参数:-e 执行--config 或 -f 配置文件，后跟参数类型可以是一个字符串的配置或全路径文件名或全路径(如：/etc/logstash.d/，logstash会自动读取/etc/logstash.d/目录下所有*.conf 的文本文件，然后在自己内存里拼接成一个完整的大配置文件再去执行)</code></pre><p><img src="/2019/01/24/使用Logstash同步ElasticSearch与Mysql数据/启动logstash.png" alt="日志输出"></p></li><li><p>MySQL数据导入Elasticsearch</p><pre><code>第一步:    在logstansh根目录下创建mysqletc(名称任意)目录，目录中创建mysql.conf（名字任意）文件，已经mysql的驱动jar包第二步: 编写mysql.conf文件input {  jdbc {      # mysql jdbc connection string to our backup databse      jdbc_connection_string =&gt; &quot;jdbc:mysql://47.107.44.169:33061/tensquare_article?characterEncoding=UTF8&quot;      # the user we wish to excute our statement as      jdbc_user =&gt; &quot;root&quot;      jdbc_password =&gt; &quot;123456&quot;      # the path to our downloaded jdbc driver        jdbc_driver_library =&gt; &quot;D:\friendprojec\logstash-5.6.8\mysqletc\mysql-connector-java-5.1.46.jar&quot;      # the name of the driver class for mysql      jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;      jdbc_paging_enabled =&gt; &quot;true&quot;      jdbc_page_size =&gt; &quot;50&quot;      #以下对应着要执行的sql的绝对路径。      #statement_filepath =&gt; &quot;&quot;      statement =&gt; &quot;SELECT  id,title,content,state FROM tb_article&quot;      #定时字段 各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为每分钟都更新（测试结果，不同的话请留言指出）      schedule =&gt; &quot;* * * * *&quot;  }}output {  elasticsearch {      #ESIP地址与端口      hosts =&gt; &quot;127.0.0.1:9200&quot;       #ES索引名称（自己定义的）      index =&gt; &quot;tensquare_article&quot;      #自增ID编号      document_id =&gt; &quot;%{id}&quot;      document_type =&gt; &quot;article&quot;  }  stdout {      #以JSON格式输出      codec =&gt; json_lines  }}第三步: 启动logstansh，用-f的方式logstash -f ../mysqletc/mysql.conf</code></pre><p><strong>注意mysql.conf路径为相对路径</strong><br><img src="/2019/01/24/使用Logstash同步ElasticSearch与Mysql数据/同步数据库成功.png" alt="同步数据库成功"><br><br></p><h3 id="logstansh一些注意的问题"><a href="#logstansh一些注意的问题" class="headerlink" title="logstansh一些注意的问题"></a>logstansh一些注意的问题</h3></li><li>logstansh支持多数据库同步ElasticSearch</li></ol><p><strong>这就是logstansh同步数据库的基础使用，也可以部署logstansh集群配合kafka或redis做到缓存同步效果</strong></p>]]></content>
      
      
      <categories>
          
          <category> Logstash </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> Logstash </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch基础入门及搜索服务的开发</title>
      <link href="/2019/01/23/ElasticSearch%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%8F%8A%E6%90%9C%E7%B4%A2%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%BC%80%E5%8F%91/"/>
      <url>/2019/01/23/ElasticSearch%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%8F%8A%E6%90%9C%E7%B4%A2%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h3 id="什么是ElasticSearch"><a href="#什么是ElasticSearch" class="headerlink" title="什么是ElasticSearch"></a>什么是ElasticSearch</h3><pre><code>Elasticsearch是一个实时的分布式搜索和分析引擎。它可以帮助你用前所未有的速度去处理大规模数据。ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</code></pre><h3 id="ElasticSearch特点"><a href="#ElasticSearch特点" class="headerlink" title="ElasticSearch特点"></a>ElasticSearch特点</h3><pre><code>（1）可以作为一个大型分布式集群（数百台服务器）技术，处理PB级数据，服务大公司；也可以运行在单机上（2）将全文检索、数据分析以及分布式技术，合并在了一起，才形成了独一无二的ES；（3）开箱即用的，部署简单（4）全文检索，同义词处理，相关度排名，复杂数据分析，海量数据的近实时</code></pre><h3 id="ElasticSearch体系结构"><a href="#ElasticSearch体系结构" class="headerlink" title="ElasticSearch体系结构"></a>ElasticSearch体系结构</h3><p><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/体系结构.png" alt="ElasticSearch体系结构"></p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h3 id="ElasticSearch部署与启动"><a href="#ElasticSearch部署与启动" class="headerlink" title="ElasticSearch部署与启动"></a>ElasticSearch部署与启动</h3><ol><li><p>下载ElasticSearch 5.6.8版本</p><pre><code>https://www.elastic.co/downloads/past-releases/elasticsearch-5-6-8</code></pre></li><li><p>在命令提示符下，进入ElasticSearch安装目录下的bin目录,执行命令即可启动。</p><pre><code>我们打开浏览器，在地址栏输入http://127.0.0.1:9200/ 即可看到输出结果</code></pre><p><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/ElasticSearch启动成功.png" alt="ElasticSearch启动成功"></p><h1 id="不同操作方式使用ElasticSearch"><a href="#不同操作方式使用ElasticSearch" class="headerlink" title="不同操作方式使用ElasticSearch"></a>不同操作方式使用ElasticSearch</h1><h3 id="通过PostMan使用RestFul风格操作ElasticSearch"><a href="#通过PostMan使用RestFul风格操作ElasticSearch" class="headerlink" title="通过PostMan使用RestFul风格操作ElasticSearch"></a>通过PostMan使用RestFul风格操作ElasticSearch</h3></li><li><p>新建索引库<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/Restful新建索引库.png" alt="Restful新建索引库"></p></li><li><p>新建文档<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/Restful新建文档.png" alt="Restful新建文档"></p></li><li>查询全部文档<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/Restful查询所有.png" alt="Restful查询所有"></li><li>修改文档<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/Restful修改文档.png" alt="Restful修改文档"><br><br><br><strong>如果ID不存在则重新创建</strong></li><li>按ID查询文档<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/RestFul根据ID查询.png" alt="RestFul根据ID查询"></li><li>基本匹配查询<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/RestFul基本查询.png" alt="RestFul基本查询"></li><li>模糊查询<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/Restful模糊查询.png" alt="Restful模糊查询"></li><li>删除文档<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/RestFul删除文档.png" alt="RestFul删除文档"><h3 id="Head插件方式操控ElasticSearch"><a href="#Head插件方式操控ElasticSearch" class="headerlink" title="Head插件方式操控ElasticSearch"></a>Head插件方式操控ElasticSearch</h3><h4 id="安装head"><a href="#安装head" class="headerlink" title="安装head"></a>安装head</h4></li><li><p>下载head插件</p><pre><code>https://github.com/mobz/elasticsearch-head</code></pre></li><li>解压到任意目录，但是要和elasticsearch的安装目录区别开</li><li><p>按照node js，按照cnpm</p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre></li><li><p>将grunt安装为全局命令 。Grunt是基于Node.js的项目构建工具。它可以自动运行你所设定的任务</p><pre><code>npm install ‐g grunt‐cli</code></pre></li><li><p>安装依赖</p><pre><code>cnpm install</code></pre></li><li><p>进入head目录启动head，在命令提示符下输入命令</p><pre><code>grunt server</code></pre></li><li>打开浏览器，输入 <a href="http://localhost:9100" target="_blank" rel="noopener">http://localhost:9100</a></li><li><p>点击连接按钮没有任何相应，按F12发现有如下错误</p><pre><code>No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resour这个错误是由于elasticsearch默认不允许跨域调用，而elasticsearch-head是属于前端工程，所以报错。我们这时需要修改elasticsearch的配置，让其允许跨域访问。修改elasticsearch配置文件：elasticsearch.yml，增加以下两句命令：http.cors.enabled: truehttp.cors.allow‐origin: &quot;*&quot;此步为允许elasticsearch跨越访问 点击连接即可看到相关信息</code></pre><p><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/head连接elasticSearch.png" alt="head连接elasticSearch"></p><h3 id="IK分词器的使用"><a href="#IK分词器的使用" class="headerlink" title="IK分词器的使用"></a>IK分词器的使用</h3></li><li><p>安装IK分词器<br>下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/releases</a> 下载5.6.8版<br>本 </p><pre><code>（1）先将其解压，将解压后的elasticsearch文件夹重命名文件夹为ik（2）将ik文件夹拷贝到elasticsearch/plugins 目录下。（3）重新启动，即可加载IK分词器</code></pre></li><li><p>IK分词器测试<br>IK提供了两个分词算法ik_smart 和 ik_max_word其中ik_smart为最少切分，ik_max_word为最细粒度划分<br>我们分别来试一下</p><pre><code>（1）最小切分：在浏览器地址栏输入地址http://127.0.0.1:9200/_analyze?analyzer=ik_smart&amp;pretty=true&amp;text=我是中国程序员输出的结果为：</code></pre><p><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/IK最小切分算法.png" alt="IK最小切分算法"></p><pre><code>（2）最细切分：在浏览器地址栏输入地址http://127.0.0.1:9200/_analyze?analyzer=ik_max_word&amp;pretty=true&amp;text=我是中国程序员输出结果为:</code></pre><p><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/IK最细切分算法.png" alt="IK最细切分算法"></p></li><li><p>IK自定义词库<br>步骤：</p><pre><code>（1）进入elasticsearch/plugins/ik/config目录（2）新建一个my.dic文件，编辑内容（3）修改IKAnalyzer.cfg.xml（在ik/config目录下）,然后重启elasticsearch服务</code></pre><p><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/IK自定义词库.png" alt="IK自定义词库"><br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/IK配置自定义词库.png" alt="IK配置自定义词库"><br><br><br><strong>注意my.dic文件需要存储为UTF-8无BOM格式</strong></p><h3 id="JAVA操作ElasticSearch"><a href="#JAVA操作ElasticSearch" class="headerlink" title="JAVA操作ElasticSearch"></a>JAVA操作ElasticSearch</h3></li><li>关于索引库文档类概念<ul><li>是否索引，就是看该域是否能被搜索</li><li>是否分词，就表示搜索的时候是整体匹配还是单词匹配，如果不分词的话代表整句匹配</li><li>是否存储，就是是否在页面上显示</li></ul></li><li><p>引入依赖和修改配置文件</p><pre><code> &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;修改配置文件:spring:  data:    elasticsearch:      cluster-nodes: localhost:9300</code></pre></li><li><p>创建索引文档类</p><pre><code>/** * SpringDataElasticSearch索引库文档类 * indexName 索引库名称 * type 数据库类型 * @author huangsm */@Document(indexName = &quot;tensquare_article&quot;,type = &quot;article&quot;)@Datapublic class Article implements Serializable {    @Id    private String id;    /**     * index 是否索引，就是看该域是否能被搜索     * 是否分词，就表示搜索的时候是整体匹配还是单词匹配，如果不分词的话代表整句匹配     * 是否存储，就是是否在页面上显示     */    @Field(index = true,    analyzer = &quot;ik_smart&quot;,searchAnalyzer = &quot;ik_smart&quot;)    private String title;    @Field(index = true,            analyzer = &quot;ik_smart&quot;,searchAnalyzer = &quot;ik_smart&quot;)    private String content;    /**     * 审核状态     */    private String state;}</code></pre></li><li>编写文章持久层</li></ol><pre><code>public interface ArticleSearchDao extends ElasticsearchRepository&lt;Article,String&gt; {    /**     * 检索     * @param title     * @param content     * @param pageable     * @return     */    public Page&lt;Article&gt;findByTitleOrContentLike(String title,                                                 String content, Pageable pageable);}</code></pre><ol start="5"><li>编写业务层</li></ol><pre><code>/** * 文章搜索业务 * @author huangsm */@Servicepublic class ArticleSearchService {    @Autowired    private ArticleSearchDao articleSearchDao;    @Autowired    private IdWorker idWorker;    /**     * 增加文章     * @param article     */    public void add(Article article){        article.setId(idWorker.nextId()+&quot;&quot;);        articleSearchDao.save(article);    }    public Page&lt;Article&gt;findByTitleLike(String keywords,int page,int size){        PageRequest pageRequest = PageRequest.of(page - 1, size);        return articleSearchDao.findByTitleOrContentLike(keywords,keywords,pageRequest);    }}</code></pre><ol start="6"><li>编写控制层</li></ol><pre><code>/** * 搜索controller * * @author huangsm */@RestController@CrossOrigin@RequestMapping(&quot;/article&quot;)public class ArticleController {    @Autowired    private ArticleSearchService articleSearchService;    @PostMapping(&quot;/&quot;)    public Result save(@RequestBody Article article) {        articleSearchService.add(article);        return new Result(true, StatusCode.OK, &quot;操作成功&quot;);    }    @GetMapping(value = &quot;/search/{keywords}/{page}/{size}&quot;)    public Result findByTitleLike(@PathVariable(&quot;keywords&quot;) String keywords,                                  @PathVariable(&quot;page&quot;) int page, @PathVariable(&quot;size&quot;) int size) {        Page&lt;Article&gt; pageData = articleSearchService.findByTitleLike(keywords, page, size);        return new Result(true, StatusCode.OK, &quot;查询成功&quot;, new PageResult&lt;Article&gt;(pageData.getTotalElements(), pageData.getContent()));    }}</code></pre><ol start="7"><li>测试<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/测试搜索.png" alt="测试搜索"></li></ol><h3 id="ElasticSearch和Solr的对比"><a href="#ElasticSearch和Solr的对比" class="headerlink" title="ElasticSearch和Solr的对比"></a>ElasticSearch和Solr的对比</h3><p><a href="https://www.cnblogs.com/chowmin/articles/4629220.html" target="_blank" rel="noopener">ES和Solr的对比</a></p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> head </tag>
            
            <tag> SpringData </tag>
            
            <tag> IK分词器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringDataMongoDB的基本使用及服务开发</title>
      <link href="/2019/01/23/SpringDataMongoDB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
      <url>/2019/01/23/SpringDataMongoDB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringDataMongoDb概述"><a href="#SpringDataMongoDb概述" class="headerlink" title="SpringDataMongoDb概述"></a>SpringDataMongoDb概述</h1><p> <em>SpringData家族成员之一，用于操作MongoDb的持久层框架，封装了底层的mongodb-driver</em></p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li>引入依赖</li></ol><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;  &lt;/dependency&gt;</code></pre><ol start="2"><li>配置application.yml配置文件</li></ol><pre><code>spring:  data:    mongodb:      host: ip地址      database: 数据库名称</code></pre><ol start="3"><li><p>通过IOC注入SpringDataMongoDB封装的模版</p><pre><code>在业务层注入：   @Autowiredprivate MongoTemplate mongoTemplate;//根据id，修改huangsm表下的num字段，每次加1，代码如下Query query = new Query();query.addCriteria(Criteria.where(&quot;_id&quot;).is(id));Update update = new Update();update.inc(&quot;num&quot;, 1);mongoTemplate.updateFirst(query, update, &quot;huangsm&quot;);</code></pre></li></ol><h2 id="关于服务开发"><a href="#关于服务开发" class="headerlink" title="关于服务开发"></a>关于服务开发</h2><p><strong>首先引入依赖，配置配置文件，然后引入MongoDB模版，剩余操作参考根据业务来选择SpringDataMongoDB提供的API来完成业务。本文只是一个简单的入门，更为详细建议参考官方文档，其实笔者认为MongoDB主要使用与数据价值低而且数据量大的场景，掌握常用的CURD就可以玩转Java中MongoDB的使用了，SpringDataMongoDb是个不错的操作MongoDb的框架，推荐。</strong></p>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringData </tag>
            
            <tag> MongoDB </tag>
            
            <tag> NOSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简述HTTP和RPC的优缺点</title>
      <link href="/2019/01/20/%E7%AE%80%E8%BF%B0HTTP%E5%92%8CRPC%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
      <url>/2019/01/20/%E7%AE%80%E8%BF%B0HTTP%E5%92%8CRPC%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p><em>在HTTP和RPC的选择上，可能有些人是迷惑的，主要是因为，有些RPC框架配置复杂，如果走HTTP也能完成同样的功能，那么为什么要选择RPC，而不是更容易上手的HTTP来实现了。</em></p><p><strong>本文主要来阐述HTTP和RPC的异同，让大家更容易根据自己的实际情况选择更适合的方案。</strong></p><ul><li><p>传输协议</p><pre><code>RPC，可以基于TCP协议，也可以基于HTTP协议HTTP，基于HTTP协议</code></pre></li><li><p>传输效率</p><pre><code>RPC，使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率HTTP，如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理</code></pre></li><li><p>性能消耗，主要在于序列化和反序列化的耗时</p><pre><code>RPC，可以基于thrift实现高效的二进制传输HTTP，大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能</code></pre></li><li><p>负载均衡</p><pre><code>RPC，基本都自带了负载均衡策略HTTP，需要配置Nginx，HAProxy来实现</code></pre></li><li><p>服务治理（下游服务新增，重启，下线时如何不影响上游调用者）</p><pre><code>RPC，能做到自动通知，不影响上游HTTP，需要事先通知，修改Nginx/HAProxy配置</code></pre></li></ul><p>总结：</p><p>  RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。</p><ul><li>博客地址: <a href="https://www.babywang.huangsm.xyz">https://www.babywang.huangsm.xyz</a></li><li>Git地址: <a href="https://github.com/babybabywang" target="_blank" rel="noopener">https://github.com/babybabywang</a></li><li>码云地址: <a href="https://gitee.com/wangyuanbaby" target="_blank" rel="noopener">https://gitee.com/wangyuanbaby</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务发现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Dubbo </tag>
            
            <tag> HTTP </tag>
            
            <tag> RPC </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB的基本使用姿势及概念</title>
      <link href="/2019/01/20/MongoDB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%8F%8A%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/01/20/MongoDB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%8F%8A%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="文档型数据库MongoDB"><a href="#文档型数据库MongoDB" class="headerlink" title="文档型数据库MongoDB"></a>文档型数据库MongoDB</h1><h2 id="MongoDB的特点和体系结构"><a href="#MongoDB的特点和体系结构" class="headerlink" title="MongoDB的特点和体系结构"></a>MongoDB的特点和体系结构</h2><h4 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h4><pre><code>1. 什么是mongodb  mongodb 是一个跨平台的,面向文档的数据库,是当前 nosql 数据库产品中最热门的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富,最像关系数据库的产品。它支持的数据结构非常松散，是类似 json的 bson 格式，因此可以存储比较复杂的数据类型。mongodb 的官方网站地址是:http://www.mongodb.org2. mongodb特点  mongodb 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。它是一个面向集合的,模式自由的文档型数据库。具体特点总结如下:（1）面向集合存储,易于存储对象类型的数据（2）模式自由（3）支持动态查询（4）支持完全索引,包含内部对象（5）支持复制和故障恢复（6）使用高效的二进制数据存储，包括大型对象（如视频等）（7）自动处理碎片,以支持云计算层次的扩展性（8）支持python,php,ruby,java,c,c#,javascript，perl及c++语言的驱动程序,社区中也提供了对erlang及.net等平台的驱动程序（9） 文件存储格式为 bson（一种 json 的扩展）3. 什么时候使用mongodb（1）数据量大（2）写入操作频繁（3）价值较低对于这样的数据，我们更适合使用mongodb来实现数据的4. mongodb体系结构mongodb 的逻辑结构是一种层次结构。主要由：文档(document)、集合(collection)、数据库(database)这三部分组成的。逻辑结构是面向用户的，用户使用 mongodb 开发应用程序使用的就是逻辑结构。（1）mongodb 的文档（document），相当于关系数据库中的一行记录。（2）多个文档组成一个集合（collection），相当于关系数据库的表。（3）多个集合（collection），逻辑上组织在一起，就是数据库（database）。（4）一个 mongodb 实例支持多个数据库（database）。5. 数据类型基本数据类型null：用于表示空值或者不存在的字段，{“x”:null}布尔型：布尔类型有两个值true和false，{“x”:true}数值：shell默认使用64为浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用numberint（4字节符号整数）或numberlong（8字节符号整数），{“x”:numberint(“3”)}{“x”:numberlong(“3”)}字符串：utf-8字符串都可以表示为字符串类型的数据，{“x”：“呵呵”}日期：日期被存储为自新纪元依赖经过的毫秒数，不存储时区，{“x”:new date()}正则表达式：查询时，使用正则表达式作为限定条件，语法与javascript的正则表达式相同，{“x”:/[abc]/}数组：数据列表或数据集可以表示为数组，{“x”： [“a“，“b”,”c”]}内嵌文档：文档可以嵌套其他文档，被嵌套的文档作为值来处理，{“x”:{“y”:3 }}对象id：对象id是一个12字节的字符串，是文档的唯一标识，{“x”: objectid() }二进制数据：二进制数据是一个任意字节的字符串。它不能直接在shell中使用。如果要将非utf-字符保存到数据库中，二进制数据是唯一的方式。代码：查询和文档中可以包括任何javascript代码</code></pre><p><strong>Mysql和MongoDB的区别:</strong></p><p><img src="/2019/01/20/MongoDB的基本使用姿势及概念/mongodb和mysql对比.png" alt="命令1"></p><h2 id="常用的MongoDB命令"><a href="#常用的MongoDB命令" class="headerlink" title="常用的MongoDB命令"></a>常用的MongoDB命令</h2><ol><li><p>首先说下Windows端mongodb的启动</p><ol><li>md e:/data</li><li>mongod –dbpath=e:/data</li><li>在b端cmd中输入 mongo即可启动</li></ol></li><li><p>docker中安装mongoDB</p><ol><li>拉取镜像<br>docker pull mongo</li><li>启动容器<br>docker run -d –name mymongodb -p 27017:27017 mongo</li></ol></li><li><p>常用的MongoDB命令</p></li></ol><p><img src="/2019/01/20/MongoDB的基本使用姿势及概念/ml1.png" alt="命令1"></p><p><img src="/2019/01/20/MongoDB的基本使用姿势及概念/ml2.png" alt="命令2"></p><p><img src="/2019/01/20/MongoDB的基本使用姿势及概念/ml3.png" alt="命令3"></p><p><img src="/2019/01/20/MongoDB的基本使用姿势及概念/ml4.png" alt="命令4"></p><p><img src="/2019/01/20/MongoDB的基本使用姿势及概念/ml5.png" alt="命令5"></p><h2 id="使用JAVA操作MongoDB"><a href="#使用JAVA操作MongoDB" class="headerlink" title="使用JAVA操作MongoDB"></a>使用JAVA操作MongoDB</h2><p><em>mongodb-driver是mongo官方推出的java连接mongoDB的驱动包，相当于JDBC驱动。我们通过一个入门的案例来了解mongodb-driver的基本</em></p><ol><li><p>引入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.mongodb&lt;/groupId&gt;    &lt;artifactId&gt;mongodb‐driver&lt;artifactId&gt;    &lt;version&gt;3.6.3&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>测试</p><pre><code>1. 查询全部数据/** * 测试Java操作mongoDb * @author huangsm */public class MongoDbDemo {    /**     * 查询mongodb中全部数据     * @param args     */    public static void main(String[] args) {        //创建连接        MongoClient mongoClient = new MongoClient(&quot;47.107.44.169&quot;);        //打开数据库        MongoDatabase spitdb = mongoClient.getDatabase(&quot;spitdb&quot;);        //获取集合        MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;);        //查询记录获取文档集合        FindIterable&lt;Document&gt; documents = spit.find();        for (Document document : documents) {            System.out.println(&quot;内容:&quot;+document.getString(&quot;content&quot;));            System.out.println(&quot;访客:&quot;+document.getInteger(&quot;visits&quot;));        }        mongoClient.close();    }}2. 条件查询/** * 测试条件查询 * @author huangsm */public class MongoDbDemo1 {    /**     * 根据条件查询     * BasicDBObject对象：表示一个具体的记录，BasicDBObject实现了DBObject，是keyvalue的数据结构，用起来和HashMap是基本一致的。     * @param args     */    public static void main(String[] args) {        //创建连接        MongoClient mongoClient = new MongoClient(&quot;47.107.44.169&quot;);        //打开数据库        MongoDatabase spitdb = mongoClient.getDatabase(&quot;spitdb&quot;);        //获取集合        MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;);        BasicDBObject basicDBObject=new BasicDBObject(&quot;_id&quot;,&quot;ObjectId(\&quot;5c446ba292035401c76895f0\&quot;)&quot;);        //查询记录获取文档集合        FindIterable&lt;Document&gt; documents = spit.find();        for (Document document : documents) {            System.out.println(&quot;id:&quot;+document.getObjectId(&quot;_id&quot;));            System.out.println(&quot;内容:&quot;+document.getString(&quot;content&quot;));            System.out.println(&quot;访客:&quot;+document.getInteger(&quot;visits&quot;));        }        mongoClient.close();    }}3. 插入数据/** * 插入数据 * @author huangsm */public class MongoDbDemo2 {    /**     * 插入数据     * @param args     */    public static void main(String[] args) {        //创建连接        MongoClient mongoClient = new MongoClient(&quot;47.107.44.169&quot;);        //打开数据库        MongoDatabase spitdb = mongoClient.getDatabase(&quot;spitdb&quot;);        //获取集合        MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;);        HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(&quot;content&quot;,&quot;git&quot;);        map.put(&quot;userId&quot;,&quot;222&quot;);        map.put(&quot;visits&quot;,123);        Document document = new Document(map);        spit.insertOne(document);        mongoClient.close();    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li></ol><p><strong>总的来说MongoDB是一款非关系性的文档数据库，它适合存储那种存储价值低而且数据量大的数据。总的来说操作起来也是否的便捷，下篇文章我会使用SpringDataMongoDB来开发一个微服务。</strong></p>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> JAVA操作 </tag>
            
            <tag> NOSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于吞吐量(TPS)、QPS、并发数、响应时间(RT)的概念</title>
      <link href="/2019/01/19/%E5%85%B3%E4%BA%8E%E5%90%9E%E5%90%90%E9%87%8F-TPS-%E3%80%81QPS%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4-RT-%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/01/19/%E5%85%B3%E4%BA%8E%E5%90%9E%E5%90%90%E9%87%8F-TPS-%E3%80%81QPS%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4-RT-%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><pre><code>因为开发的原因，需要对吞吐量（TPS）、QPS、并发数、响应时间（RT）几个概念做下了解，查自百度百科，记录如下：</code></pre><h3 id="1-响应时间-RT"><a href="#1-响应时间-RT" class="headerlink" title="1.响应时间(RT)"></a>1.响应时间(RT)</h3><p><br></p><blockquote><p>   <em>响应时间是指系统对请求作出响应的时间。</em>直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时<br>间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间&gt;也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论&gt;其平均响应时间和最大响应时间。</p></blockquote><pre><code>对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个游戏软件来说，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。 </code></pre><h3 id="2-吞吐量-TPS"><a href="#2-吞吐量-TPS" class="headerlink" title="2.吞吐量(TPS)"></a>2.吞吐量(TPS)</h3><blockquote><p><strong>吞吐量是指系统在单位时间内处理请求的数量。</strong>对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间（或者系统响应时间和应用延迟时间）可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。 </p></blockquote><h3 id="3-并发数"><a href="#3-并发数" class="headerlink" title="3.并发数"></a>3.并发数</h3><blockquote><p><strong>并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。</strong>与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。实际上，并发用户数是一个非常不准确的指标，因为用户不同的使用模式会导致不同用户在单位时间发出不同数量的请求。一网站系统为例，假设用户只有注册后才能使用，但注册用户并不是每时每刻都在使用该网站，因此具体一个时刻只有部分注册用户同时在线，在线用户就在浏览网站时会花很多时间阅读网站上的信息，因而具体一个时刻只有部分在线用户同时向系统发出请求。这样，对于网站系统我们会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数。由于注册用户可能长时间不登陆网站，使用注册用户数作为性能指标会造成很大的误差。而在线用户数和同事发请求用户数都可以作为性能指标。相比而言，以在线用户作为性能指标更直观些，而以同时发请求用户数作为性能指标更准确些。 </p></blockquote><h3 id="4-QPS每秒查询率-Query-Per-Second"><a href="#4-QPS每秒查询率-Query-Per-Second" class="headerlink" title="4.QPS每秒查询率(Query Per Second)"></a>4.QPS每秒查询率(Query Per Second)</h3><p>　&gt;每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 （看来是类似于TPS，只是应用于特定场景的吞吐量）</p>]]></content>
      
      
      <categories>
          
          <category> 系统概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统概述 </tag>
            
            <tag> 概念分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RateLimiter配合注解的使用</title>
      <link href="/2019/01/19/RateLimiter%E9%85%8D%E5%90%88%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/01/19/RateLimiter%E9%85%8D%E5%90%88%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="首先我们来了解下什么是RateLimiter"><a href="#首先我们来了解下什么是RateLimiter" class="headerlink" title="首先我们来了解下什么是RateLimiter"></a>首先我们来了解下什么是RateLimiter</h1><blockquote><p>RateLimiter 从概念上来讲，速率限制器会在可配置的速率下分配许可证。如果必要的话，每个acquire() 会阻塞当前线程直到许可证可用后获<br>取该许可证。一旦获取到许可证，不需要再释放许可证。<br><br><br><em>校对注：RateLimiter使用的是一种叫令牌桶的流控算法，RateLimiter会按照一定的频率往桶里扔令牌，线程拿到令牌才能执行，比如你希望自己的应用程序QPS不要超过1000，那么RateLimiter设置1000的速率后，就会每秒往桶里扔1000个令牌。</em><br><br><br><img src="/2019/01/19/RateLimiter配合注解的使用/令牌桶算法.png" alt="令牌桶算法"><br><br><br>    RateLimiter经常用于限制对一些物理资源或者逻辑资源的访问速率。与Semaphore 相比，Semaphore 限制了并发访问的数量而不是使用速率。（注意尽管并发性和速率是紧密相关的，比如参考Little定律）</p></blockquote><blockquote><p>通过设置许可证的速率来定义RateLimiter。在默认配置下，许可证会在固定的速率下被分配，速率单位是每秒多少个许可证。为了确保维护配<br>置的速率，许可会被平稳地分配，许可之间的延迟会做调整。<br>可能存在配置一个拥有预热期的RateLimiter 的情况，在这段时间内，每秒分配的许可数会稳定地增长直到达到稳定的速率。<br>举例来说明如何使用RateLimiter，想象下我们需要处理一个任务列表，但我们不希望每秒的任务提交超过两个：</p></blockquote><pre><code>//速率是每秒两个许可final RateLimiter rateLimiter = RateLimiter.create(2.0);void submitTasks(List tasks, Executor executor) {    for (Runnable task : tasks) {        rateLimiter.acquire(); // 也许需要等待        executor.execute(task);   }}</code></pre><h1 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h1><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><p>引入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;    &lt;version&gt;25.1-jre&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.28&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>创建自定义注解</p><pre><code>import java.lang.annotation.*;/** * 自定义RateLimiter限流注解 * @author huang * @PACKAGE_NAME cn.huangsm.advance.ratelimiter * @PROJECT_NAME advance-code * @date 2019/1/19 */@Inherited@Documented@Target({ElementType.METHOD,ElementType.FIELD,ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)public @interface RateLimitAspect {}</code></pre></li><li><p>自定义切面类解析自定义注解</p></li></ol><pre><code>import com.alibaba.fastjson.JSON;import com.google.common.util.concurrent.RateLimiter;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 自定义切面类解析注解 * * @author huang * @PACKAGE_NAME cn.huangsm.advance.ratelimiter.aop * @PROJECT_NAME advance-code * @date 2019/1/19 */@Component@Aspect@Scope@Slf4jpublic class RateLimitAop {    @Autowired    private HttpServletResponse response;    /**     * 需要处理一个任务列表，但我们不希望每秒的任务提交超过五个     */    private RateLimiter rateLimiter = RateLimiter.create(5.0);    @Pointcut(&quot;@annotation(cn.huangsm.advance.ratelimiter.RateLimitAspect)&quot;)    public void rateLimiterPointCut() {    }    ;    @Around(&quot;rateLimiterPointCut()&quot;)    public Object around(ProceedingJoinPoint joinPoint) {        /**         * 得到令牌         */        Boolean flag = rateLimiter.tryAcquire();        Object obj = null;        try {            if (flag) {                obj = joinPoint.proceed();                log.info(&quot;得到令牌!&quot;);            } else {                String result = JSON.toJSONString(&quot;抱歉，操作过于频繁，请稍等片刻在操作！&quot;);                log.info(&quot;未获得令牌!&quot;);                output(response, result);            }        } catch (Throwable e) {            e.printStackTrace();        }        System.out.println(&quot;是否得到令牌=&quot; + flag + &quot;,参数=&quot; + obj);        return obj;    }    public void output(HttpServletResponse response, String msg) throws IOException {        response.setContentType(&quot;application/json;charset=UTF-8&quot;);        ServletOutputStream outputStream = null;        try {            outputStream = response.getOutputStream();            outputStream.write(msg.getBytes(&quot;UTF-8&quot;));        } catch (IOException e) {            e.printStackTrace();        } finally {            outputStream.flush();            outputStream.close();        }    }}</code></pre><ol start="4"><li>测试Controller类</li></ol><pre><code>/** * 限流测试 * @author huang * @PACKAGE_NAME cn.huangsm.advance.ratelimiter * @PROJECT_NAME advance-code * @date 2019/1/19 */@RestControllerpublic class TestController {    @RateLimitAspect    @GetMapping(&quot;/test&quot;)    public String test(){        return &quot;nihao&quot;;    }}    </code></pre><h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><blockquote><p>上文中的编码阶段算是结束了，总体来说就是自定义一个限流注解方便以后每次的使用，其实我这里做的还不够细致，如果可以的话可以自定义速率，本例中默认速率为5.0表示：想象下我们需要处理一个任务列表，但我们不希望每秒的任务提交超过五个。</p></blockquote><p><strong>话不多说开始测试</strong><br>首先打开JMeter并发测试工具类，定义好线程组，以及Http请求和结果树，在线程组和HTTP请求中输入必要的参数<br><em>JMeter线程组参数</em><br><br><br><img src="/2019/01/19/RateLimiter配合注解的使用/JMeter线程组参数.jpg" alt="线程组参数"><br><em>HTTP请求参数</em><br><br><br><img src="/2019/01/19/RateLimiter配合注解的使用/HTTP请求参数.png" alt="HTTP参数"><br><br><br><strong>启动测试</strong><br><em>可以看到有10个结果在结果树中</em><br><img src="/2019/01/19/RateLimiter配合注解的使用/结果树.jpg" alt="HTTP参数"><br><br><br><strong>分别查看10个HTTP请求的响应</strong><br><em>调用成功</em><br><img src="/2019/01/19/RateLimiter配合注解的使用/调用成功结果.jpg" alt="HTTP参数"><br><br><br><em>限流请求结果</em><br><img src="/2019/01/19/RateLimiter配合注解的使用/限流请求结果.jpg" alt="HTTP参数"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><pre><code>不管重试多少次都是10次请求有4次被限制访问，6次成功访问.因此我重新设置线程次的参数为20个线程，重新发送请求后得到结果为:6次成功，14次失败，得出结论美妙的认为提交不超过六个。对于为什么是五个而不是六个，在RateLimiter的github看下issue了解。</code></pre>]]></content>
      
      
      <categories>
          
          <category> RateLimiter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RateLimiter </tag>
            
            <tag> 限流 </tag>
            
            <tag> 自定义注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker部署maven私服</title>
      <link href="/2019/01/18/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2maven%E7%A7%81%E6%9C%8D/"/>
      <url>/2019/01/18/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2maven%E7%A7%81%E6%9C%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="使用docker配置maven私服"><a href="#使用docker配置maven私服" class="headerlink" title="使用docker配置maven私服"></a>使用docker配置maven私服</h1><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><blockquote><p>安装docker环境<br>使用docker -v查看服务器docker环境<br><img src="/2019/01/18/使用Docker部署maven私服/docker-env.png" alt="docker环境"></p></blockquote><h3 id="下拉nexus3镜像"><a href="#下拉nexus3镜像" class="headerlink" title="下拉nexus3镜像"></a>下拉nexus3镜像</h3><p><em>使用命令，拉去最新版本的nexus镜像</em></p><blockquote><p>docker pull sonatype/nexus3<br><img src="/2019/01/18/使用Docker部署maven私服/nexus-pull.png" alt="拉去nexus镜像"></p></blockquote><h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><p><em>使用命令</em></p><blockquote><p>docker run –rm -d –privileged=true -p 8088:8088 –name nexus -v /root/nexus-data:/var/nexus-data sonatype/nexus3</p></blockquote><pre><code>上面命令是指使用nexus3镜像创建并启动一个容器，然后指定暴露8081端口到对应主机的8081端口将容器内部/var/nexus-data挂载到主机/root/nexus-data目录。如果没有任何问题的话，Nexus应该是搭建成功了。此时在浏览器输入：http://ip:8081即可看到以下页面：(ip为远程主机的ip地址) </code></pre><p><img src="/2019/01/18/使用Docker部署maven私服/nexus-login.png" alt="登录nexus"><br><em>修改nexus帐号密码</em></p><blockquote><p>点击右上方的Sign in进行登录，初始账号密码为admin/admin123.请登录后修改密码<br><em>如下图</em><br><img src="/2019/01/18/使用Docker部署maven私服/nexusupdate.jpg" alt="修改密码"><br>可以看到默认情况下Nexus会帮我们创建了几个仓库，仔细观察红色框住的地方，里面有几种仓库的类型，解释如下：</p></blockquote><ol><li>proxy 远程仓库的代理，比如说nexus配置了一个central repository的proxy,当用户向这个proxy请求一个</li><li>artifact的时候，会现在本地查找，如果找不到，则会从远程仓库下载，然后返回给用户。</li><li>hosted 宿主仓库，用户可以把自己的一些仓库deploy到这个仓库中</li><li>group 仓库组，是nexus特有的概念，目的是将多个仓库整合，对用户暴露统一的地址，这样就不需要配置多个仓库地址。<blockquote><p>下面我们仔细看一下里面的一些仓库。点击maven-central仓库:<br><img src="/2019/01/18/使用Docker部署maven私服/20180307192826615.jpg" alt="仓库"><br>可以看到是一个proxy类型的仓库，他代理的远程仓库地址是<a href="https://repo1.maven.org/maven2/。" target="_blank" rel="noopener">https://repo1.maven.org/maven2/。</a><br><br>后退，在进入maven-public查看:<br><img src="/2019/01/18/使用Docker部署maven私服/nexus-cha.png" alt="pubilc"><br><strong>可以看到这是一个group类型的仓库，里面包含了maven-releases/maven-snapshots/maven-central仓库，意思是我们只需要在本地添加这个仓库，则可以依赖到上述3个仓库中的库了。</strong></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> maven私服 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> maven </tag>
            
            <tag> nexus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon+Feign扩展</title>
      <link href="/2019/01/18/Ribbon-Feign%E6%89%A9%E5%B1%95/"/>
      <url>/2019/01/18/Ribbon-Feign%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Ribbon扩展"><a href="#Ribbon扩展" class="headerlink" title="Ribbon扩展"></a>Ribbon扩展</h2><h3 id="切换Ribbon加载策略，ribbon默认加载策略为懒加载，修改为饥饿加载"><a href="#切换Ribbon加载策略，ribbon默认加载策略为懒加载，修改为饥饿加载" class="headerlink" title="切换Ribbon加载策略，ribbon默认加载策略为懒加载，修改为饥饿加载"></a>切换Ribbon加载策略，ribbon默认加载策略为懒加载，修改为饥饿加载</h3><pre><code>ribbon:  eager-load:    enabled: true    # 多个用,分隔    clients: microservice-provider-user</code></pre><h3 id="Feign配置自定义【通用配置】"><a href="#Feign配置自定义【通用配置】" class="headerlink" title="Feign配置自定义【通用配置】"></a>Feign配置自定义【通用配置】</h3><pre><code>feign:  client:    config:      default:        connectTimeout: 5000        readTimeout: 5000        loggerLevel: basic</code></pre><h3 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h3><pre><code>如果你不小心又使用了Java代码配置Feign，同时又使用了配置属性配置Feign，那么使用配置属性的优先级更高。配置属性配置的方式将会覆盖Java代码配置。如果你想修改代码配置方式的优先级，可使用如下属性：feign.client.default-to-properties=false 。  </code></pre><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>一些场景下，我们可能需要对请求或响应进行压缩，此时可使用以下属性启用Feign的压缩功能。</p><pre><code>feign.compression.request.enabled=truefeign.compression.response.enabled=true</code></pre><p>对于请求的压缩，Feign还提供了更为详细的设置，例如：</p><pre><code>feign.compression.request.enabled=truefeign.compression.request.mime-types=text/xml,application/xml,application/jsonfeign.compression.request.min-request-size=2048</code></pre><p>其中，feign.compression.request.mime-types 用于支持的媒体类型列表，默认是text/xml、application/xml以及application/json。<br>feign.compression.request.min-request-size 用于设置请求的最小阈值，默认是2048。</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作-人事管理项目开发</title>
      <link href="/2019/01/18/%E5%B7%A5%E4%BD%9C-%E4%BA%BA%E4%BA%8B%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
      <url>/2019/01/18/%E5%B7%A5%E4%BD%9C-%E4%BA%BA%E4%BA%8B%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;这是我的第二份工作的第二个项目，相比于第一个安全响应项目。这个项目是针对公司内部使用的人事管理系统。主要包含数据的导入和导出，已经公司人员的管理和工资记录的管理，另一个就是这个系统基本上都是我来开发的。除了框架是公司的一个同事搭建的，因为考虑到后期该系统会调用第三方接口因此框架设计使用的和公司一样的架子，引入公司封装好的一些启动器，关闭eureka注册中心后我就开始工作了，说是架子是公司同事搭建的其实本质的技术还是我来进行选择的。</p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringBoot+Mybatis-plus+Mybatis代码生成器+POI+SpringCloud+OpenFeign+swagger2+公司的一些工具类和异常处理等</span><br></pre></td></tr></table></figure><h3 id="开发前期"><a href="#开发前期" class="headerlink" title="开发前期"></a>开发前期</h3><p>&nbsp;&nbsp;&nbsp;&nbsp; 因为需求很简单这样我就需要先考虑系统的优化，考虑到并发小因此选择使用version字段来实现乐观锁，使用mybatis-plus的乐观锁插件来控制接口的幂等性，从而解决防止同一人操作同一条数据带来的脏数据问题。对于一些工资计算算法进行封装工具类，创建常用的策略模式,这些做完后基本上就可以开始开发了。</p><h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这是我第二次开发前后端分离的项目，关于前后端分离对我来说是便捷的，起码我不需要去考虑前后端数据的交互<br>了，但是这对刚刚进入工作不久的我不是个好事，因此在空闲时间我还是需要去研究前端学习一些前端的框架，保持自己的竞争力。<br><br><img src="/2019/01/18/工作-人事管理项目开发/blogHead.jpg" alt="乐观"></p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 工作日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术图谱</title>
      <link href="/2019/01/17/%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/"/>
      <url>/2019/01/17/%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是我收集的一些技术图片，是我平时写的一下项目的架构，以及一些用<br>到的流程图.</p></blockquote><h3 id="Java技术图片"><a href="#Java技术图片" class="headerlink" title="Java技术图片"></a>Java技术图片</h3><p><img src="/2019/01/17/技术图谱/技术.png" alt="技术图谱"></p><h3 id="Java高级体系结构图"><a href="#Java高级体系结构图" class="headerlink" title="Java高级体系结构图"></a>Java高级体系结构图</h3><p><img src="/2019/01/17/技术图谱/JAVA高级体系结构.png" alt="高级体系结构"></p><h3 id="毕业设计框架图"><a href="#毕业设计框架图" class="headerlink" title="毕业设计框架图"></a>毕业设计框架图</h3><p><img src="/2019/01/17/技术图谱/校园物流架构图.png" alt="校园物流架构图"></p><h3 id="异步化结构图"><a href="#异步化结构图" class="headerlink" title="异步化结构图"></a>异步化结构图</h3><p><img src="/2019/01/17/技术图谱/调用第三方短信异步化.png" alt="调用第三方短信异步化"></p>]]></content>
      
      
      <categories>
          
          <category> 技术图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> technology_image </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SB框架]SpringBoot中对多个配置文件中的属性进行提取的简易方法</title>
      <link href="/2019/01/17/SB%E6%A1%86%E6%9E%B6-SpringBoot%E4%B8%AD%E5%AF%B9%E5%A4%9A%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E8%BF%9B%E8%A1%8C%E6%8F%90%E5%8F%96%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/"/>
      <url>/2019/01/17/SB%E6%A1%86%E6%9E%B6-SpringBoot%E4%B8%AD%E5%AF%B9%E5%A4%9A%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E8%BF%9B%E8%A1%8C%E6%8F%90%E5%8F%96%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>SpringBoot中对多个配置文件中的属性进行提取的简易方法</p></blockquote><p><strong>我们要提取一下属性:</strong><br><img src="/2019/01/17/SB框架-SpringBoot中对多个配置文件中的属性进行提取的简易方法/201811152203225.png" alt="我们要提取一下属性"><br><strong>首先创建一个GirlProperties类</strong><br><img src="/2019/01/17/SB框架-SpringBoot中对多个配置文件中的属性进行提取的简易方法/20181115220338950.png" alt="首先创建一个GirlProperties类"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.springboot.properties;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @BelongsProject: springbootideademo</span><br><span class="line"> * @BelongsPackage: com.springboot.properties</span><br><span class="line"> * @Author: HUANG</span><br><span class="line"> * @CreateTime: 2018-11-15 21:46</span><br><span class="line"> * @PROJECT_NAME: springbootideademo</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;girl&quot;)</span><br><span class="line">public class GirlProperties &#123;</span><br><span class="line">    private String cupSize;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public String getCupSize() &#123;</span><br><span class="line">        return cupSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCupSize(String cupSize) &#123;</span><br><span class="line">        this.cupSize = cupSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式:<br><img src="/2019/01/17/SB框架-SpringBoot中对多个配置文件中的属性进行提取的简易方法/20181115220407188.png" alt="调用方式"></p><p>通过属性调用:<br><img src="/2019/01/17/SB框架-SpringBoot中对多个配置文件中的属性进行提取的简易方法/20181115220501614.png" alt="通过属性调用"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
