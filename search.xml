<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微服务网关zuul的概念与实战</title>
      <link href="/2019/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3zuul%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
      <url>/2019/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3zuul%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="微服务网关Zuul"><a href="#微服务网关Zuul" class="headerlink" title="微服务网关Zuul"></a>微服务网关Zuul</h1><h3 id="为什么需要微服务网关"><a href="#为什么需要微服务网关" class="headerlink" title="为什么需要微服务网关"></a>为什么需要微服务网关</h3><pre><code>不同的微服务一般有不同的网络地址，而外部的客户端可能需要调用多个服务的接口才能完成一个业务需求。比如一个电影购票的收集APP,可能回调用电影分类微服务，用户微服务，支付微服务等。如果客户端直接和微服务进行通信，会存在一下问题： 客户端会多次请求不同微服务，增加客户端的复杂性 存在跨域请求，在一定场景下处理相对复杂 认证复杂，每一个服务都需要独立认证 难以重构，随着项目的迭代，可能需要重新划分微服务，如果客户端直接和微服务通信，那么重构会难以实施 某些微服务可能使用了其他协议，直接访问有一定困难上述问题，都可以借助微服务网关解决。微服务网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过微服务网关。</code></pre><h3 id="什么是Zuul"><a href="#什么是Zuul" class="headerlink" title="什么是Zuul"></a>什么是Zuul</h3><pre><code>Zuul是Netflix开源的微服务网关，他可以和Eureka,Ribbon,Hystrix等组件配合使用。Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能： 身份认证和安全: 识别每一个资源的验证要求，并拒绝那些不符的请求审查与监控： 动态路由：动态将请求路由到不同后端集群 压力测试：逐渐增加指向集群的流量，以了解性能 负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求 静态响应处理：边缘位置进行响应，避免转发到内部集群 多区域弹性：跨域AWS Region进行请求路由，旨在实现ELB(ElasticLoad Balancing)使用多样化Spring Cloud对Zuul进行了整合和增强。使用Zuul后，架构图演变为以下形式</code></pre><p><img src="/2019/01/28/微服务网关zuul的概念与实战/Zuul图.png" alt="微服务网关zuul的概念与实战"></p><h3 id="Zuul路由转发"><a href="#Zuul路由转发" class="headerlink" title="Zuul路由转发"></a>Zuul路由转发</h3><ol><li>引入依赖</li></ol><pre><code> &lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li><p>修改application.yml文件</p><pre><code>server:  port: 9012spring:  application:    name: tensquare-managereureka:  client:    service-url:      defaultZone: http://localhost:9010/eureka/  instance:    prefer-ip-address: true    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}zuul:  routes:    tensquare-base: /base/**    tensquare-article: /article/**    tensquare-user: /user/**jwt:  config:    key: huangsmzhenshuaihystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 60000# 解决请求超时连接问题ribbon:  ConnectTimeout: 3000  ReadTimeout: 60000management:  endpoint:    health:      show-details: always  endpoints:    web:      exposure:        include: &quot;*&quot;</code></pre></li><li><p>在启动类添加@EnableZuulProxy</p></li></ol><h3 id="Zuul过滤器"><a href="#Zuul过滤器" class="headerlink" title="Zuul过滤器"></a>Zuul过滤器</h3><ol><li><p>Zuul过滤器快速体验</p><pre><code>创建一个简单的zuul过滤器:/** * Zuul过滤器 * @author huangsm */@Componentpublic class WebFilter extends ZuulFilter {    /**     * filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过     *         滤器类型，具体如下：     *         * pre ：可以在请求被路由之前调用     *         * route ：在路由请求时候被调用     *         * post ：在route和error过滤器之后被调用     *         * error ：处理请求时发生错误时被调用     *         filterOrder ：通过int值来定义过滤器的执行顺序     *         shouldFilter ：返回一个boolean类型来判断该过滤器是否要执行，所以通过此函数可     *         实现过滤器的开关。在上例中，我们直接返回true，所以该过滤器总是生效     *         run ：过滤器的具体逻辑。     */    @Override    public String filterType() {        //前置过滤器        return &quot;pre&quot;;    }    @Override    public int filterOrder() {        //优先级为0,数字越大，优先级越低        return 0;    }    @Override    public boolean shouldFilter() {        //是否执行该过滤器，此处为true，说明需要过滤        return true;    }    @Override    public Object run() throws ZuulException {        System.out.println(&quot;进过了Zuul过滤器!&quot;);        return null;    }}</code></pre></li></ol><pre><code>filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：* pre ：可以在请求被路由之前调用* route ：在路由请求时候被调用* post ：在route和error过滤器之后被调用* error ：处理请求时发生错误时被调用filterOrder ：通过int值来定义过滤器的执行顺序shouldFilter ：返回一个boolean类型来判断该过滤器是否要执行，所以通过此函数可实现过滤器的开关。在上例中，我们直接返回true，所以该过滤器总是生效run ：过滤器的具体逻辑。</code></pre><ol start="2"><li>网站前台的token转发</li></ol><pre><code>1.网关转发Token信息到下游服务@Overridepublic Object run() throws ZuulException {    System.out.println(&quot;进过了Zuul过滤器!&quot;);    //得到request上下文    RequestContext currentContext = RequestContext.getCurrentContext();    //得到request域    HttpServletRequest request = currentContext.getRequest();    //得到头信息    String authorization = request.getHeader(&quot;Authorization&quot;);    //判断是否有头信息    if (StringUtils.isNotBlank(authorization)) {        currentContext.addZuulRequestHeader(&quot;Authorization&quot;, authorization);    }    return null;}</code></pre><ol start="3"><li><p>管理后台过滤器实现token校验</p><pre><code>  @Overridepublic Object run() throws ZuulException {    RequestContext currentContext = RequestContext.getCurrentContext();    HttpServletRequest request = RequestContext.getCurrentContext().getRequest();    String authorization = request.getHeader(&quot;Authorization&quot;);    //第一次请求时，进过OPTIONS方法来分发路径，不会带有头信息    if (request.getMethod().equals(&quot;OPTIONS&quot;)){        return null;    }    //如果login存在这为登录请求，就放行    if (request.getRequestURI().indexOf(&quot;/admin/login&quot;)&gt;0){        System.out.println(&quot;登录页面&quot;+request.getRequestURI());        return null;    }    if (StringUtils.isNotBlank(authorization)) {        if (authorization.startsWith(&quot;Bearer &quot;)) {            String token = authorization.substring(7);            try {                Claims claims = jwtUtil.parseJWT(token);                String roles = (String) claims.get(&quot;roles&quot;);                if (roles.equals(&quot;admin&quot;)) {                    currentContext.addZuulRequestHeader(&quot;Authorization&quot;, authorization);                    return null;                }            } catch (Exception e) {                //终止运行                currentContext.setSendZuulResponse(false);                currentContext.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);                currentContext.setResponseBody(&quot;无权访问&quot;);            }        }    }    //终止运行    currentContext.setSendZuulResponse(false);    currentContext.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);    currentContext.setResponseBody(&quot;无权访问&quot;);    currentContext.getResponse().setContentType(&quot;text/html;charset=UTF-8&quot;);    return null;}</code></pre></li><li><p>解决CORS跨域请求问题</p><pre><code>/** * 解决cors跨域问题 * @author huangsm * @version V1.0 */@Configurationpublic class WebMvcConfigurer {    @Bean    public WebMvcConfigurer corsConfigurer() {        return new WebMvcConfigurer() {            public void addCorsMappings(CorsRegistry registry) {                registry.addMapping(&quot;/users/**&quot;)                        .allowedOrigins(&quot;http://huangsm.zyx.com&quot;)                        .allowedMethods(&quot;GET&quot;, &quot;POST&quot;);            }        };    }}</code></pre></li></ol><p><strong>关于更加详细的Zuul网关的使用，可以了解下我的码云上的代码</strong></p><p><a href="https://gitee.com/wangyuanbaby/microservice-springcloud/tree/master/microservice-gateway-zuul-filter/" target="_blank" rel="noopener">SpringCloud-Zuul</a></p>]]></content>
      
      
      <categories>
          
          <category> Zuul </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zuul </tag>
            
            <tag> 统一权限管理与Token转发 </tag>
            
            <tag> Zuul访问超时问题解决 </tag>
            
            <tag> 统一Cors跨域解决 </tag>
            
            <tag> Zuul过滤器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud的Hystrix断路器在服务中的应用</title>
      <link href="/2019/01/27/SpringCloud%E7%9A%84Hystrix%E6%96%AD%E8%B7%AF%E5%99%A8%E5%9C%A8%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2019/01/27/SpringCloud%E7%9A%84Hystrix%E6%96%AD%E8%B7%AF%E5%99%A8%E5%9C%A8%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="熔断器Hystrix"><a href="#熔断器Hystrix" class="headerlink" title="熔断器Hystrix"></a>熔断器Hystrix</h1><h3 id="为什么要使用熔断器"><a href="#为什么要使用熔断器" class="headerlink" title="为什么要使用熔断器"></a>为什么要使用熔断器</h3><blockquote><p>&nbsp;&nbsp;&nbsp;在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，<br>进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种<br>因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;如果下图所示：A作为服务提供者，B为A的服务消费者，C和D是B的服务消费者。A<br>不可用引起了B的不可用，并将不可用像滚雪球一样放大到C和D时，雪崩效应就形成<br>了。</p></blockquote><p><img src="/2019/01/27/SpringCloud的Hystrix断路器在服务中的应用/雪崩效应.png" alt="雪崩效应"></p><p>如何避免产生这种雪崩效应呢？我们可以使用Hystrix来实现熔断器。</p><h3 id="什么是Hystrix"><a href="#什么是Hystrix" class="headerlink" title="什么是Hystrix"></a>什么是Hystrix</h3><blockquote><p>Hystrix 能使你的系统在出现依赖服务失效的时候，通过隔离系统所依赖的服务，防止服务级联失败，同时提供失败回退机制，更优雅地应对失效，并使你的系统能更快地从异常中恢复。</p></blockquote><blockquote><p>了解熔断器模式请看下图:</p></blockquote><p><img src="/2019/01/27/SpringCloud的Hystrix断路器在服务中的应用/Hystirx.png" alt="Hystirx"></p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ol><li><p>Feign 本身支持Hystrix，不需要额外引入依赖。修改application.yml配置文件</p><pre><code>feign:  hystrix:    enabled: true</code></pre></li><li><p>创建BaseClient实现类</p><pre><code>@FeignClient(name = &quot;tensquare-base&quot;,fallback = BaseClientFallback.class,configuration = FallBackConfig.class)public interface BaseClient {    /**     * 调用base服务的根据ID查询文章接口     * @param labelId     * @return     */    @GetMapping(&quot;/label/{labelId}&quot;)    Result findById(@PathVariable(&quot;labelId&quot;) String labelId);}/** * 熔断器 * @author huangsm */@Componentpublic class BaseClientFallback implements BaseClient{    @Override    public Result findById(String labelId) {        return new Result(false, StatusCode.ERROR,&quot;服务崩溃了~&quot;);    }}</code></pre></li><li><p>创建配置类，监控feign客户端日志</p><pre><code>/** * feign配置类 * @author huangsm */public class FallBackConfig  {    /**     * 配置Feign的日志级别     * @return     */    @Bean    public Logger.Level feignLoggerLevel(){        return Logger.Level.FULL;    }}</code></pre></li><li><p>根据日志监听类</p><pre><code>logging:  level:    com.tensquare.qa.client.BaseClient: debug</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Feign </tag>
            
            <tag> Hystrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud基本概念以及服务注册与服务调用</title>
      <link href="/2019/01/27/SpringCloud%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
      <url>/2019/01/27/SpringCloud%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud简介"><a href="#SpringCloud简介" class="headerlink" title="SpringCloud简介"></a>SpringCloud简介</h1><h3 id="什么是SpringCloud"><a href="#什么是SpringCloud" class="headerlink" title="什么是SpringCloud?"></a>什么是SpringCloud?</h3><blockquote><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如<br>服务发现注册、配置中心、消息总线、负载均衡、熔断器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p></blockquote><p>&nbsp;&nbsp;&nbsp;<a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="noopener">Spring Cloud项目的官方网址</a></p><h3 id="SpringCloud与SpringBoot的关系"><a href="#SpringCloud与SpringBoot的关系" class="headerlink" title="SpringCloud与SpringBoot的关系"></a>SpringCloud与SpringBoot的关系</h3><blockquote><p>&nbsp;&nbsp;&nbsp;Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单<br>个微服务，Spring Cloud是一个基于Spring Boot实现的云应用开发工具；Spring Boot专<br>注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架；<br>Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就<br>不配置，Spring Cloud很大的一部分是基于Spring Boot来实现，可以不基于Spring Boot<br>吗？不可以。</p></blockquote><blockquote><p>Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开<br>Spring Boot，属于依赖的关系。</p></blockquote><h3 id="Spring-Cloud和Dubbo对比"><a href="#Spring-Cloud和Dubbo对比" class="headerlink" title="Spring Cloud和Dubbo对比"></a>Spring Cloud和Dubbo对比</h3><blockquote><p>或许很多人会说Spring Cloud和Dubbo的对比有点不公平，Dubbo只是实现了服务治<br>理，而Spring Cloud下面有17个子项目（可能还会新增）分别覆盖了微服务架构下的方<br>方面面，服务治理只是其中的一个方面，一定程度来说，Dubbo只是Spring Cloud<br>Netflix中的一个子集。</p></blockquote><p><img src="/2019/01/27/SpringCloud基本概念以及服务注册与服务调用/SpringCloud和Dubbo的对比.png" alt="SpringCloud和Dubbo的对比"></p><p><strong>这里可以去了解下我以前一篇文章了解下RPC和HTTP直接的区别，也可以帮助你了解Dubbo和SC之间的区别</strong><br><a href="https://www.babywang.huangsm.xyz/2019/01/20/%E7%AE%80%E8%BF%B0HTTP%E5%92%8CRPC%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/">简述HTTP和RPC的优缺点</a></p><h1 id="服务发现组件-Eureka"><a href="#服务发现组件-Eureka" class="headerlink" title="服务发现组件 Eureka"></a>服务发现组件 Eureka</h1><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><pre><code>    Eureka是Netflix开发的服务发现框架，SpringCloud将它集成在自己的子项目spring-cloud-netflix中，实现SpringCloud的服务发现功能。Eureka包含两个组件：Eureka Server和Eureka Client。    Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。    Eureka Client是一个java客户端，用于简化与Eureka Server的交互，客户端同时也就别一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳,默认周期为30秒，如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移除(默认90秒)。    Eureka Server之间通过复制的方式完成数据的同步，Eureka还提供了客户端缓存机制，即使所有的Eureka Server都挂掉，客户端依然可以利用缓存中的信息消费其他服务的API。综上，Eureka通过心跳检查、客户端缓存等机制，确保了系统的高可用性、灵活性和可伸缩性。</code></pre><h3 id="Eureka服务端开发"><a href="#Eureka服务端开发" class="headerlink" title="Eureka服务端开发"></a>Eureka服务端开发</h3><ol><li>创建注册中心模块</li><li><p>引入依赖</p><pre><code>&lt;properties&gt;    &lt;spring-cloud.version&gt; Finchley.RELEASE&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;            &lt;version&gt;${spring-cloud.version}&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;</code></pre></li><li><p>添加application.yml配置</p><pre><code>server:  port: 9010spring:  application:    name: eureka-registereureka:  client:    service-url:      defaultZone: http://localhost:${server.port}/eureka/    register-with-eureka: false    fetch-registry: false</code></pre></li><li><p>在启动类加上@EnableEurekaServer</p></li></ol><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><ol><li><p>引入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>编写application.yml文件</p><pre><code>eureka:  client:    service-url:      defaultZone: http://localhost:9010/eureka/  instance:    prefer-ip-address: true    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}</code></pre></li></ol><p><img src="/2019/01/27/SpringCloud基本概念以及服务注册与服务调用/服务注册成功.png" alt="服务注册成功"><br><strong>注意F版本后，客户端无需在启动类加@EnableEurekaClient注解</strong></p><p>###　保护模式</p><pre><code>如果在Eureka Server的首页看到以下这段提示，则说明Eureka已经进入了保护模式：</code></pre><p><img src="/2019/01/27/SpringCloud基本概念以及服务注册与服务调用/eureka自我保护提示.png" alt="eureka自我保护提示">　</p><blockquote><p>&nbsp;&nbsp;&nbsp;Eureka Server在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%，如果出<br>现低于的情况（在单机调试的时候很容易满足，实际在生产环境上通常是由于网络不稳<br>定导致），Eureka Server会将当前的实例注册信息保护起来，同时提示这个警告。保护<br>模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保<br>护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的<br>数据（也就是不会注销任何微服务）。</p></blockquote><h1 id="Feign实现服务间的调用"><a href="#Feign实现服务间的调用" class="headerlink" title="Feign实现服务间的调用"></a>Feign实现服务间的调用</h1><h3 id="Feign简介"><a href="#Feign简介" class="headerlink" title="Feign简介"></a>Feign简介</h3><blockquote><p>&nbsp;&nbsp;&nbsp;Feign是简化Java HTTP客户端开发的工具（java-to-httpclient-binder），它的灵感<br>来自于Retrofit、JAXRS-2.0和WebSocket。Feign的初衷是降低统一绑定Denominator到<br>HTTP API的复杂度，不区分是否为restful.</p></blockquote><h3 id="通过Feign-实现问答服务调用基础服务"><a href="#通过Feign-实现问答服务调用基础服务" class="headerlink" title="(通过Feign)实现问答服务调用基础服务"></a>(通过Feign)实现问答服务调用基础服务</h3><ol><li><p>引入依赖</p><pre><code> &lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>在启动类添加@EnableFeignClients和@EnableDiscoveryClient</p></li><li>调用Base服务接口</li></ol><pre><code>/** * 通过Feign调用服务 * @author huangsm */@FeignClient(name = &quot;tensquare-base&quot;)public interface BaseClient {    /**     * 调用base服务的根据ID查询文章接口     * @param labelId     * @return     */    @GetMapping(&quot;/label/{labelId}&quot;)    Result findById(@PathVariable(&quot;labelId&quot;) String labelId);}</code></pre><ol start="4"><li>远程服务的使用</li></ol><pre><code>@Autowiredprivate BaseClient baseClient;@GetMapping(value = &quot;/label/{labelid}&quot;)public Result findLabelById(@PathVariable String labelid){    Result result = baseClient.findById(labelid);    return result;}</code></pre><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p><strong>因为Feign内集成了rabbion所以引入feign后服务带有负载均衡</strong></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Dubbo </tag>
            
            <tag> Eureka </tag>
            
            <tag> Feign </tag>
            
            <tag> rabbion </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于JWT的微服务鉴权开发实现</title>
      <link href="/2019/01/26/%E5%9F%BA%E4%BA%8EJWT%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%89%B4%E6%9D%83%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/01/26/%E5%9F%BA%E4%BA%8EJWT%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%89%B4%E6%9D%83%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="鉴权微服务开发"><a href="#鉴权微服务开发" class="headerlink" title="鉴权微服务开发"></a>鉴权微服务开发</h2><h3 id="JWT工具类编写"><a href="#JWT工具类编写" class="headerlink" title="JWT工具类编写"></a>JWT工具类编写</h3><pre><code>/** * JWT工具类 * @author huangsm */@ConfigurationProperties(&quot;jwt.config&quot;)public class JwtUtil {    private String key ;    /**     * 一个小时     */    private long ttl ;    public String getKey() {        return key;    }    public void setKey(String key) {        this.key = key;    }    public long getTtl() {        return ttl;    }    public void setTtl(long ttl) {        this.ttl = ttl;    }    /**     * 生成JWT     *     * @param id     * @param subject     * @return     */    public String createJWT(String id, String subject, String roles) {        long nowMillis = System.currentTimeMillis();        Date now = new Date(nowMillis);        JwtBuilder builder = Jwts.builder().setId(id)                .setSubject(subject)                .setIssuedAt(now)                .signWith(SignatureAlgorithm.HS256, key).claim(&quot;roles&quot;, roles);        if (ttl &gt; 0) {            builder.setExpiration( new Date( nowMillis + ttl));        }        return builder.compact();    }    /**     * 解析JWT     * @param jwtStr     * @return     */    public Claims parseJWT(String jwtStr){        return  Jwts.parser()                .setSigningKey(key)                .parseClaimsJws(jwtStr)                .getBody();    }}</code></pre><h3 id="管理员登陆后台签发token"><a href="#管理员登陆后台签发token" class="headerlink" title="管理员登陆后台签发token"></a>管理员登陆后台签发token</h3><p>１．　修改全局配置文件，配置token的盐和过期时间</p><pre><code>jwt:  config:    key: huangsmzhenshuai    ttl: 3600000</code></pre><ol start="2"><li><p>将Jwt工具类放入Spring容器</p><pre><code>@Beanpublic JwtUtil jwtUtil(){    return new JwtUtil();}</code></pre></li><li><p>管理员登录后台token签发</p><pre><code>1.控制层代码: @PostMapping(value = &quot;/login&quot;)public Result login(@RequestBody Admin admin) {    String token = adminService.login(admin.getLoginname(), admin.getPassword());    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;token&quot;, token);    map.put(&quot;roles&quot;, &quot;admin&quot;);    map.put(&quot;loginName&quot;, admin.getLoginname());    return new Result(true, StatusCode.OK, &quot;登录成功&quot;, map);} 2.服务层代码:@Autowiredprivate JwtUtil jwtUtil;public String login(String loginName,String password){    Admin sysAdmin = adminDao.findByLoginname(loginName);    if (sysAdmin==null){        throw new RuntimeException(&quot;用户名不存在!&quot;);    }    if (!bCryptPasswordEncoder.matches(password,sysAdmin.getPassword())){        throw new RuntimeException(&quot;密码错误!&quot;);    }    String token = jwtUtil.createJWT(loginName, password, &quot;admin&quot;);    return token;}</code></pre></li></ol><ol start="4"><li><p>管理员删除用户功能鉴权</p><pre><code>需求：删除用户，必须拥有管理员权限，否则不能删除前后端约定：前端请求微服务时需要添加头信息Authorization ,内容为Bearer+空格+token业务代码:   /**     * 删除必须有admin才可以删除     *     * @param id     */    public void deleteById(String id) {        String authorization = request.getHeader(&quot;Authorization&quot;);        if (StringUtils.isEmpty(authorization)){            throw new RuntimeException(&quot;权限不足!&quot;);        }        if (!authorization.startsWith(&quot;Bearer&quot;)){            throw new RuntimeException(&quot;权限不足!&quot;);        }        //得到token        String token = authorization.substring(7);        try {            Claims claims = jwtUtil.parseJWT(token);            if (!claims.get(&quot;roles&quot;).equals(&quot;admin&quot;)||claims.get(&quot;roles&quot;)==null){                throw new RuntimeException(&quot;权限不足!&quot;);            }        }catch (Exception e){            throw new RuntimeException(&quot;权限不足!&quot;);        }        userDao.deleteById(id);    }</code></pre></li><li><p>上述代码你会发现个问题，每次验证都需要写一大堆业务，代码过于重复，这里使用拦截器来完成鉴权</p></li></ol><pre><code>一、编写拦截器/** * 授权拦截器 * * @author huangsm */@Componentpublic class JwtInterceptor implements HandlerInterceptor {    /**     * Spring为我们提供了org.springframework.web.servlet.handler.HandlerInterceptorAdapter这个适配器，     * 继承此类，可以非常方便的实现自己的拦截器。     * 他有三个方法：分别实现预处理、后处理（调用了Service并返回ModelAndView，但未进行页面渲染）、返回处理（已经渲染了页面）     * 在preHandle中，可以进行编码、安全控制等处理；     * 在postHandle中，有机会修改ModelAndView；     * 在afterCompletion中，可以根据ex是否为null判断是否发生了异常，进行日志记     */    @Autowired    private JwtUtil jwtUtil;    /**     * 前置拦截器     *     * @param request     * @param response     * @param handler     * @return     * @throws Exception     */    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(&quot;经过了拦截器&quot;);        //无论如何都放下。具体能不能操作还是在具体操作中去判断        //拦截器只是负责把请求头中包含token的令牌进行解析验证。        final String authorization = request.getHeader(&quot;Authorization&quot;);        //如果包含有Authorization头信息，就对其进行判断        if (authorization != null &amp;&amp; authorization.startsWith(&quot;Bearer&quot;)) {            //得到token            final String token = authorization.substring(7);            try {                Claims claims = jwtUtil.parseJWT(token);                if (claims != null) {                    String roles = (String) claims.get(&quot;roles&quot;);                    //如果是管理员                    if (&quot;admin&quot;.equals(roles) &amp;&amp; roles != null) {                        request.setAttribute(&quot;admin_claims&quot;, claims);                    }                    //如果是用户                    if (&quot;user&quot;.equals(roles) &amp;&amp; roles != null) {                        request.setAttribute(&quot;user_claims&quot;, claims);                    }                }            } catch (Exception e) {                throw new RuntimeException(&quot;令牌有误!&quot;);            }        }        return true;    }}二、将拦截器加入到SpringMvc中/** * Web配置类 * * @author huangsm */@Configurationpublic class WebConfig extends WebMvcConfigurationSupport {    @Autowired    private JwtInterceptor jwtInterceptor;    /**     * 添加拦截器     * addPathPatterns拦截的路径     * excludePathPatterns不拦截的路径     * @param registry     */    @Override    public void addInterceptors(InterceptorRegistry registry) {        //注册拦截器要声明拦截器对象和要拦截的请求        registry.addInterceptor(jwtInterceptor)                .addPathPatterns(&quot;/**&quot;)                .excludePathPatterns(&quot;/**/login&quot;);    }}三、修改原有的删除用户逻辑    /**     * 删除必须有admin才可以删除     *     * @param id     */    public void deleteById(String id) {        Claims admin_claims = (Claims) request.getAttribute(&quot;admin_claims&quot;);        if (admin_claims == null) {            throw new RuntimeException(&quot;权限不足!&quot;);        }        userDao.deleteById(id);    }</code></pre><p><strong>这是是一个拦截器的简单使用，其实可以加上角色认证和aop注解栏控制那些请求不需要拦截</strong></p>]]></content>
      
      
      <categories>
          
          <category> JWT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> jwt </tag>
            
            <tag> 权限拦截器 </tag>
            
            <tag> 鉴权微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于JWT的Token认证机制以及实现</title>
      <link href="/2019/01/26/%E5%9F%BA%E4%BA%8EJWT%E7%9A%84Token%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/01/26/%E5%9F%BA%E4%BA%8EJWT%E7%9A%84Token%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前提要求"><a href="#前提要求" class="headerlink" title="前提要求"></a>前提要求</h1><p><strong>考虑到使用SpringSecurity的BCryptPasswordEncoder盐加密算法所以在服务中引入SpringSecurity</strong></p><ol><li>引入依赖</li></ol><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>我们在添加了spring security依赖后，所有的地址都被spring security所控制了，我们目前只是需要用到BCrypt密码加密的部分，所以我们要添加一个配置类，配置为所有地址都可以匿名访问</li></ol><pre><code>/** * 安全配置类 * @author huangsm */@EnableWebSecurity@Configurationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {    /**     * authorizeRequests所有security全注解配置实现的开端，表示开始说明需要的权限。     * 需要的权限分两部分，第一部分是拦截的路径，第二部分访问该路径需要的权限。     * antMatchers表示拦截什么路径，permitAll任何权限都可以访问，直接放行所有。     * anyRequest()任何的请求，authenticated认证后才能访问     * and().csrf().disable()；固定写法，标识csrf失效。     * @param http     * @throws Exception     */    @Override    protected void configure(HttpSecurity http) throws Exception {        http                .authorizeRequests()                .antMatchers(&quot;/**&quot;).permitAll()                .anyRequest().authenticated()                .and().csrf().disable();    }    /**     * 配置BCrypt强哈希方法 每次加密的结果都不一样     * @return     */    @Bean    public BCryptPasswordEncoder bCryptPasswordEncoder(){        return new BCryptPasswordEncoder();    }}</code></pre><h1 id="基于JWT的Token认证机制"><a href="#基于JWT的Token认证机制" class="headerlink" title="基于JWT的Token认证机制"></a>基于JWT的Token认证机制</h1><h3 id="关于有状态登录和无状态的登录"><a href="#关于有状态登录和无状态的登录" class="headerlink" title="关于有状态登录和无状态的登录"></a>关于有状态登录和无状态的登录</h3><ul><li>有状态登录: 服务器端需要存储用户信息</li><li>无状态登录: 服务器端不需要存储用户信息</li></ul><h3 id="常见的认证机制"><a href="#常见的认证机制" class="headerlink" title="常见的认证机制"></a>常见的认证机制</h3><ol><li>HTTP Basic Auth（无状态登录）</li></ol><pre><code>HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP BasicAuth</code></pre><ol start="2"><li><p>Cookie Auth</p><pre><code>Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效。</code></pre><p> <img src="/2019/01/26/基于JWT的Token认证机制以及实现/Cookie认证机制.png" alt="基于JWT的Token认证机制以及实现"></p></li><li><p>OAuth</p><pre><code>OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有</code></pre><p><strong>下面是OAuth2.0的流程:</strong></p></li></ol><p><img src="/2019/01/26/基于JWT的Token认证机制以及实现/OAuth认证机制.png" alt="OAuth认证机制"></p><pre><code>这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。</code></pre><ol start="4"><li><p>Token Auth</p><pre><code>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：1.客户端使用用户名跟密码请求登录2.服务端收到请求，去验证用户名与密码3.验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端4.客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里5.客户端每次向服务端请求资源的时候需要带着服务端签发的 Token6.服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</code></pre></li></ol><p><img src="/2019/01/26/基于JWT的Token认证机制以及实现/JwtToken.png" alt="JwtToken"></p><p><strong>Token Auth的优点:</strong></p><p>Token机制相对于Cookie机制又有什么好处呢？</p><ul><li>支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提<br>是传输的用户认证信息通过HTTP头传输.</li><li>无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为<br>Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储<br>状态信息.</li><li>更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，<br>HTML,图片等），而你的服务端只要提供API即可.</li><li>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在<br>你的API被调用的时候，你可以进行Token生成调用即可.<br>更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）<br>时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认<br>证机制就会简单得多。</li><li>CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防<br>范。</li><li>性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256<br>计算 的Token验证和解析要费时得多.</li><li>不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要<br>为登录页面做特殊处理.</li><li>基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在<br>多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：<br>Firebase,Google, Microsoft）.<h3 id="基于JWT的Token认证机制实现"><a href="#基于JWT的Token认证机制实现" class="headerlink" title="基于JWT的Token认证机制实现"></a>基于JWT的Token认证机制实现</h3></li></ul><ol><li><p>什么是JWT?</p><pre><code>JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息.</code></pre></li><li><p>JWT组成</p><pre><code>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。</code></pre></li></ol><p><strong>头部（Header）</strong></p><pre><code>    头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。{&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;}    在头部指明了签名算法是HS256算法。 我们进行BASE64编码http://base64.xpcha.com/，编码后的字符串如下：    eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1Ni</code></pre><blockquote><p>小知识：Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。JDK 中提供了非常方便的 BASE64Encoder 和 BASE64Decoder，用它们可以非常方便的完成基于 BASE64 的编码和解码</p></blockquote><p><strong>载荷（playload）</strong></p><pre><code>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分（1）标准中注册的声明（建议但不强制使用）    iss: jwt签发者    sub: jwt所面向的用户    aud: 接收jwt的一方    exp: jwt的过期时间，这个过期时间必须要大于签发时间    nbf: 定义在什么时间之前，该jwt都是不可用的.    iat: jwt的签发时间    jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。（2）公共的声明    公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.    但不建议添加敏感信息，因为该部分在客户端可解密.（3）私有的声明    私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64    是对称解密的，意味着该部分信息可以归类为明文信息。    这个指的就是自定义的claim。比如前面那个结构举例中的admin和name都属于自定的    claim。这些claim跟JWT标准规定的claim区别在于：JWT规定的claim，JWT的接收方在    拿到JWT之后，都知道怎么对这些标准的claim进行验证(还不知道是否能够验证)；而    private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行.</code></pre><p><em>定义一个payload:</em></p><pre><code>{&quot;sub&quot;:&quot;1234567890&quot;,&quot;name&quot;:&quot;John Doe&quot;,&quot;admin&quot;:true}</code></pre><p><em>然后将其进行base64编码，得到Jwt的第二部分。</em></p><pre><code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</code></pre><p><strong>签证（signature）</strong></p><p><em>jwt的第三部分是一个签证信息，这个签证信息由三部分组成</em></p><pre><code>    header (base64后的)    payload (base64后的)    secr这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ将这三部分用.连接成一个完整的字符串,构成了最终的jwt:</code></pre><blockquote><p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIi<br>wiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</p></blockquote><pre><code>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</code></pre><h3 id="Java的JJWT实现JWT"><a href="#Java的JJWT实现JWT" class="headerlink" title="Java的JJWT实现JWT"></a>Java的JJWT实现JWT</h3><ol><li><p>什么是JJWT？</p><pre><code>JJWT是一个提供端到端的JWT创建和验证的Java库。永远免费和开源(ApacheLicense，版本2.0)，JJWT很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。</code></pre></li><li><p>token的创建</p><pre><code>一、引入依赖&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;    &lt;version&gt;0.6.0&lt;/version&gt;&lt;/dependency&gt;二、创建类JwtTest，用于生成token/** * 测试生产Json Web Token */public class CreateJwt {    public static void main(String[] args) {        /**         * signWith实现签名算法和盐(huangsm是盐)         * setIssuedAt用于设置签发时间         * signWith用于设置签名秘钥         * setExpiration设置过期时间         */        //为了方便测试，我们将过期时间设置为1分钟        long now = System.currentTimeMillis();// 当前时间        long exp = now + 1000 * 60;//过期时间为1分钟        JwtBuilder jwtBuilder = Jwts.builder()                .setId(&quot;666&quot;)                .setSubject(&quot;你号&quot;)                .setIssuedAt(new Date())                .signWith(SignatureAlgorithm.HS256, &quot;huangsm&quot;)                .setExpiration(new Date(exp));        System.out.println(jwtBuilder.compact());    }}</code></pre></li></ol><ol start="3"><li>token的解析</li></ol><pre><code>我们刚才已经创建了token ，在web应用中这个操作是由服务端进行然后发给客户端，客户端在下次向服务端发送请求时需要携带这个token（这就好像是拿着一张门票一样），那服务端接到这个token 应该解析出token中的信息（例如用户id）,根据这些信息查询数据库返回相应的结果。解析类:/** * JWT解析 * * @author huangsm */public class ParseJwt {    public static void main(String[] args) {        String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI2NjYiLCJzdWIiOiLkvaDlj7ciLCJpYXQiOjE1NDg1MDI5NzZ9.-MhnLDDDmdsT6c8CX1qXA-kM2HneEgdxIrNH5_54Jn8&quot;;        Claims claims = Jwts.parser().setSigningKey(&quot;huangsm&quot;)                .parseClaimsJws(token).getBody();        System.out.println(&quot;用户ID:&quot;+claims.getId());        System.out.println(&quot;用户名称:&quot;+claims.getSubject());        System.out.println(&quot;登录时间:&quot;+claims.getIssuedAt());    }}</code></pre><p><em>试着将token或签名秘钥篡改一下，会发现运行时就会报错，所以解析token也就是验证token</em></p><ol start="4"><li>自定义claims</li></ol><blockquote><p>我们刚才的例子只是存储了id和subject两个信息，如果你想存储更多的信息（例如角<br>色）可以定义自定义claims </p></blockquote><pre><code>/** * 测试生产Json Web Token */public class CreateJwt {    public static void main(String[] args) {        /**         * signWith实现签名算法和盐(huangsm是盐)         * setIssuedAt用于设置签发时间         * signWith用于设置签名秘钥         * setExpiration设置过期时间         * claim自定义claim         */        //为了方便测试，我们将过期时间设置为1分钟        long now = System.currentTimeMillis();// 当前时间        long exp = now + 1000 * 60;//过期时间为1分钟        JwtBuilder jwtBuilder = Jwts.builder()                .setId(&quot;666&quot;)                .setSubject(&quot;你号&quot;)                .setIssuedAt(new Date())                .signWith(SignatureAlgorithm.HS256, &quot;huangsm&quot;)                .setExpiration(new Date(exp))                .claim(&quot;role&quot;,&quot;admin&quot;)                .claim(&quot;image&quot;,&quot;login.png&quot;);        System.out.println(jwtBuilder.compact());    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JWT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Json Web Token </tag>
            
            <tag> token </tag>
            
            <tag> JJWT </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> 认证机制 </tag>
            
            <tag> 无状态登录和有状态登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ在用户微服务开发中的实战</title>
      <link href="/2019/01/26/RabbitMQ%E5%9C%A8%E7%94%A8%E6%88%B7%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AE%9E%E6%88%98/"/>
      <url>/2019/01/26/RabbitMQ%E5%9C%A8%E7%94%A8%E6%88%B7%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h4 id="用户微服务开发"><a href="#用户微服务开发" class="headerlink" title="用户微服务开发"></a>用户微服务开发</h4><ol><li><p>发送短信验证码</p><pre><code>实现思路： 在用户微服务编写API ,生成手机验证码，存入Redis并发送到RabbitMQ一、准备工作（1）因为要用到缓存和消息队列，所以在用户微服务（tensquare_user）引入依赖redis和amqp的起步依赖。  &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;  &lt;/dependency&gt;（2）修改application.yml ,在spring 节点下添加配置    spring:      redis:        host: 192.168.25.133      rabbitmq:        host: 192.168.25.133二、代码实现（1）在UserService中新增方法，用于发送短信验证码     /**      * 发送短信验证码      *      * @param mobile 手机号      */    public void sendSms(String mobile) {        //1.生成6位短信验证码        String code = RandomStringUtils.randomNumeric(6);        System.out.println(mobile + &quot;收到验证码是:&quot; + code);        //2.将验证码放于redis(5分钟过期)        redisTemplate.opsForValue().set(&quot;smsCode_&quot; + mobile, code, 5, TimeUnit.MINUTES);        //3.将验证码和手机号发动到RabbitMQ中        Map&lt;String, String&gt; map = new HashMap&lt;&gt;(2);        map.put(&quot;mobile&quot;, mobile);        map.put(&quot;code&quot;, code);        rabbitTemplate.convertAndSend(&quot;sms&quot;, map);    }（2）UserController新增方法    @PostMapping(&quot;/sendSms/{mobile}&quot;)    public Result sendSms(@PathVariable(&quot;mobile&quot;) String mobile){        userService.sendSms(mobile);        return new Result(true,StatusCode.OK,&quot;发送成功&quot;);    }（3）启动微服务，在rabbitMQ中创建名为sms的队列，测试API三、用户注册服务开发  /**   * 用户注册   * @param user 用户信息   * @param code 验证码   */    @Transactional(rollbackFor = Exception.class)    public void  register(User user,String code){        String sysCode = (String) redisTemplate.opsForValue().get(&quot;smsCode_&quot; + user.getMobile());        if (StringUtils.isEmpty(sysCode)){            throw new RuntimeException(&quot;请点击获取验证码!&quot;);        }        if (StringUtils.isEmpty(code)){            throw new RuntimeException(&quot;请输入您收到的验证码!&quot;);        }        if (!sysCode.equals(code)){            throw new RuntimeException(&quot;验证码输入有误，请重新输入!&quot;);        }        user.setId(idWorker.nextId()+&quot;&quot;);        //关注数        user.setFollowcount(0);        //粉丝总数        user.setFanscount(0);        userDao.save(user);    }</code></pre><h4 id="短信微服务开发"><a href="#短信微服务开发" class="headerlink" title="短信微服务开发"></a>短信微服务开发</h4><p>开发短信发送微服务，从rabbitMQ中提取消息，调用阿里大于短信接口实现短信发送。<br><br>（我们这里实际做的就是消息的消费）</p></li><li><p>引入依赖</p><pre><code>&lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt;</code></pre></li><li><p>创建application.yml</p><pre><code>server:  port: 9009spring:  application:    name: tensquare-sms  rabbitmq:    host: 192.168.25.133</code></pre></li><li><p>创建消息监听器(消息消费者)</p><pre><code>/** * 发送短信监听类 * @author huangsm * @date 2019/1/26 17:08:36 */@Component@RabbitListener(queues = &quot;sms&quot;)public class SmsListener {    @RabbitHandler    public void sendSms(Map&lt;String,String&gt; map){        System.out.println(map);    }}</code></pre></li></ol><p><strong>这里RabbitMQ在短信服务中的应用就开发完成了，这里没有真的发送短信，如果发送短信可以调用第三方(如阿里大于等)</strong></p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 短信服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件RabbitMQ的使用以及基本概念</title>
      <link href="/2019/01/26/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/01/26/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h2><ol><li><p>消息队列中间件简介</p><pre><code>  消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用，可伸缩和最终一致性[架构]使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ以下介绍消息队列在实际应用中常用的使用场景：异步处理，应用解耦，流量削锋和消息通讯四个场景</code></pre><p><em>速度:kafka、rabbitmq、activemq</em><br><br><em>最安全的是:activemq</em></p></li><li><p>什么是RabbitMQ</p><pre><code>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：1.可靠性（Reliability）RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。2.灵活的路由（Flexible Routing）在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。3.消息集群（Clustering）多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。4.高可用（Highly Available Queues）队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。5.多种协议（Multi-protocol）RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。6.多语言客户端（Many Clients）RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。7.管理界面（Management UI）RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。8.跟踪机制（Tracing）如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。9.插件机制（Plugin System）RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件</code></pre></li><li><p>架构图与主要概念</p></li></ol><p><strong>RabbitMQ架构图</strong><br><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/RabbitMq架构图.png" alt="RabbitMq架构图"></p><p><strong>主要概念</strong></p><pre><code>RabbitMQ Server： 也叫broker server，它是一种传输服务。 他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。Producer： 消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服务器然后将消息投递到Exchange。Consumer：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列，RabbitMQ将Queue中的消息发送到消息消费者。Exchange：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。Exchange并不存储消息。RabbitMQ中的Exchange有direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。Queue：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并最终投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。RoutingKey：生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255bytesConnection： （连接）：Producer和Consumer都是通过TCP连接到RabbitMQ Server的。以后我们可以看到，程序的起始处就是建立这个TCP连接。Channels： （信道）：它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。VirtualHost：权限控制的基本单位，一个VirtualHost里面有若干Exchange和MessageQueue，以及指定被哪些user使用</code></pre><h2 id="RabbitMQ的使用"><a href="#RabbitMQ的使用" class="headerlink" title="RabbitMQ的使用"></a>RabbitMQ的使用</h2><ol><li><p>RabbitMQ安装与启动</p><p> <strong>一、windows环境下的安装</strong></p><pre><code>（1）下载并安装 Eralng配套软件中已提供otp_win64_20.2.exe （以管理员身份运行安装）（2）下载并安装rabbitmq配套软件中已提供rabbitmq-server-3.7.4.exe。双击安装，注意不要安装在包含    中文和空格的目录下！安装后window服务中就存在rabbitMQ了，并且是启动状态。（3）安装管理界面（插件）进入rabbitMQ安装目录的sbin目录，输入命令    rabbitmq‐plugins enable rabbitmq_management（4）重新启动服务（5）打开浏览器，地址栏输入http://127.0.0.1:15672 ,即可看到管理界面的登陆页</code></pre><p> <strong>二、docker容器中按照RabbitMQ</strong></p><pre><code>（1）拉去rabbitMQ镜像    docker pull rabbitmq:management（2）创建容器，rabbitmq需要有映射以下端口: 5671 5672 4369 15671 15672 25672    15672 (if management plugin is enabled)    15671 management监听端口    5672, 5671 (AMQP 0-9-1 without and with TLS)    4369 (epmd) epmd 代表 Erlang 端口映射守护进程    25672 (Erlang distribution)(3)启动容器:docker run -d --name=myrabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 15671:15671 -p 15672:15672 -p 25672:25672 d69a5113ceae</code></pre></li></ol><p><em>输入<a href="http://192.168.25.133:15672进入RabbitMQ登录页面" target="_blank" rel="noopener">http://192.168.25.133:15672进入RabbitMQ登录页面</a></em></p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/启动RabbitMq.png" alt="启动RabbitMq"><br></p><p><em>输入用户名和密码，都为guest 进入主界</em></p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/RabbitMq启动页面.png" alt="RabbitMq启动页面"><br></p><p><strong>最上侧的导航以此是：概览、连接、信道、交换器、队列、用户管理</strong></p><ol start="2"><li><p>直接模式(Direct)</p><pre><code>一、什么是Direct模式我们需要将消息发给唯一一个节点时使用这种模式，这是最简单的一种形式。任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。1.一般情况可以使用rabbitMQ自带的Exchange：&quot;&quot;(该Exchange的名字为空字符串，下文称其为default Exchange)。2.这种模式下不需要将Exchange进行任何绑定(binding)操作3.消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。4.如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。</code></pre></li></ol><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/直接模式Direct.png" alt="直接模式Direct"></p><pre><code>二、创建队列做下面的例子前，我们先建立一个叫myQue的队列Durability：是否做持久化 Durable（持久） transient（临时）Auto delete : 是否自动删除</code></pre><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/创建队列.png" alt="创建队列">    </p><pre><code>三、代码实现-消息生产者1.引入依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;2.编写配置文件application.ymlspring:  rabbitmq:    host: 192.168.25.1333.编写测试类@Autowiredprivate RabbitTemplate rabbitTemplate;@Testpublic void contextLoads() {    /**     * 第一个参数是队列名也就是routingKey     */    rabbitTemplate.convertAndSend(&quot;myQue&quot;,&quot;测试下直接模式(Direct)&quot;);}</code></pre><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/直接模式消息接收情况.png" alt="直接模式消息接收情况">    </p><pre><code>四、代码实现-消息消费者（1）编写消息消费者类@Component                            @RabbitListener(queues = &quot;myQue&quot;)public class Customer {    @RabbitHandler    public void showMessage(String msg){        System.out.println(&quot;myQue接收的消息:&quot;+msg);    }}    (2)运行启动类，可以在控制台看到刚才发送的消息</code></pre><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/消费者测试.png" alt="消费者测试"></p><p><strong>利用IDEA启用俩个消费者实例，在利用生产者发送消息，多次测试后发现俩个消费者实例收到消息的比例相同为1:1（负载均衡）</strong></p><ol start="2"><li><p>分列模式（Fanout）</p><pre><code>一、什么是分列（Fanout）模式当我们需要将消息一次发给多个队列时，需要使用这种模式。任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。1.可以理解为路由表的模式2.这种模式不需要RouteKey3.这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。4.如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。</code></pre></li></ol><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/分列模式图.png" alt="分列模式图"></p><p><strong>创建交换机</strong></p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/添加交换机.png" alt="添加交换机"></p><p><strong>绑定QUEUE</strong></p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/绑定Queue.png" alt="绑定Queue"></p><pre><code>二、代码实现---分列模式消息生产者     /**        *      * 分列模式(Fanout)      */    @Test    public void sendMsg2() {        /**         * 第一个参数是交换机名称，第二个队列名称是routingkey         */        rabbitTemplate.convertAndSend(&quot;huangsm&quot;,&quot;&quot;,&quot;测试分列模式(Fanout)&quot;);    }三、代码实现-分列模式消息消费者@Component@RabbitListener(queues = &quot;myQue2&quot;)public class Customer2 {    @RabbitHandler    public void showMessage(String msg){        System.out.println(&quot;myQue3接收的消息:&quot;+msg);    }}</code></pre><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/分列模式消息消费者.png" alt="分列模式消息消费者"></p><ol start="3"><li><p>主题模式（Topic）</p><pre><code>一、什么是主题模式任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上</code></pre></li></ol><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/topic模式.png" alt="topic模式">        </p><pre><code>由上图看出:此类交换器使得来自不同的源头的消息可以到达一个队列，其实说的更明白一点就是模糊匹配的意思，例如：上图中红色对列的routekey为usa.#，#代表匹配任意字符，但是要想消息能到达此对列，usa.必须匹配后面的#好可以随意。图中usa.newsusa.weather,都能找到红色队列，符号 # 匹配一个或多个词，符号 * 匹配不多不少一个词。因此 usa.# 能够匹配到 usa.news.XXX ，但是 usa.* 只会匹配到 usa.XXX 。注：交换器说到底是一个名称与队列绑定的列表。当消息发布到交换器时，实际上是由你所连接的信道，将消息路由键同交换器上绑定的列表进行比较，最后路由消息。任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上1.这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的队列。2.这种模式需要RouteKey，也许要提前绑定Exchange与Queue。3.在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。4.“#”表示0个或若干个关键字，“”表示一个关键字。如“log.”能与“log.warn”匹配，无法与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。5.同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息</code></pre><p><strong>创建队列与绑定</strong></p><p>（1）新建一个交换器 ，类型选择topic</p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/新建topic交换机.png" alt="新建topic交换机"></p><p>（2）点击新建的交换器topichuang,添加匹配规则，添加后列表如下：</p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/绑定routingkey.png" alt="绑定routingkey"></p><p><strong>消息生产者代码已经消费者测试结果</strong></p><pre><code>/** * 测试主题模式(topic)*/     @Test public void sendMsg3() {     /**      * 第一个参数是交换机名称，第二个队列名称是routingKey      */     rabbitTemplate.convertAndSend(&quot;topichuang&quot;,&quot;huang.aaa&quot;,&quot;aaa消息发送给谁呢&quot;); } /**  * 测试主题模式(topic)  */ @Test public void sendMsg4() {     /**      * 第一个参数是交换机名称，第二个队列名称是routingKey      */     rabbitTemplate.convertAndSend(&quot;topichuang&quot;,&quot;huang.log&quot;,&quot;huang.log消息发送给谁呢&quot;); } /**  * 测试主题模式(topic)  */ @Test public void sendMsg5() {     /**      * 第一个参数是交换机名称，第二个队列名称是routingKey      */     rabbitTemplate.convertAndSend(&quot;topichuang&quot;,&quot;log.ccc&quot;,&quot;ccc消息发送给谁呢&quot;); }</code></pre><p><em>Topic模式测试结果</em></p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/Topic模式测试结果.png" alt="Topic模式测试结果"></p><p><em>Topic模式流程图</em></p><p><img src="/2019/01/26/消息中间件RabbitMQ的使用以及基本概念/Rabbit主题模式.png" alt="Rabbit主题模式"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p><strong>这篇博客主要讲述RabbitMQ的一些概念和一些操作方式，下篇博客会介绍RabbitMQ的实战，开发一个用户微服务</strong></p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 主题模式Topic </tag>
            
            <tag> 直接模式Direct </tag>
            
            <tag> 分列模式（Fanout) </tag>
            
            <tag> AMQP </tag>
            
            <tag> Erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker下部署elasticsearch环境</title>
      <link href="/2019/01/25/docker%E4%B8%8B%E9%83%A8%E7%BD%B2elasticsearch%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/01/25/docker%E4%B8%8B%E9%83%A8%E7%BD%B2elasticsearch%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li>阿里云服务器</li><li>docker最新版环境</li></ol><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><h5 id="容器的创建与远程连接"><a href="#容器的创建与远程连接" class="headerlink" title="容器的创建与远程连接"></a>容器的创建与远程连接</h5><ul><li><p>下载镜像</p><pre><code>docker pull elasticsearch:5.6.8</code></pre></li><li><p>创建容器</p><pre><code>docker run -d --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; 6c0bdf761f3b</code></pre><p><strong>如果启动报错，通过docker logs es查看日志，如果错误是</strong></p><pre><code>Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x0000000085330000, 2060255232, 0) failed; error=’Cannot allocate memory’ (errno=12)</code></pre><p>因为这是由于elasticsearch5.0默认分配jvm空间大小为2g，内存不足以分配导致<br><strong>修改elasticsearch分配的jvm空间</strong></p><pre><code>find /var/lib/docker/overlay2/ -name jvm.optionsvim /var/lib/docker/overlay2/7f59cf980d035aa1f8e5275e4e64eb9ec9a775b0d62bacf94ee3d562b782c136/diff/etc/elasticsearch/jvm.options</code></pre><p><strong>最后重新启动即可</strong></p></li><li><p>测试</p><pre><code>输入http://192.168.25.133:9200/</code></pre><p><img src="/2019/01/25/docker下部署elasticsearch环境/es测试.png" alt="es测试"></p><pre><code>使用写好的搜索服务，改变elasticsearch服务器地址后启动测试报错:</code></pre><p><img src="/2019/01/25/docker下部署elasticsearch环境/es搜索服务启动报错.png" alt="es搜索服务启动报错"></p></li><li><p>进入容器</p><pre><code>一、输入命令docker exec es -it /bin/bash此时，我们看到elasticsearch所在的目录为/usr/share/elasticsearch,进入config看到了配置文件elasticsearch.yml我们通过vi命令编辑此文件，尴尬的是容器并没有vi命令 ，咋办？我们需要以文件挂载的方式创建容器才行，这样我们就可以通过修改宿主机中的某个文件来实现对容器内配置文件的修改二、拷贝配置文件到宿主机首先退出容器，然后执行命令： docker cp es:/usr/share/elasticsearch/config/elasticsearch.yml /usr/share/elasticsearch.yml三、停止和删除原来创建的容器docker stop esdocker rm es四、重新执行创建容器命令docker run -d --name=es -p 9200:9200 -p 9300:9300 -v /usr/share/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml elasticsearch:5.6.8五、修改/usr/share/elasticsearch.yml 将 transport.host: 0.0.0.0 前的#去掉后保存文件退出。其作用是允许任何ip地址访问elasticsearch开发测试阶段可以这么做，生产环境下指定具体的IP</code></pre><p><img src="/2019/01/25/docker下部署elasticsearch环境/解决docker容器中部署的跨域问题.png" alt="解决docker容器中部署的跨域问题"></p></li><li><p>重启启动</p><p>  docker restart es<br><strong>重新启动失败怎么办?</strong></p><pre><code>重启后发现重启启动失败了，这时什么原因呢？这与我们刚才修改的配置有关，因为elasticsearch在启动的时候会进行一些检查，比如最多打开的文件的个数以及虚拟内存区域数量等等，如果你放开了此配置，意味着需要打开更多的文件以及虚拟内存，所以我们还需要系统调优。</code></pre></li><li>系统调优(宿主机问题)</li></ul><p><em>我们一共需要修改两处</em></p><pre><code>第一步:修改/etc/security/limits.conf 配置文件,追加* soft nofile 65536* hard nofile 655nofile是单个进程允许打开的最大文件个数 soft nofile 是软限制 hard nofile是硬限制第二步:修改/etc/sysctl.conf，追加内容vm.max_map_count=655360限制一个进程可以拥有的VMA(虚拟内存区域)的数量执行下面命令 修改内核参数马上生效</code></pre><ul><li>安装IK分词器</li></ul><p>（1）快捷键alt+p进入sftp , 将ik文件夹上传至宿主机</p><pre><code>put -r  D:\friendprojec\elasticsearch-5.6.8\plugins\ik</code></pre><p>（2）在宿主机中将ik文件夹拷贝到容器内 /usr/share/elasticsearch/plugins 目录下。</p><pre><code>docker cp ik es:/usr/share/elasticsearch/plugins/</code></pre><p>（3）重启容器</p><ul><li>HEAD插件安装</li></ul><p>（1）修改/usr/share/elasticsearch.yml ,添加允许跨域配置</p><pre><code>http.cors.enabled: truehttp.cors.allow‐origin: &quot;*&quot;</code></pre><p>（2）重新启动elasticseach容器<br>（3）下载head镜像</p><pre><code>docker pull mobz/elasticsearch‐head:5</code></pre><p>（4）创建head容器</p><pre><code>docker run ‐di ‐‐name=myhead ‐p 9100:9100  mobz/elasticsearch‐head:5</code></pre><p><strong>这样我们在docker中部署elasticsearch就完成了</strong></p>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
            <tag> docker </tag>
            
            <tag> head </tag>
            
            <tag> IK </tag>
            
            <tag> docker系统优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Logstash同步ElasticSearch与Mysql数据</title>
      <link href="/2019/01/24/%E4%BD%BF%E7%94%A8Logstash%E5%90%8C%E6%AD%A5ElasticSearch%E4%B8%8EMysql%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/01/24/%E4%BD%BF%E7%94%A8Logstash%E5%90%8C%E6%AD%A5ElasticSearch%E4%B8%8EMysql%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="ElasticSearch与MYSQL数据库的同步-使用logstash"><a href="#ElasticSearch与MYSQL数据库的同步-使用logstash" class="headerlink" title="ElasticSearch与MYSQL数据库的同步(使用logstash)"></a>ElasticSearch与MYSQL数据库的同步(使用logstash)</h3><ol><li><p>概述</p><pre><code>Logstash是一款轻量级的日志搜集处理框架，可以方便的把分散的、多样化的日志搜集起来，并进行自定义的理，然后传输到指定的位置，比如某个服务器或者文件。</code></pre></li><li><p>Logstash的安装和测试</p><pre><code>解压，进入bin目录logstash ‐e &apos;input { stdin { } } output { stdout {} }&apos;控制台输入字符，随后就有日志输出stdin，表示输入流，指从键盘输入stdout，表示输出流，指从显示器输出命令行参数:-e 执行--config 或 -f 配置文件，后跟参数类型可以是一个字符串的配置或全路径文件名或全路径(如：/etc/logstash.d/，logstash会自动读取/etc/logstash.d/目录下所有*.conf 的文本文件，然后在自己内存里拼接成一个完整的大配置文件再去执行)</code></pre><p><img src="/2019/01/24/使用Logstash同步ElasticSearch与Mysql数据/启动logstash.png" alt="日志输出"></p></li><li><p>MySQL数据导入Elasticsearch</p><pre><code>第一步:    在logstansh根目录下创建mysqletc(名称任意)目录，目录中创建mysql.conf（名字任意）文件，已经mysql的驱动jar包第二步: 编写mysql.conf文件input {  jdbc {      # mysql jdbc connection string to our backup databse      jdbc_connection_string =&gt; &quot;jdbc:mysql://47.107.44.169:33061/tensquare_article?characterEncoding=UTF8&quot;      # the user we wish to excute our statement as      jdbc_user =&gt; &quot;root&quot;      jdbc_password =&gt; &quot;123456&quot;      # the path to our downloaded jdbc driver        jdbc_driver_library =&gt; &quot;D:\friendprojec\logstash-5.6.8\mysqletc\mysql-connector-java-5.1.46.jar&quot;      # the name of the driver class for mysql      jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;      jdbc_paging_enabled =&gt; &quot;true&quot;      jdbc_page_size =&gt; &quot;50&quot;      #以下对应着要执行的sql的绝对路径。      #statement_filepath =&gt; &quot;&quot;      statement =&gt; &quot;SELECT  id,title,content,state FROM tb_article&quot;      #定时字段 各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为每分钟都更新（测试结果，不同的话请留言指出）      schedule =&gt; &quot;* * * * *&quot;  }}output {  elasticsearch {      #ESIP地址与端口      hosts =&gt; &quot;127.0.0.1:9200&quot;       #ES索引名称（自己定义的）      index =&gt; &quot;tensquare_article&quot;      #自增ID编号      document_id =&gt; &quot;%{id}&quot;      document_type =&gt; &quot;article&quot;  }  stdout {      #以JSON格式输出      codec =&gt; json_lines  }}第三步: 启动logstansh，用-f的方式logstash -f ../mysqletc/mysql.conf</code></pre><p><strong>注意mysql.conf路径为相对路径</strong><br><img src="/2019/01/24/使用Logstash同步ElasticSearch与Mysql数据/同步数据库成功.png" alt="同步数据库成功"><br><br></p><h3 id="logstansh一些注意的问题"><a href="#logstansh一些注意的问题" class="headerlink" title="logstansh一些注意的问题"></a>logstansh一些注意的问题</h3></li><li>logstansh支持多数据库同步ElasticSearch</li></ol><p><strong>这就是logstansh同步数据库的基础使用，也可以部署logstansh集群配合kafka或redis做到缓存同步效果</strong></p>]]></content>
      
      
      <categories>
          
          <category> Logstash </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> Logstash </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch基础入门及搜索服务的开发</title>
      <link href="/2019/01/23/ElasticSearch%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%8F%8A%E6%90%9C%E7%B4%A2%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%BC%80%E5%8F%91/"/>
      <url>/2019/01/23/ElasticSearch%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%8F%8A%E6%90%9C%E7%B4%A2%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h3 id="什么是ElasticSearch"><a href="#什么是ElasticSearch" class="headerlink" title="什么是ElasticSearch"></a>什么是ElasticSearch</h3><pre><code>Elasticsearch是一个实时的分布式搜索和分析引擎。它可以帮助你用前所未有的速度去处理大规模数据。ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</code></pre><h3 id="ElasticSearch特点"><a href="#ElasticSearch特点" class="headerlink" title="ElasticSearch特点"></a>ElasticSearch特点</h3><pre><code>（1）可以作为一个大型分布式集群（数百台服务器）技术，处理PB级数据，服务大公司；也可以运行在单机上（2）将全文检索、数据分析以及分布式技术，合并在了一起，才形成了独一无二的ES；（3）开箱即用的，部署简单（4）全文检索，同义词处理，相关度排名，复杂数据分析，海量数据的近实时</code></pre><h3 id="ElasticSearch体系结构"><a href="#ElasticSearch体系结构" class="headerlink" title="ElasticSearch体系结构"></a>ElasticSearch体系结构</h3><p><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/体系结构.png" alt="ElasticSearch体系结构"></p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h3 id="ElasticSearch部署与启动"><a href="#ElasticSearch部署与启动" class="headerlink" title="ElasticSearch部署与启动"></a>ElasticSearch部署与启动</h3><ol><li><p>下载ElasticSearch 5.6.8版本</p><pre><code>https://www.elastic.co/downloads/past-releases/elasticsearch-5-6-8</code></pre></li><li><p>在命令提示符下，进入ElasticSearch安装目录下的bin目录,执行命令即可启动。</p><pre><code>我们打开浏览器，在地址栏输入http://127.0.0.1:9200/ 即可看到输出结果</code></pre><p><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/ElasticSearch启动成功.png" alt="ElasticSearch启动成功"></p><h1 id="不同操作方式使用ElasticSearch"><a href="#不同操作方式使用ElasticSearch" class="headerlink" title="不同操作方式使用ElasticSearch"></a>不同操作方式使用ElasticSearch</h1><h3 id="通过PostMan使用RestFul风格操作ElasticSearch"><a href="#通过PostMan使用RestFul风格操作ElasticSearch" class="headerlink" title="通过PostMan使用RestFul风格操作ElasticSearch"></a>通过PostMan使用RestFul风格操作ElasticSearch</h3></li><li><p>新建索引库<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/Restful新建索引库.png" alt="Restful新建索引库"></p></li><li><p>新建文档<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/Restful新建文档.png" alt="Restful新建文档"></p></li><li>查询全部文档<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/Restful查询所有.png" alt="Restful查询所有"></li><li>修改文档<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/Restful修改文档.png" alt="Restful修改文档"><br><br><br><strong>如果ID不存在则重新创建</strong></li><li>按ID查询文档<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/RestFul根据ID查询.png" alt="RestFul根据ID查询"></li><li>基本匹配查询<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/RestFul基本查询.png" alt="RestFul基本查询"></li><li>模糊查询<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/Restful模糊查询.png" alt="Restful模糊查询"></li><li>删除文档<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/RestFul删除文档.png" alt="RestFul删除文档"><h3 id="Head插件方式操控ElasticSearch"><a href="#Head插件方式操控ElasticSearch" class="headerlink" title="Head插件方式操控ElasticSearch"></a>Head插件方式操控ElasticSearch</h3><h4 id="安装head"><a href="#安装head" class="headerlink" title="安装head"></a>安装head</h4></li><li><p>下载head插件</p><pre><code>https://github.com/mobz/elasticsearch-head</code></pre></li><li>解压到任意目录，但是要和elasticsearch的安装目录区别开</li><li><p>按照node js，按照cnpm</p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre></li><li><p>将grunt安装为全局命令 。Grunt是基于Node.js的项目构建工具。它可以自动运行你所设定的任务</p><pre><code>npm install ‐g grunt‐cli</code></pre></li><li><p>安装依赖</p><pre><code>cnpm install</code></pre></li><li><p>进入head目录启动head，在命令提示符下输入命令</p><pre><code>grunt server</code></pre></li><li>打开浏览器，输入 <a href="http://localhost:9100" target="_blank" rel="noopener">http://localhost:9100</a></li><li><p>点击连接按钮没有任何相应，按F12发现有如下错误</p><pre><code>No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resour这个错误是由于elasticsearch默认不允许跨域调用，而elasticsearch-head是属于前端工程，所以报错。我们这时需要修改elasticsearch的配置，让其允许跨域访问。修改elasticsearch配置文件：elasticsearch.yml，增加以下两句命令：http.cors.enabled: truehttp.cors.allow‐origin: &quot;*&quot;此步为允许elasticsearch跨越访问 点击连接即可看到相关信息</code></pre><p><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/head连接elasticSearch.png" alt="head连接elasticSearch"></p><h3 id="IK分词器的使用"><a href="#IK分词器的使用" class="headerlink" title="IK分词器的使用"></a>IK分词器的使用</h3></li><li><p>安装IK分词器<br>下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/releases</a> 下载5.6.8版<br>本 </p><pre><code>（1）先将其解压，将解压后的elasticsearch文件夹重命名文件夹为ik（2）将ik文件夹拷贝到elasticsearch/plugins 目录下。（3）重新启动，即可加载IK分词器</code></pre></li><li><p>IK分词器测试<br>IK提供了两个分词算法ik_smart 和 ik_max_word其中ik_smart为最少切分，ik_max_word为最细粒度划分<br>我们分别来试一下</p><pre><code>（1）最小切分：在浏览器地址栏输入地址http://127.0.0.1:9200/_analyze?analyzer=ik_smart&amp;pretty=true&amp;text=我是中国程序员输出的结果为：</code></pre><p><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/IK最小切分算法.png" alt="IK最小切分算法"></p><pre><code>（2）最细切分：在浏览器地址栏输入地址http://127.0.0.1:9200/_analyze?analyzer=ik_max_word&amp;pretty=true&amp;text=我是中国程序员输出结果为:</code></pre><p><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/IK最细切分算法.png" alt="IK最细切分算法"></p></li><li><p>IK自定义词库<br>步骤：</p><pre><code>（1）进入elasticsearch/plugins/ik/config目录（2）新建一个my.dic文件，编辑内容（3）修改IKAnalyzer.cfg.xml（在ik/config目录下）,然后重启elasticsearch服务</code></pre><p><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/IK自定义词库.png" alt="IK自定义词库"><br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/IK配置自定义词库.png" alt="IK配置自定义词库"><br><br><br><strong>注意my.dic文件需要存储为UTF-8无BOM格式</strong></p><h3 id="JAVA操作ElasticSearch"><a href="#JAVA操作ElasticSearch" class="headerlink" title="JAVA操作ElasticSearch"></a>JAVA操作ElasticSearch</h3></li><li>关于索引库文档类概念<ul><li>是否索引，就是看该域是否能被搜索</li><li>是否分词，就表示搜索的时候是整体匹配还是单词匹配，如果不分词的话代表整句匹配</li><li>是否存储，就是是否在页面上显示</li></ul></li><li><p>引入依赖和修改配置文件</p><pre><code> &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;修改配置文件:spring:  data:    elasticsearch:      cluster-nodes: localhost:9300</code></pre></li><li><p>创建索引文档类</p><pre><code>/** * SpringDataElasticSearch索引库文档类 * indexName 索引库名称 * type 数据库类型 * @author huangsm */@Document(indexName = &quot;tensquare_article&quot;,type = &quot;article&quot;)@Datapublic class Article implements Serializable {    @Id    private String id;    /**     * index 是否索引，就是看该域是否能被搜索     * 是否分词，就表示搜索的时候是整体匹配还是单词匹配，如果不分词的话代表整句匹配     * 是否存储，就是是否在页面上显示     */    @Field(index = true,    analyzer = &quot;ik_smart&quot;,searchAnalyzer = &quot;ik_smart&quot;)    private String title;    @Field(index = true,            analyzer = &quot;ik_smart&quot;,searchAnalyzer = &quot;ik_smart&quot;)    private String content;    /**     * 审核状态     */    private String state;}</code></pre></li><li>编写文章持久层</li></ol><pre><code>public interface ArticleSearchDao extends ElasticsearchRepository&lt;Article,String&gt; {    /**     * 检索     * @param title     * @param content     * @param pageable     * @return     */    public Page&lt;Article&gt;findByTitleOrContentLike(String title,                                                 String content, Pageable pageable);}</code></pre><ol start="5"><li>编写业务层</li></ol><pre><code>/** * 文章搜索业务 * @author huangsm */@Servicepublic class ArticleSearchService {    @Autowired    private ArticleSearchDao articleSearchDao;    @Autowired    private IdWorker idWorker;    /**     * 增加文章     * @param article     */    public void add(Article article){        article.setId(idWorker.nextId()+&quot;&quot;);        articleSearchDao.save(article);    }    public Page&lt;Article&gt;findByTitleLike(String keywords,int page,int size){        PageRequest pageRequest = PageRequest.of(page - 1, size);        return articleSearchDao.findByTitleOrContentLike(keywords,keywords,pageRequest);    }}</code></pre><ol start="6"><li>编写控制层</li></ol><pre><code>/** * 搜索controller * * @author huangsm */@RestController@CrossOrigin@RequestMapping(&quot;/article&quot;)public class ArticleController {    @Autowired    private ArticleSearchService articleSearchService;    @PostMapping(&quot;/&quot;)    public Result save(@RequestBody Article article) {        articleSearchService.add(article);        return new Result(true, StatusCode.OK, &quot;操作成功&quot;);    }    @GetMapping(value = &quot;/search/{keywords}/{page}/{size}&quot;)    public Result findByTitleLike(@PathVariable(&quot;keywords&quot;) String keywords,                                  @PathVariable(&quot;page&quot;) int page, @PathVariable(&quot;size&quot;) int size) {        Page&lt;Article&gt; pageData = articleSearchService.findByTitleLike(keywords, page, size);        return new Result(true, StatusCode.OK, &quot;查询成功&quot;, new PageResult&lt;Article&gt;(pageData.getTotalElements(), pageData.getContent()));    }}</code></pre><ol start="7"><li>测试<br><img src="/2019/01/23/ElasticSearch基础入门及搜索服务的开发/测试搜索.png" alt="测试搜索"></li></ol><h3 id="ElasticSearch和Solr的对比"><a href="#ElasticSearch和Solr的对比" class="headerlink" title="ElasticSearch和Solr的对比"></a>ElasticSearch和Solr的对比</h3><p><a href="https://www.cnblogs.com/chowmin/articles/4629220.html" target="_blank" rel="noopener">ES和Solr的对比</a></p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringData </tag>
            
            <tag> head </tag>
            
            <tag> ElasticSearch </tag>
            
            <tag> IK分词器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringDataMongoDB的基本使用及服务开发</title>
      <link href="/2019/01/23/SpringDataMongoDB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
      <url>/2019/01/23/SpringDataMongoDB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringDataMongoDb概述"><a href="#SpringDataMongoDb概述" class="headerlink" title="SpringDataMongoDb概述"></a>SpringDataMongoDb概述</h1><p> <em>SpringData家族成员之一，用于操作MongoDb的持久层框架，封装了底层的mongodb-driver</em></p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li>引入依赖</li></ol><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;  &lt;/dependency&gt;</code></pre><ol start="2"><li>配置application.yml配置文件</li></ol><pre><code>spring:  data:    mongodb:      host: ip地址      database: 数据库名称</code></pre><ol start="3"><li><p>通过IOC注入SpringDataMongoDB封装的模版</p><pre><code>在业务层注入：   @Autowiredprivate MongoTemplate mongoTemplate;//根据id，修改huangsm表下的num字段，每次加1，代码如下Query query = new Query();query.addCriteria(Criteria.where(&quot;_id&quot;).is(id));Update update = new Update();update.inc(&quot;num&quot;, 1);mongoTemplate.updateFirst(query, update, &quot;huangsm&quot;);</code></pre></li></ol><h2 id="关于服务开发"><a href="#关于服务开发" class="headerlink" title="关于服务开发"></a>关于服务开发</h2><p><strong>首先引入依赖，配置配置文件，然后引入MongoDB模版，剩余操作参考根据业务来选择SpringDataMongoDB提供的API来完成业务。本文只是一个简单的入门，更为详细建议参考官方文档，其实笔者认为MongoDB主要使用与数据价值低而且数据量大的场景，掌握常用的CURD就可以玩转Java中MongoDB的使用了，SpringDataMongoDb是个不错的操作MongoDb的框架，推荐。</strong></p>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> NOSQL </tag>
            
            <tag> SpringData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简述HTTP和RPC的优缺点</title>
      <link href="/2019/01/20/%E7%AE%80%E8%BF%B0HTTP%E5%92%8CRPC%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
      <url>/2019/01/20/%E7%AE%80%E8%BF%B0HTTP%E5%92%8CRPC%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p><em>在HTTP和RPC的选择上，可能有些人是迷惑的，主要是因为，有些RPC框架配置复杂，如果走HTTP也能完成同样的功能，那么为什么要选择RPC，而不是更容易上手的HTTP来实现了。</em></p><p><strong>本文主要来阐述HTTP和RPC的异同，让大家更容易根据自己的实际情况选择更适合的方案。</strong></p><ul><li><p>传输协议</p><pre><code>RPC，可以基于TCP协议，也可以基于HTTP协议HTTP，基于HTTP协议</code></pre></li><li><p>传输效率</p><pre><code>RPC，使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率HTTP，如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理</code></pre></li><li><p>性能消耗，主要在于序列化和反序列化的耗时</p><pre><code>RPC，可以基于thrift实现高效的二进制传输HTTP，大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能</code></pre></li><li><p>负载均衡</p><pre><code>RPC，基本都自带了负载均衡策略HTTP，需要配置Nginx，HAProxy来实现</code></pre></li><li><p>服务治理（下游服务新增，重启，下线时如何不影响上游调用者）</p><pre><code>RPC，能做到自动通知，不影响上游HTTP，需要事先通知，修改Nginx/HAProxy配置</code></pre></li></ul><p>总结：</p><p>  RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。</p><ul><li>博客地址: <a href="https://www.babywang.huangsm.xyz">https://www.babywang.huangsm.xyz</a></li><li>Git地址: <a href="https://github.com/babybabywang" target="_blank" rel="noopener">https://github.com/babybabywang</a></li><li>码云地址: <a href="https://gitee.com/wangyuanbaby" target="_blank" rel="noopener">https://gitee.com/wangyuanbaby</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务发现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Dubbo </tag>
            
            <tag> HTTP </tag>
            
            <tag> RPC </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB的基本使用姿势及概念</title>
      <link href="/2019/01/20/MongoDB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%8F%8A%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/01/20/MongoDB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%8F%8A%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="文档型数据库MongoDB"><a href="#文档型数据库MongoDB" class="headerlink" title="文档型数据库MongoDB"></a>文档型数据库MongoDB</h1><h2 id="MongoDB的特点和体系结构"><a href="#MongoDB的特点和体系结构" class="headerlink" title="MongoDB的特点和体系结构"></a>MongoDB的特点和体系结构</h2><h4 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h4><pre><code>1. 什么是MongoDB  MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热门的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似 JSON的 BSON 格式，因此可以存储比较复杂的数据类型。MongoDB 的官方网站地址是：http://www.mongodb.or2. MongoDB特点  MongoDB 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。它是一个面向集合的,模式自由的文档型数据库。具体特点总结如下：（1）面向集合存储，易于存储对象类型的数据（2）模式自由（3）支持动态查询（4）支持完全索引，包含内部对象（5）支持复制和故障恢复（6）使用高效的二进制数据存储，包括大型对象（如视频等）（7）自动处理碎片，以支持云计算层次的扩展性（8）支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++语言的驱动程序，社区中也提供了对 Erlang 及.NET 等平台的驱动程序（9） 文件存储格式为 BSON（一种 JSON 的扩展）3. 什么时候使用MongoDB（1）数据量大（2）写入操作频繁（3）价值较低对于这样的数据，我们更适合使用MongoDB来实现数据的4. MongoDB体系结构MongoDB 的逻辑结构是一种层次结构。主要由：文档(document)、集合(collection)、数据库(database)这三部分组成的。逻辑结构是面向用户的，用户使用 MongoDB 开发应用程序使用的就是逻辑结构。（1）MongoDB 的文档（document），相当于关系数据库中的一行记录。（2）多个文档组成一个集合（collection），相当于关系数据库的表。（3）多个集合（collection），逻辑上组织在一起，就是数据库（database）。（4）一个 MongoDB 实例支持多个数据库（database）。5. 数据类型基本数据类型null：用于表示空值或者不存在的字段，{“x”:null}布尔型：布尔类型有两个值true和false，{“x”:true}数值：shell默认使用64为浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用NumberInt（4字节符号整数）或NumberLong（8字节符号整数），{“x”:NumberInt(“3”)}{“x”:NumberLong(“3”)}字符串：UTF-8字符串都可以表示为字符串类型的数据，{“x”：“呵呵”}日期：日期被存储为自新纪元依赖经过的毫秒数，不存储时区，{“x”:new Date()}正则表达式：查询时，使用正则表达式作为限定条件，语法与JavaScript的正则表达式相同，{“x”:/[abc]/}数组：数据列表或数据集可以表示为数组，{“x”： [“a“，“b”,”c”]}内嵌文档：文档可以嵌套其他文档，被嵌套的文档作为值来处理，{“x”:{“y”:3 }}对象Id：对象id是一个12字节的字符串，是文档的唯一标识，{“x”: objectId() }二进制数据：二进制数据是一个任意字节的字符串。它不能直接在shell中使用。如果要将非utf-字符保存到数据库中，二进制数据是唯一的方式。代码：查询和文档中可以包括任何JavaScript代码，{“x”:function(){/…/</code></pre><p><strong>Mysql和MongoDB的区别:</strong><br><img src="/2019/01/20/MongoDB的基本使用姿势及概念/mongodb和mysql对比.png" alt="命令1"></p><h2 id="常用的MongoDB命令"><a href="#常用的MongoDB命令" class="headerlink" title="常用的MongoDB命令"></a>常用的MongoDB命令</h2><ol><li>首先说下Windows端mongodb的启动<ol><li>md e:/data</li><li>mongod –dbpath=e:/data</li><li>在b端cmd中输入 mongo即可启动</li></ol></li><li>docker中安装mongoDB<ol><li>拉取镜像<br>docker pull mongo</li><li>启动容器<br>docker run -d –name mymongodb -p 27017:27017 mongo</li></ol></li><li>常用的MongoDB命令<br><img src="/2019/01/20/MongoDB的基本使用姿势及概念/ml1.png" alt="命令1"><br><img src="/2019/01/20/MongoDB的基本使用姿势及概念/ml2.png" alt="命令2"><br><img src="/2019/01/20/MongoDB的基本使用姿势及概念/ml3.png" alt="命令3"><br><img src="/2019/01/20/MongoDB的基本使用姿势及概念/ml4.png" alt="命令4"><br><img src="/2019/01/20/MongoDB的基本使用姿势及概念/ml5.png" alt="命令5"></li></ol><h2 id="使用JAVA操作MongoDB"><a href="#使用JAVA操作MongoDB" class="headerlink" title="使用JAVA操作MongoDB"></a>使用JAVA操作MongoDB</h2><p><em>mongodb-driver是mongo官方推出的java连接mongoDB的驱动包，相当于JDBC驱动。我们通过一个入门的案例来了解mongodb-driver的基本</em></p><ol><li><p>引入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.mongodb&lt;/groupId&gt;    &lt;artifactId&gt;mongodb‐driver&lt;artifactId&gt;    &lt;version&gt;3.6.3&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>测试</p><pre><code>1. 查询全部数据/** * 测试Java操作mongoDb * @author huangsm */public class MongoDbDemo {    /**     * 查询mongodb中全部数据     * @param args     */    public static void main(String[] args) {        //创建连接        MongoClient mongoClient = new MongoClient(&quot;47.107.44.169&quot;);        //打开数据库        MongoDatabase spitdb = mongoClient.getDatabase(&quot;spitdb&quot;);        //获取集合        MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;);        //查询记录获取文档集合        FindIterable&lt;Document&gt; documents = spit.find();        for (Document document : documents) {            System.out.println(&quot;内容:&quot;+document.getString(&quot;content&quot;));            System.out.println(&quot;访客:&quot;+document.getInteger(&quot;visits&quot;));        }        mongoClient.close();    }}2. 条件查询/** * 测试条件查询 * @author huangsm */public class MongoDbDemo1 {    /**     * 根据条件查询     * BasicDBObject对象：表示一个具体的记录，BasicDBObject实现了DBObject，是keyvalue的数据结构，用起来和HashMap是基本一致的。     * @param args     */    public static void main(String[] args) {        //创建连接        MongoClient mongoClient = new MongoClient(&quot;47.107.44.169&quot;);        //打开数据库        MongoDatabase spitdb = mongoClient.getDatabase(&quot;spitdb&quot;);        //获取集合        MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;);        BasicDBObject basicDBObject=new BasicDBObject(&quot;_id&quot;,&quot;ObjectId(\&quot;5c446ba292035401c76895f0\&quot;)&quot;);        //查询记录获取文档集合        FindIterable&lt;Document&gt; documents = spit.find();        for (Document document : documents) {            System.out.println(&quot;id:&quot;+document.getObjectId(&quot;_id&quot;));            System.out.println(&quot;内容:&quot;+document.getString(&quot;content&quot;));            System.out.println(&quot;访客:&quot;+document.getInteger(&quot;visits&quot;));        }        mongoClient.close();    }}3. 插入数据/** * 插入数据 * @author huangsm */public class MongoDbDemo2 {    /**     * 插入数据     * @param args     */    public static void main(String[] args) {        //创建连接        MongoClient mongoClient = new MongoClient(&quot;47.107.44.169&quot;);        //打开数据库        MongoDatabase spitdb = mongoClient.getDatabase(&quot;spitdb&quot;);        //获取集合        MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;);        HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(&quot;content&quot;,&quot;git&quot;);        map.put(&quot;userId&quot;,&quot;222&quot;);        map.put(&quot;visits&quot;,123);        Document document = new Document(map);        spit.insertOne(document);        mongoClient.close();    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li></ol><p><strong>总的来说MongoDB是一款非关系性的文档数据库，它适合存储那种存储价值低而且数据量大的数据。总的来说操作起来也是否的便捷，下篇文章我会使用SpringDataMongoDB来开发一个微服务。</strong></p>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> JAVA操作 </tag>
            
            <tag> NOSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于吞吐量(TPS)、QPS、并发数、响应时间(RT)的概念</title>
      <link href="/2019/01/19/%E5%85%B3%E4%BA%8E%E5%90%9E%E5%90%90%E9%87%8F-TPS-%E3%80%81QPS%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4-RT-%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/01/19/%E5%85%B3%E4%BA%8E%E5%90%9E%E5%90%90%E9%87%8F-TPS-%E3%80%81QPS%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4-RT-%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><pre><code>因为开发的原因，需要对吞吐量（TPS）、QPS、并发数、响应时间（RT）几个概念做下了解，查自百度百科，记录如下：</code></pre><h3 id="1-响应时间-RT"><a href="#1-响应时间-RT" class="headerlink" title="1.响应时间(RT)"></a>1.响应时间(RT)</h3><p><br></p><blockquote><p>   <em>响应时间是指系统对请求作出响应的时间。</em>直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时<br>间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间&gt;也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论&gt;其平均响应时间和最大响应时间。</p></blockquote><pre><code>对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个游戏软件来说，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。 </code></pre><h3 id="2-吞吐量-TPS"><a href="#2-吞吐量-TPS" class="headerlink" title="2.吞吐量(TPS)"></a>2.吞吐量(TPS)</h3><blockquote><p><strong>吞吐量是指系统在单位时间内处理请求的数量。</strong>对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间（或者系统响应时间和应用延迟时间）可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。 </p></blockquote><h3 id="3-并发数"><a href="#3-并发数" class="headerlink" title="3.并发数"></a>3.并发数</h3><blockquote><p><strong>并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。</strong>与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。实际上，并发用户数是一个非常不准确的指标，因为用户不同的使用模式会导致不同用户在单位时间发出不同数量的请求。一网站系统为例，假设用户只有注册后才能使用，但注册用户并不是每时每刻都在使用该网站，因此具体一个时刻只有部分注册用户同时在线，在线用户就在浏览网站时会花很多时间阅读网站上的信息，因而具体一个时刻只有部分在线用户同时向系统发出请求。这样，对于网站系统我们会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数。由于注册用户可能长时间不登陆网站，使用注册用户数作为性能指标会造成很大的误差。而在线用户数和同事发请求用户数都可以作为性能指标。相比而言，以在线用户作为性能指标更直观些，而以同时发请求用户数作为性能指标更准确些。 </p></blockquote><h3 id="4-QPS每秒查询率-Query-Per-Second"><a href="#4-QPS每秒查询率-Query-Per-Second" class="headerlink" title="4.QPS每秒查询率(Query Per Second)"></a>4.QPS每秒查询率(Query Per Second)</h3><p>　&gt;每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 （看来是类似于TPS，只是应用于特定场景的吞吐量）</p>]]></content>
      
      
      <categories>
          
          <category> 系统概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统概述 </tag>
            
            <tag> 概念分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RateLimiter配合注解的使用</title>
      <link href="/2019/01/19/RateLimiter%E9%85%8D%E5%90%88%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/01/19/RateLimiter%E9%85%8D%E5%90%88%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="首先我们来了解下什么是RateLimiter"><a href="#首先我们来了解下什么是RateLimiter" class="headerlink" title="首先我们来了解下什么是RateLimiter"></a>首先我们来了解下什么是RateLimiter</h1><blockquote><p>RateLimiter 从概念上来讲，速率限制器会在可配置的速率下分配许可证。如果必要的话，每个acquire() 会阻塞当前线程直到许可证可用后获<br>取该许可证。一旦获取到许可证，不需要再释放许可证。<br><br><br><em>校对注：RateLimiter使用的是一种叫令牌桶的流控算法，RateLimiter会按照一定的频率往桶里扔令牌，线程拿到令牌才能执行，比如你希望自己的应用程序QPS不要超过1000，那么RateLimiter设置1000的速率后，就会每秒往桶里扔1000个令牌。</em><br><br><br><img src="/2019/01/19/RateLimiter配合注解的使用/令牌桶算法.png" alt="令牌桶算法"><br><br><br>    RateLimiter经常用于限制对一些物理资源或者逻辑资源的访问速率。与Semaphore 相比，Semaphore 限制了并发访问的数量而不是使用速率。（注意尽管并发性和速率是紧密相关的，比如参考Little定律）</p></blockquote><blockquote><p>通过设置许可证的速率来定义RateLimiter。在默认配置下，许可证会在固定的速率下被分配，速率单位是每秒多少个许可证。为了确保维护配<br>置的速率，许可会被平稳地分配，许可之间的延迟会做调整。<br>可能存在配置一个拥有预热期的RateLimiter 的情况，在这段时间内，每秒分配的许可数会稳定地增长直到达到稳定的速率。<br>举例来说明如何使用RateLimiter，想象下我们需要处理一个任务列表，但我们不希望每秒的任务提交超过两个：</p></blockquote><pre><code>//速率是每秒两个许可final RateLimiter rateLimiter = RateLimiter.create(2.0);void submitTasks(List tasks, Executor executor) {    for (Runnable task : tasks) {        rateLimiter.acquire(); // 也许需要等待        executor.execute(task);   }}</code></pre><h1 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h1><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><p>引入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;    &lt;version&gt;25.1-jre&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.28&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>创建自定义注解</p><pre><code>import java.lang.annotation.*;/** * 自定义RateLimiter限流注解 * @author huang * @PACKAGE_NAME cn.huangsm.advance.ratelimiter * @PROJECT_NAME advance-code * @date 2019/1/19 */@Inherited@Documented@Target({ElementType.METHOD,ElementType.FIELD,ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)public @interface RateLimitAspect {}</code></pre></li><li><p>自定义切面类解析自定义注解</p></li></ol><pre><code>import com.alibaba.fastjson.JSON;import com.google.common.util.concurrent.RateLimiter;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 自定义切面类解析注解 * * @author huang * @PACKAGE_NAME cn.huangsm.advance.ratelimiter.aop * @PROJECT_NAME advance-code * @date 2019/1/19 */@Component@Aspect@Scope@Slf4jpublic class RateLimitAop {    @Autowired    private HttpServletResponse response;    /**     * 需要处理一个任务列表，但我们不希望每秒的任务提交超过五个     */    private RateLimiter rateLimiter = RateLimiter.create(5.0);    @Pointcut(&quot;@annotation(cn.huangsm.advance.ratelimiter.RateLimitAspect)&quot;)    public void rateLimiterPointCut() {    }    ;    @Around(&quot;rateLimiterPointCut()&quot;)    public Object around(ProceedingJoinPoint joinPoint) {        /**         * 得到令牌         */        Boolean flag = rateLimiter.tryAcquire();        Object obj = null;        try {            if (flag) {                obj = joinPoint.proceed();                log.info(&quot;得到令牌!&quot;);            } else {                String result = JSON.toJSONString(&quot;抱歉，操作过于频繁，请稍等片刻在操作！&quot;);                log.info(&quot;未获得令牌!&quot;);                output(response, result);            }        } catch (Throwable e) {            e.printStackTrace();        }        System.out.println(&quot;是否得到令牌=&quot; + flag + &quot;,参数=&quot; + obj);        return obj;    }    public void output(HttpServletResponse response, String msg) throws IOException {        response.setContentType(&quot;application/json;charset=UTF-8&quot;);        ServletOutputStream outputStream = null;        try {            outputStream = response.getOutputStream();            outputStream.write(msg.getBytes(&quot;UTF-8&quot;));        } catch (IOException e) {            e.printStackTrace();        } finally {            outputStream.flush();            outputStream.close();        }    }}</code></pre><ol start="4"><li>测试Controller类</li></ol><pre><code>/** * 限流测试 * @author huang * @PACKAGE_NAME cn.huangsm.advance.ratelimiter * @PROJECT_NAME advance-code * @date 2019/1/19 */@RestControllerpublic class TestController {    @RateLimitAspect    @GetMapping(&quot;/test&quot;)    public String test(){        return &quot;nihao&quot;;    }}    </code></pre><h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><blockquote><p>上文中的编码阶段算是结束了，总体来说就是自定义一个限流注解方便以后每次的使用，其实我这里做的还不够细致，如果可以的话可以自定义速率，本例中默认速率为5.0表示：想象下我们需要处理一个任务列表，但我们不希望每秒的任务提交超过五个。</p></blockquote><p><strong>话不多说开始测试</strong><br>首先打开JMeter并发测试工具类，定义好线程组，以及Http请求和结果树，在线程组和HTTP请求中输入必要的参数<br><em>JMeter线程组参数</em><br><br><br><img src="/2019/01/19/RateLimiter配合注解的使用/JMeter线程组参数.jpg" alt="线程组参数"><br><em>HTTP请求参数</em><br><br><br><img src="/2019/01/19/RateLimiter配合注解的使用/HTTP请求参数.png" alt="HTTP参数"><br><br><br><strong>启动测试</strong><br><em>可以看到有10个结果在结果树中</em><br><img src="/2019/01/19/RateLimiter配合注解的使用/结果树.jpg" alt="HTTP参数"><br><br><br><strong>分别查看10个HTTP请求的响应</strong><br><em>调用成功</em><br><img src="/2019/01/19/RateLimiter配合注解的使用/调用成功结果.jpg" alt="HTTP参数"><br><br><br><em>限流请求结果</em><br><img src="/2019/01/19/RateLimiter配合注解的使用/限流请求结果.jpg" alt="HTTP参数"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><pre><code>不管重试多少次都是10次请求有4次被限制访问，6次成功访问.因此我重新设置线程次的参数为20个线程，重新发送请求后得到结果为:6次成功，14次失败，得出结论美妙的认为提交不超过六个。对于为什么是五个而不是六个，在RateLimiter的github看下issue了解。</code></pre>]]></content>
      
      
      <categories>
          
          <category> RateLimiter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RateLimiter </tag>
            
            <tag> 限流 </tag>
            
            <tag> 自定义注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker部署maven私服</title>
      <link href="/2019/01/18/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2maven%E7%A7%81%E6%9C%8D/"/>
      <url>/2019/01/18/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2maven%E7%A7%81%E6%9C%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="使用docker配置maven私服"><a href="#使用docker配置maven私服" class="headerlink" title="使用docker配置maven私服"></a>使用docker配置maven私服</h1><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><blockquote><p>安装docker环境<br>使用docker -v查看服务器docker环境<br><img src="/2019/01/18/使用Docker部署maven私服/docker-env.png" alt="docker环境"></p></blockquote><h3 id="下拉nexus3镜像"><a href="#下拉nexus3镜像" class="headerlink" title="下拉nexus3镜像"></a>下拉nexus3镜像</h3><p><em>使用命令，拉去最新版本的nexus镜像</em></p><blockquote><p>docker pull sonatype/nexus3<br><img src="/2019/01/18/使用Docker部署maven私服/nexus-pull.png" alt="拉去nexus镜像"></p></blockquote><h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><p><em>使用命令</em></p><blockquote><p>docker run –rm -d –privileged=true -p 8088:8088 –name nexus -v /root/nexus-data:/var/nexus-data sonatype/nexus3</p></blockquote><pre><code>上面命令是指使用nexus3镜像创建并启动一个容器，然后指定暴露8081端口到对应主机的8081端口将容器内部/var/nexus-data挂载到主机/root/nexus-data目录。如果没有任何问题的话，Nexus应该是搭建成功了。此时在浏览器输入：http://ip:8081即可看到以下页面：(ip为远程主机的ip地址) </code></pre><p><img src="/2019/01/18/使用Docker部署maven私服/nexus-login.png" alt="登录nexus"><br><em>修改nexus帐号密码</em></p><blockquote><p>点击右上方的Sign in进行登录，初始账号密码为admin/admin123.请登录后修改密码<br><em>如下图</em><br><img src="/2019/01/18/使用Docker部署maven私服/nexusupdate.jpg" alt="修改密码"><br>可以看到默认情况下Nexus会帮我们创建了几个仓库，仔细观察红色框住的地方，里面有几种仓库的类型，解释如下：</p></blockquote><ol><li>proxy 远程仓库的代理，比如说nexus配置了一个central repository的proxy,当用户向这个proxy请求一个</li><li>artifact的时候，会现在本地查找，如果找不到，则会从远程仓库下载，然后返回给用户。</li><li>hosted 宿主仓库，用户可以把自己的一些仓库deploy到这个仓库中</li><li>group 仓库组，是nexus特有的概念，目的是将多个仓库整合，对用户暴露统一的地址，这样就不需要配置多个仓库地址。<blockquote><p>下面我们仔细看一下里面的一些仓库。点击maven-central仓库:<br><img src="/2019/01/18/使用Docker部署maven私服/20180307192826615.jpg" alt="仓库"><br>可以看到是一个proxy类型的仓库，他代理的远程仓库地址是<a href="https://repo1.maven.org/maven2/。" target="_blank" rel="noopener">https://repo1.maven.org/maven2/。</a><br><br>后退，在进入maven-public查看:<br><img src="/2019/01/18/使用Docker部署maven私服/nexus-cha.png" alt="pubilc"><br><strong>可以看到这是一个group类型的仓库，里面包含了maven-releases/maven-snapshots/maven-central仓库，意思是我们只需要在本地添加这个仓库，则可以依赖到上述3个仓库中的库了。</strong></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> maven私服 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> maven </tag>
            
            <tag> nexus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon+Feign扩展</title>
      <link href="/2019/01/18/Ribbon-Feign%E6%89%A9%E5%B1%95/"/>
      <url>/2019/01/18/Ribbon-Feign%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Ribbon扩展"><a href="#Ribbon扩展" class="headerlink" title="Ribbon扩展"></a>Ribbon扩展</h2><h3 id="切换Ribbon加载策略，ribbon默认加载策略为懒加载，修改为饥饿加载"><a href="#切换Ribbon加载策略，ribbon默认加载策略为懒加载，修改为饥饿加载" class="headerlink" title="切换Ribbon加载策略，ribbon默认加载策略为懒加载，修改为饥饿加载"></a>切换Ribbon加载策略，ribbon默认加载策略为懒加载，修改为饥饿加载</h3><pre><code>ribbon:  eager-load:    enabled: true    # 多个用,分隔    clients: microservice-provider-user</code></pre><h3 id="Feign配置自定义【通用配置】"><a href="#Feign配置自定义【通用配置】" class="headerlink" title="Feign配置自定义【通用配置】"></a>Feign配置自定义【通用配置】</h3><pre><code>feign:  client:    config:      default:        connectTimeout: 5000        readTimeout: 5000        loggerLevel: basic</code></pre><h3 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h3><pre><code>如果你不小心又使用了Java代码配置Feign，同时又使用了配置属性配置Feign，那么使用配置属性的优先级更高。配置属性配置的方式将会覆盖Java代码配置。如果你想修改代码配置方式的优先级，可使用如下属性：feign.client.default-to-properties=false 。  </code></pre><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>一些场景下，我们可能需要对请求或响应进行压缩，此时可使用以下属性启用Feign的压缩功能。</p><pre><code>feign.compression.request.enabled=truefeign.compression.response.enabled=true</code></pre><p>对于请求的压缩，Feign还提供了更为详细的设置，例如：</p><pre><code>feign.compression.request.enabled=truefeign.compression.request.mime-types=text/xml,application/xml,application/jsonfeign.compression.request.min-request-size=2048</code></pre><p>其中，feign.compression.request.mime-types 用于支持的媒体类型列表，默认是text/xml、application/xml以及application/json。<br>feign.compression.request.min-request-size 用于设置请求的最小阈值，默认是2048。</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作-人事管理项目开发</title>
      <link href="/2019/01/18/%E5%B7%A5%E4%BD%9C-%E4%BA%BA%E4%BA%8B%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
      <url>/2019/01/18/%E5%B7%A5%E4%BD%9C-%E4%BA%BA%E4%BA%8B%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;这是我的第二份工作的第二个项目，相比于第一个安全响应项目。这个项目是针对公司内部使用的人事管理系统。主要包含数据的导入和导出，已经公司人员的管理和工资记录的管理，另一个就是这个系统基本上都是我来开发的。除了框架是公司的一个同事搭建的，因为考虑到后期该系统会调用第三方接口因此框架设计使用的和公司一样的架子，引入公司封装好的一些启动器，关闭eureka注册中心后我就开始工作了，说是架子是公司同事搭建的其实本质的技术还是我来进行选择的。</p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringBoot+Mybatis-plus+Mybatis代码生成器+POI+SpringCloud+OpenFeign+swagger2+公司的一些工具类和异常处理等</span><br></pre></td></tr></table></figure><h3 id="开发前期"><a href="#开发前期" class="headerlink" title="开发前期"></a>开发前期</h3><p>&nbsp;&nbsp;&nbsp;&nbsp; 因为需求很简单这样我就需要先考虑系统的优化，考虑到并发小因此选择使用version字段来实现乐观锁，使用mybatis-plus的乐观锁插件来控制接口的幂等性，从而解决防止同一人操作同一条数据带来的脏数据问题。对于一些工资计算算法进行封装工具类，创建常用的策略模式,这些做完后基本上就可以开始开发了。</p><h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这是我第二次开发前后端分离的项目，关于前后端分离对我来说是便捷的，起码我不需要去考虑前后端数据的交互<br>了，但是这对刚刚进入工作不久的我不是个好事，因此在空闲时间我还是需要去研究前端学习一些前端的框架，保持自己的竞争力。<br><br><img src="/2019/01/18/工作-人事管理项目开发/blogHead.jpg" alt="乐观"></p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 工作日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术图谱</title>
      <link href="/2019/01/17/%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/"/>
      <url>/2019/01/17/%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是我收集的一些技术图片，是我平时写的一下项目的架构，以及一些用<br>到的流程图.</p></blockquote><h3 id="Java技术图片"><a href="#Java技术图片" class="headerlink" title="Java技术图片"></a>Java技术图片</h3><p><img src="/2019/01/17/技术图谱/技术.png" alt="技术图谱"></p><h3 id="Java高级体系结构图"><a href="#Java高级体系结构图" class="headerlink" title="Java高级体系结构图"></a>Java高级体系结构图</h3><p><img src="/2019/01/17/技术图谱/JAVA高级体系结构.png" alt="高级体系结构"></p><h3 id="毕业设计框架图"><a href="#毕业设计框架图" class="headerlink" title="毕业设计框架图"></a>毕业设计框架图</h3><p><img src="/2019/01/17/技术图谱/校园物流架构图.png" alt="校园物流架构图"></p><h3 id="异步化结构图"><a href="#异步化结构图" class="headerlink" title="异步化结构图"></a>异步化结构图</h3><p><img src="/2019/01/17/技术图谱/调用第三方短信异步化.png" alt="调用第三方短信异步化"></p>]]></content>
      
      
      <categories>
          
          <category> 技术图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> technology_image </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SB框架]SpringBoot中对多个配置文件中的属性进行提取的简易方法</title>
      <link href="/2019/01/17/SB%E6%A1%86%E6%9E%B6-SpringBoot%E4%B8%AD%E5%AF%B9%E5%A4%9A%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E8%BF%9B%E8%A1%8C%E6%8F%90%E5%8F%96%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/"/>
      <url>/2019/01/17/SB%E6%A1%86%E6%9E%B6-SpringBoot%E4%B8%AD%E5%AF%B9%E5%A4%9A%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E8%BF%9B%E8%A1%8C%E6%8F%90%E5%8F%96%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>SpringBoot中对多个配置文件中的属性进行提取的简易方法</p></blockquote><p><strong>我们要提取一下属性:</strong><br><img src="/2019/01/17/SB框架-SpringBoot中对多个配置文件中的属性进行提取的简易方法/201811152203225.png" alt="我们要提取一下属性"><br><strong>首先创建一个GirlProperties类</strong><br><img src="/2019/01/17/SB框架-SpringBoot中对多个配置文件中的属性进行提取的简易方法/20181115220338950.png" alt="首先创建一个GirlProperties类"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.springboot.properties;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @BelongsProject: springbootideademo</span><br><span class="line"> * @BelongsPackage: com.springboot.properties</span><br><span class="line"> * @Author: HUANG</span><br><span class="line"> * @CreateTime: 2018-11-15 21:46</span><br><span class="line"> * @PROJECT_NAME: springbootideademo</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;girl&quot;)</span><br><span class="line">public class GirlProperties &#123;</span><br><span class="line">    private String cupSize;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public String getCupSize() &#123;</span><br><span class="line">        return cupSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCupSize(String cupSize) &#123;</span><br><span class="line">        this.cupSize = cupSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式:<br><img src="/2019/01/17/SB框架-SpringBoot中对多个配置文件中的属性进行提取的简易方法/20181115220407188.png" alt="调用方式"></p><p>通过属性调用:<br><img src="/2019/01/17/SB框架-SpringBoot中对多个配置文件中的属性进行提取的简易方法/20181115220501614.png" alt="通过属性调用"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
